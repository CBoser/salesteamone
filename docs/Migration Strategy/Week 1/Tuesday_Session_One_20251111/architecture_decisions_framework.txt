================================================================================
CODING SYSTEM ARCHITECTURE: THREE CRITICAL DECISIONS
================================================================================
Session 2: Decision Framework (Tuesday, November 11, 2025)
Purpose: Present evidence-based options for the 3 decisions that determine database schema
Audience: Corey (decision-maker), William Hatley (Richmond expert), Alicia Vandehey (Holt expert)
Prerequisites: richmond_hierarchy_map.txt, holt_hierarchy_map.txt, richmond_holt_comparison.txt

================================================================================
EXECUTIVE GUIDANCE
================================================================================

These three decisions are FOUNDATIONAL - all subsequent work depends on them.

âœ… Complete Session 1 (Understanding Current State):
  • Richmond hierarchy mapped (✓)
  • Holt hierarchy mapped (✓)
  • Side-by-side comparison completed (✓)

⏭️  Session 2 Goal: Make THREE CRITICAL DECISIONS

The decisions:
  1. Plan-Pack Relationships: Universal vs Plan-Specific packs
  2. Plan-Elevation Modeling: Variant vs Dimension approach
  3. Internal Option Code Philosophy: Systematic vs Mnemonic codes

Decision Order:
  These decisions are SEQUENTIAL. Decision #1 affects #2, which affects #3.
  We MUST decide them in order.

Time Allocation:
  • Decision 1: 1.5 hours (most complex, highest impact)
  • Decision 2: 1 hour (evidence strongly favors one option)
  • Decision 3: 30 minutes (can support both approaches)

================================================================================
DECISION #1: PLAN-PACK RELATIONSHIPS
================================================================================
Duration: 1.5 hours
Impact: Determines core database schema (packs table, plan_packs junction, queries)

THE QUESTION:
âž¡ï¸  Are packs universal (one pack used across multiple plans) 
   OR plan-specific (each plan has its own pack variants)?

This determines:
  • How many pack records in database (315 universal vs 2,000+ plan-specific)
  • Whether updates affect one pack or many
  • Query complexity for "get materials for plan X"
  • How options cascade across plans

--------------------------------------------------------------------------------
OPTION A: UNIVERSAL PACKS
--------------------------------------------------------------------------------

Model: One pack definition → Used by multiple plans

Example:
  Pack: "Extended Great Room Foundation" (ID: |10.60x)
  Used by: G603, G914, 1649A, and 8 other plans
  
  When customer selects XGREAT:
    Database looks up: Which packs are part of XGREAT option?
    Answer: |10.60x (Foundation), |11.60x (Joists), |20.60x (Walls), etc.
    Then: Apply these packs to ANY plan that supports XGREAT

Database Structure:
  packs table:
    pack_id (PK): |10.60x
    pack_name: Extended Great Room Foundation
    phase: 10
    option_code: XGREAT
    materials: [list of materials]
  
  plan_pack_availability table:
    plan_id: G603
    pack_id: |10.60x
    is_available: true
  
  Query: "Get materials for Plan G603 with XGREAT option"
    1. Find packs where option_code = XGREAT
    2. Check plan_pack_availability: G603 + |10.60x = available
    3. Return materials from packs table

âœ… ADVANTAGES:
  1. Reduce duplication
     - One pack definition instead of 46 copies (one per plan)
     - Easier to maintain: change once, affects all plans
     - Smaller database: 315 packs instead of 14,490 (315 × 46)
  
  2. Encourages standardization
     - XGREAT means same thing across all plans
     - Consistent customer experience
     - Easier to train: "XGREAT always includes these materials"
  
  3. Easier updates
     - Change lumber specs for Extended Great Room
     - Update ONE pack: |10.60x
     - Affects all plans using XGREAT automatically
  
  4. Simpler option management
     - One option (XGREAT) → one set of packs
     - Clear relationship: option to packs is 1:many
  
  5. Better for reporting
     - "How many customers chose XGREAT across all plans?"
     - Single query: COUNT where option_code = XGREAT
  
  6. Matches Richmond evidence
     - reference_PackNames shows 315 packs for 46 plans
     - 315/46 = 6.8 packs per plan (if all plan-specific)
     - More likely: ~100 universal packs × 46 plans = 315 total references

❌ DISADVANTAGES:
  1. Less granular tracking
     - Can't easily see "how is XGREAT different in Plan G603 vs G914?"
     - Assumes all plans use XGREAT identically
     - Hidden variations might exist
  
  2. Harder to customize per plan
     - What if G603 needs slightly different materials for XGREAT?
     - Must create a SECOND pack (|10.60x-G603) = destroys universality
     - Or use overrides (complex)
  
  3. Availability tracking complexity
     - Need plan_pack_availability junction table
     - Must maintain "which packs work on which plans"
     - 46 plans × 100 universal packs = 4,600 availability records
  
  4. Ambiguous ownership
     - Who "owns" the universal pack definition?
     - Richmond team or Holt team?
     - How to resolve conflicts?
  
  5. Risk of false assumptions
     - What if XGREAT is NOT actually the same across plans?
     - Current Excel might hide variations
     - Need validation before assuming universality

âš ï¸  CRITICAL QUESTION FOR DOMAIN EXPERTS:
  Does XGREAT (Extended Great Room) use the SAME materials in:
    - Plan G603?
    - Plan G914?
    - Plan 1649A?
  
  If YES → Universal packs make sense
  If NO → Plan-specific packs required

--------------------------------------------------------------------------------
OPTION B: PLAN-SPECIFIC PACKS
--------------------------------------------------------------------------------

Model: Each plan has its own pack variants

Example:
  Pack: "Extended Great Room Foundation - Plan G603" (ID: G603-|10.60x)
  Pack: "Extended Great Room Foundation - Plan G914" (ID: G914-|10.60x)
  Pack: "Extended Great Room Foundation - Plan 1649A" (ID: 1649A-|10.60x)
  
  Same concept (Extended Great Room), but separate implementations per plan.
  
  When customer selects XGREAT on Plan G603:
    Database looks up: Packs for G603 with option_code = XGREAT
    Answer: G603-|10.60x, G603-|11.60x, G603-|20.60x
    Materials specific to G603's implementation

Database Structure:
  packs table:
    pack_id (PK): G603-|10.60x
    plan_id (FK): G603
    pack_name: Extended Great Room Foundation
    phase: 10
    option_code: XGREAT
    materials: [list of materials specific to G603]
  
  Query: "Get materials for Plan G603 with XGREAT option"
    1. Find packs where plan_id = G603 AND option_code = XGREAT
    2. Return materials directly (no availability check needed)

âœ… ADVANTAGES:
  1. Precise tracking
     - Know exactly which materials go with which plan
     - Can see plan-specific variations clearly
     - No ambiguity about "which version of XGREAT"
  
  2. Easier to customize per plan
     - Plan G603 needs different lumber for XGREAT? Just update G603's pack.
     - No risk of affecting other plans
     - Each plan can evolve independently
  
  3. No availability complexity
     - Don't need plan_pack_availability junction table
     - Pack exists = available for that plan
     - Simpler relationships
  
  4. Matches Holt evidence
     - Holt option codes include plan number: 167010105, 164910105
     - Same option (01), different plan (167 vs 164) = different code
     - Strongly suggests plan-specific packs
  
  5. Clear ownership
     - Richmond team owns Richmond plan packs
     - Holt team owns Holt plan packs
     - No conflict about "who defines XGREAT"
  
  6. Easier migration
     - Copy existing sheets as-is
     - Each plan sheet → separate pack records
     - No need to identify "universal vs specific" during migration

❌ DISADVANTAGES:
  1. More duplication
     - Same pack concept repeated 46 times (once per plan)
     - If XGREAT is truly identical, we're storing 46 copies
     - Database size: 14,490 packs (315 × 46) instead of 315
  
  2. Harder to update
     - Change lumber specs for Extended Great Room
     - Must update 46 separate pack records (one per plan)
     - Risk of inconsistency: update 45, miss 1
  
  3. Larger database
     - More pack records = more storage
     - More records to query
     - Potentially slower queries
  
  4. Harder to enforce standards
     - Plans can diverge over time
     - XGREAT might mean different things in different plans
     - Harder to ensure consistent customer experience
  
  5. More complex reporting
     - "How many customers chose XGREAT across all plans?"
     - Must aggregate: COUNT where option_code = XGREAT GROUP BY plan_id
     - Then sum across plans

âš ï¸  CRITICAL QUESTION FOR DOMAIN EXPERTS:
  Do you ever need to:
    - Update ONE pack (e.g., XGREAT) across ALL plans at once?
    - Or do you always customize per plan?
  
  If update across all → Universal packs better
  If customize per plan → Plan-specific packs better

--------------------------------------------------------------------------------
OPTION C: HYBRID (Pack Templates + Plan Instances)
--------------------------------------------------------------------------------

Model: Universal templates + Plan-specific instances

Example:
  Template: "Extended Great Room Foundation" (ID: TMPL-|10.60x)
    - Defines standard materials
    - Owned by leadership/standards committee
  
  Instance: "Extended Great Room Foundation - Plan G603" (ID: G603-|10.60x)
    - Inherits from template
    - Can override specific materials
    - Owned by plan designer
  
  When customer selects XGREAT on Plan G603:
    Database looks up: Instance for G603-|10.60x
    If instance has overrides → use instance materials
    If no overrides → use template materials

Database Structure:
  pack_templates table:
    template_id (PK): TMPL-|10.60x
    template_name: Extended Great Room Foundation
    phase: 10
    option_code: XGREAT
    materials: [default materials]
  
  pack_instances table:
    instance_id (PK): G603-|10.60x
    template_id (FK): TMPL-|10.60x
    plan_id (FK): G603
    overrides: [materials that differ from template]
  
  Query: "Get materials for Plan G603 with XGREAT option"
    1. Find instance where plan_id = G603 AND option_code = XGREAT
    2. Get materials from instance (if overrides exist)
    3. Merge with materials from template (for non-overridden items)

âœ… ADVANTAGES:
  1. Standardization + Flexibility
     - Templates encourage consistency
     - Instances allow customization
     - Best of both worlds
  
  2. Clear change tracking
     - Can see "what's different from standard?"
     - Instance.overrides = deviations from template
     - Audit trail of customizations
  
  3. Easy bulk updates
     - Update template → affects all plans using defaults
     - Plans with overrides remain unchanged
     - Selective propagation
  
  4. Supports both workflows
     - Standard options: Just use template (no instance needed)
     - Custom options: Create instance with overrides
     - Flexible for different option types
  
  5. Better for learning
     - New designers start with templates
     - Learn standard practices
     - Customize only when needed

❌ DISADVANTAGES:
  1. Most complex schema
     - Need templates table
     - Need instances table  
     - Need template_instances relationship
     - More joins in queries
  
  2. Steeper learning curve
     - Team must understand template vs instance concept
     - More training required
     - More ways to make mistakes
  
  3. Override management complexity
     - How are overrides stored? Full material or just delta?
     - What happens when template changes? Cascade or preserve overrides?
     - Versioning challenges
  
  4. Migration complexity
     - Must identify "template" during migration
     - Must identify "instance overrides"
     - How to automatically detect variations?
  
  5. Two sources of truth
     - Template says X, instance says Y
     - Which is correct?
     - Requires governance

--------------------------------------------------------------------------------
RECOMMENDATION: OPTION A (Universal Packs) with validation
--------------------------------------------------------------------------------

Rationale:
  1. Richmond evidence suggests universality
     - 315 packs for 46 plans = ~6.8 per plan
     - If all plan-specific: implausibly low
     - More likely: ~100 universal packs reused
  
  2. Holt evidence can be translated
     - Yes, Holt uses plan-specific codes (167010105)
     - But this might be for tracking, not because materials differ
     - Can map Holt plan-specific → Richmond universal
  
  3. Easier to start universal, split later if needed
     - Begin with universal packs
     - If we discover plan-specific needs → clone pack, make plan-specific
     - Hard to go OTHER direction (merge plan-specific into universal)
  
  4. Simpler database
     - Fewer records
     - Simpler queries
     - Better performance
  
  5. Encourages standardization
     - Forces conversation: "Why is this plan different?"
     - Reduces unintentional divergence
     - Better for long-term maintenance

âš ï¸  VALIDATION REQUIRED:
  Before finalizing this decision, MUST validate with domain experts:
  
  Questions for William Hatley (Richmond):
    Q1: Does XGREAT use the same materials in all plans, or does it vary?
    Q2: When you update an option (like XGREAT), do you update all plans together?
    Q3: Are there options that are plan-specific by design?
  
  Questions for Alicia Vandehey (Holt):
    Q1: Why do your option codes include plan numbers (167 vs 164)?
    Q2: Is it because materials differ, or for tracking purposes?
    Q3: If materials are the same across plans, would you be OK with a universal approach?

If validation shows materials truly differ by plan → Switch to Option B or C

--------------------------------------------------------------------------------
DECISION #1 DELIVERABLE: 
--------------------------------------------------------------------------------

[ ] Option chosen: _________________
[ ] Validation questions answered
[ ] Database schema implications documented
[ ] Impact on Decisions #2 and #3 noted

================================================================================
DECISION #2: PLAN-ELEVATION MODELING
================================================================================
Duration: 1 hour
Impact: Determines how plan and elevation relate in database

THE QUESTION:
âž¡ï¸  Is elevation a VARIANT of a plan (separate plan records)
   OR a DIMENSION of a plan (base plan + elevation attributes)?

This determines:
  • Whether Plan 1670A, 1670B, 1670C, 1670D are 4 separate plans or 1 plan with 4 elevations
  • How plan metadata (square footage, bedroom count) is stored
  • Query complexity for "get all elevations of plan X"
  • How materials are linked to plan-elevation combinations

--------------------------------------------------------------------------------
OPTION A: ELEVATION AS VARIANT (Separate Plan Records)
--------------------------------------------------------------------------------

Model: Each plan-elevation combo = separate plan

Example:
  Plan 1670A (ID: 1670A)
  Plan 1670B (ID: 1670B)
  Plan 1670C (ID: 1670C)
  Plan 1670D (ID: 1670D)
  
  These are 4 SEPARATE plans in the database.

Database Structure:
  plans table:
    plan_id (PK): 1670A
    plan_number: 1670
    elevation: A
    square_feet: 2,450
    bedrooms: 3
    bathrooms: 2.5
    garage_type: 2-Car Left
  
  plans table:
    plan_id (PK): 1670B
    plan_number: 1670
    elevation: B
    square_feet: 2,520
    bedrooms: 4
    bathrooms: 2.5
    garage_type: 2-Car Right
  
  Query: "Get all materials for Plan 1670A"
    SELECT * FROM plan_materials WHERE plan_id = '1670A'

âœ… ADVANTAGES:
  1. Simpler queries
     - One plan = one record
     - No joins needed for basic queries
     - Easy to understand: plan_id = '1670A'
  
  2. Easier to track differences
     - Each elevation has own SF, bedroom count, etc.
     - Clear what's unique to this elevation
     - No "base plan + overrides" complexity
  
  3. Matches sheet naming
     - Richmond: LE93 G603B (sheet name includes elevation)
     - Holt: 1670ABCD (sheet name includes all elevations)
     - Natural mapping: sheet → plan record
  
  4. Elevation-specific customization
     - Can add attributes specific to one elevation
     - No constraints from base plan
     - Maximum flexibility

❌ DISADVANTAGES:
  1. Data duplication
     - Must repeat plan metadata for each elevation
     - If plan name changes → update 4 records
     - Risk of inconsistency: update 3, miss 1
  
  2. Harder to see base plan
     - Which is the "main" plan? 1670A? 1670?
     - Can't easily query "all elevations of plan 1670"
     - Must parse plan_number: "SELECT * WHERE plan_number = 1670"
  
  3. Update burden
     - Change plan-level attribute (builder, subdivision)
     - Must update N records (one per elevation)
     - More work, more errors
  
  4. Unclear "plan count"
     - Do we have 10 plans or 40 plans?
     - Depends on whether you count elevations separately
     - Confusing for reporting

âš ï¸  CRITICAL QUESTION FOR DOMAIN EXPERTS:
  When you say "we have 10 plans," do you mean:
    - 10 base plans (and 40 plan-elevation combos), or
    - Literally 10 separate plans?

--------------------------------------------------------------------------------
OPTION B: ELEVATION AS DIMENSION (Base Plan + Elevation Attributes)
--------------------------------------------------------------------------------

Model: Base plan + separate elevation records

Example:
  Plan 1670 (base)
    - Plan-level attributes: name, builder, subdivision, base SF
  
  Elevation A (of Plan 1670)
    - Elevation-specific attributes: garage type, SF, bedrooms
  
  Elevation B (of Plan 1670)
    - Different values for same attributes

Database Structure:
  plans table:
    plan_id (PK): 1670
    plan_name: "The Madison"
    builder: Holt Homes
    subdivision: Creek Ridge
    base_square_feet: 2,450
  
  elevations table:
    elevation_id (PK): 1670-A
    plan_id (FK): 1670
    elevation_letter: A
    square_feet: 2,450
    bedrooms: 3
    bathrooms: 2.5
    garage_type: 2-Car Left
  
  elevations table:
    elevation_id (PK): 1670-B
    plan_id (FK): 1670
    elevation_letter: B
    square_feet: 2,520
    bedrooms: 4
    bathrooms: 2.5
    garage_type: 2-Car Right
  
  Query: "Get all materials for Plan 1670, Elevation A"
    SELECT * FROM plan_materials pm
    JOIN elevations e ON pm.elevation_id = e.elevation_id
    WHERE e.plan_id = 1670 AND e.elevation_letter = 'A'

âœ… ADVANTAGES:
  1. DRY principle
     - Plan metadata stored ONCE
     - Change plan name → one UPDATE
     - No risk of inconsistency
  
  2. Clear base plan concept
     - Easy to see "which elevations belong to this plan"
     - Query: SELECT * FROM elevations WHERE plan_id = 1670
     - Returns: A, B, C, D
  
  3. Easier updates
     - Change plan-level attribute (builder)
     - One UPDATE affects all elevations
     - Less maintenance
  
  4. Clear plan count
     - "We have 10 plans" → 10 records in plans table
     - "We have 40 elevations" → 40 records in elevations table
     - Unambiguous for reporting
  
  5. Matches Holt's single-encoding approach
     - Holt stores elevation ONCE in option code
     - No triple-encoding issues
     - Same philosophy: one authoritative source
  
  6. Prevents Richmond's triple-encoding problem
     - Elevation stored in ONE table (elevations)
     - Retrieved via joins (not text encoding)
     - No sync errors

❌ DISADVANTAGES:
  1. More complex queries
     - Must join plans + elevations
     - Can't just query plan_id = '1670A'
     - Slightly more work for developers
  
  2. More complex schema
     - Two tables instead of one
     - Relationship to maintain
     - Requires foreign key understanding
  
  3. What if elevations share nothing?
     - If elevations are TOTALLY different → no shared base plan
     - Might force artificial "base plan" concept
     - Risk of empty base plan records

âš ï¸  CRITICAL QUESTION FOR DOMAIN EXPERTS:
  Do elevations of the same plan share common attributes?
    - Plan name?
    - Builder?
    - Subdivision?
    - Marketing materials?
  
  If YES → Base plan concept makes sense
  If NO → Maybe they're truly separate plans?

--------------------------------------------------------------------------------
OPTION C: HYBRID (Base Plan + Elevation Overrides)
--------------------------------------------------------------------------------

Model: Base plan defines defaults, elevations override specific attributes

Example:
  Plan 1670 (base)
    - square_feet: 2,450 (default)
    - bedrooms: 3 (default)
    - bathrooms: 2.5 (default)
  
  Elevation B overrides:
    - square_feet: 2,520 (override default)
    - bedrooms: 4 (override default)
    - bathrooms: 2.5 (use default)

Database Structure:
  plans table:
    plan_id (PK): 1670
    plan_name: "The Madison"
    default_square_feet: 2,450
    default_bedrooms: 3
    default_bathrooms: 2.5
  
  elevations table:
    elevation_id (PK): 1670-B
    plan_id (FK): 1670
    elevation_letter: B
    override_square_feet: 2,520  -- overrides default
    override_bedrooms: 4         -- overrides default
    override_bathrooms: NULL     -- uses default (2.5)
  
  Query: "Get attributes for Plan 1670, Elevation B"
    SELECT 
      p.plan_name,
      COALESCE(e.override_square_feet, p.default_square_feet) AS square_feet,
      COALESCE(e.override_bedrooms, p.default_bedrooms) AS bedrooms,
      COALESCE(e.override_bathrooms, p.default_bathrooms) AS bathrooms
    FROM plans p
    JOIN elevations e ON p.plan_id = e.plan_id
    WHERE e.elevation_id = '1670-B'

âœ… ADVANTAGES:
  1. Maximum efficiency
     - Store only what's different
     - No duplication of unchanged attributes
     - Smallest database size
  
  2. Clear deviation tracking
     - Can see exactly what varies per elevation
     - NULL = uses default
     - NOT NULL = customized for this elevation
  
  3. Easy to add new elevations
     - Create elevation record
     - Override only what differs
     - Inherits everything else

❌ DISADVANTAGES:
  1. Most complex queries
     - Must COALESCE every attribute
     - Hard to write, hard to read
     - Error-prone
  
  2. Most complex schema
     - Two tables with override logic
     - Requires understanding of inheritance
     - Steep learning curve
  
  3. Unclear "what are the attributes?"
     - Must check BOTH tables to know what exists
     - Can't just query elevations table
     - Discovery is harder

--------------------------------------------------------------------------------
RECOMMENDATION: OPTION B (Elevation as Dimension)
--------------------------------------------------------------------------------

Rationale:
  1. Strong evidence from Richmond's pain point
     - Triple-encoding creates sync errors
     - Database should store elevation ONCE
     - Option B aligns with this principle
  
  2. Holt already uses single-encoding
     - Elevation in option code (167010100)
     - Confirmed in Elevation column
     - Option B matches Holt's philosophy
  
  3. Cleaner database design
     - Follows normalization principles
     - Reduces duplication
     - Easier to maintain long-term
  
  4. Clear plan vs elevation separation
     - Plans have plan-level attributes
     - Elevations have elevation-level attributes
     - Intuitive model
  
  5. Easier updates
     - Change plan attribute → one UPDATE
     - No risk of missing an elevation
     - Less work for users

âš ï¸  VALIDATION REQUIRED:
  
  Questions for both teams:
    Q1: Do elevations share common plan-level attributes (name, builder, subdivision)?
    Q2: When you update plan info, do you update all elevations?
    Q3: Are there "elevation families" where some share attributes?
  
  If answers are YES → Option B confirmed
  If answers are NO → Reconsider Option A

--------------------------------------------------------------------------------
DECISION #2 DELIVERABLE:
--------------------------------------------------------------------------------

[ ] Option chosen: _________________
[ ] Validation questions answered
[ ] Schema implications documented
[ ] Impact on queries documented

================================================================================
DECISION #3: INTERNAL OPTION CODE PHILOSOPHY
================================================================================
Duration: 30 minutes
Impact: Determines how options are coded internally in database

THE QUESTION:
âž¡ï¸  Should internal option codes be SYSTEMATIC NUMERIC (like Holt)
   OR MNEMONIC ABBREVIATIONS (like Richmond)?

This determines:
  • How options are stored in options table
  • Whether codes are human-readable or machine-readable
  • Whether codes encode structure (plan, phase, option) or meaning (XGREAT)
  • How much translation is needed between companies

--------------------------------------------------------------------------------
OPTION A: SYSTEMATIC NUMERIC (Holt Style)
--------------------------------------------------------------------------------

Format: [PLAN][PHASE][OPTION][ELEV]
Example: 167010105-4085

Components:
  167   = Plan 1670
  01    = Phase 01
  01    = Option 01 within phase
  05    = Sequence or elevation indicator
  4085  = Item type (Lumber)

âœ… ADVANTAGES:
  1. Precise tracking
     - Code encodes plan, phase, option, elevation
     - Can parse programmatically
     - Know context from code alone
  
  2. No collisions
     - Each plan has own number space
     - 167010105 ≠ 164910105 (different plans)
     - Guaranteed unique
  
  3. Scalable
     - Add new plan → just use next plan number
     - Add new option → increment option number
     - No naming conflicts
  
  4. Consistent structure
     - All codes follow same format
     - Easy to validate
     - Predictable

❌ DISADVANTAGES:
  1. Not memorable
     - What is 167010105?
     - Requires lookup every time
     - Team won't memorize
  
  2. Long codes
     - 9-12 characters
     - Harder to type
     - More storage
  
  3. Not human-friendly
     - Can't communicate verbally
     - "Please add one-six-seven-oh-one-oh-one-oh-five"
     - vs "Please add Extended Great Room"

--------------------------------------------------------------------------------
OPTION B: MNEMONIC ABBREVIATIONS (Richmond Style)
--------------------------------------------------------------------------------

Format: [MEANINGFUL_ABBREVIATION]
Examples: XGREAT, FPSING01, 3CARA, SUN

âœ… ADVANTAGES:
  1. Memorable
     - XGREAT = Extended Great Room (obvious)
     - Team knows what it means
     - Easy to communicate
  
  2. Short codes
     - 3-8 characters
     - Easy to type
     - Less storage
  
  3. Human-friendly
     - Can say "add X-GREAT"
     - Natural communication
     - Better UX

❌ DISADVANTAGES:
  1. Inconsistent format
     - FPSING vs FPSING01 (why the 01?)
     - 3CARA vs XGREAT (why the 3?)
     - No standard
  
  2. Collision risk
     - What if two options both want "SUN"?
     - Must manually check uniqueness
     - Hard to scale
  
  3. Less information
     - Code doesn't tell you plan or phase
     - Must query database for context
     - Can't parse programmatically

--------------------------------------------------------------------------------
OPTION C: BOTH (Translation Layer)
--------------------------------------------------------------------------------

Model: Support BOTH via translation table

Internal representation: Systematic numeric (like Holt)
Display representation: Mnemonic abbreviation (like Richmond)
Translation: Bidirectional mapping

Database Structure:
  options table (internal):
    option_id (PK): 167010105
    plan_id: 1670
    phase: 01
    option_sequence: 01
    elevation: 05
    option_name: Extended Great Room
  
  option_translations table:
    holt_code: 167010105
    richmond_code: XGREAT
    universal_name: EXTENDED_GREAT_ROOM
    display_name: "Extended Great Room"
  
  Usage:
    Holt team sees: 167010105
    Richmond team sees: XGREAT
    Database stores: Both, plus universal_name for reporting

âœ… ADVANTAGES:
  1. Best of both worlds
     - Precision of systematic codes
     - Memorability of mnemonic codes
     - Each team uses familiar format
  
  2. Smooth transition
     - Richmond team keeps using XGREAT
     - Holt team keeps using 167010105
     - Database handles translation
  
  3. Unified reporting
     - Universal name for cross-company reports
     - "Extended Great Room" not "XGREAT" or "167010105"
     - Clear business meaning
  
  4. Flexible display
     - Can show either code depending on context
     - UI can toggle between formats
     - Power users can see both

❌ DISADVANTAGES:
  1. More complex schema
     - Need translation table
     - Need to maintain mappings
     - More joins in queries
  
  2. Sync complexity
     - What if translation is missing?
     - What if codes don't align (XGREAT for Richmond, but what for Holt)?
     - Requires governance
  
  3. Steeper learning curve
     - Team must understand translation
     - More training needed
     - More ways to make mistakes

--------------------------------------------------------------------------------
RECOMMENDATION: OPTION C (Both via Translation Layer)
--------------------------------------------------------------------------------

Rationale:
  1. Respects both teams' workflows
     - Richmond team has 192 mnemonic codes memorized
     - Holt team uses systematic codes
     - Don't force either team to change
  
  2. Enables unified system
     - Universal names for reporting
     - Both teams can understand each other
     - Cross-company collaboration
  
  3. Better for learning-first philosophy
     - Can show BOTH codes to new hires
     - Explain why each exists
     - Teach systematic thinking via Holt codes
     - Teach business meaning via Richmond codes
  
  4. Future-proof
     - Can add more translation formats later
     - Can support external vendor codes
     - Flexible for integration

Implementation Notes:
  • Internal database uses systematic codes (option_id)
  • UI shows mnemonic codes (display_name)
  • Reports use universal names (universal_name)
  • Translation table maintained by admin

--------------------------------------------------------------------------------
DECISION #3 DELIVERABLE:
--------------------------------------------------------------------------------

[ ] Option chosen: _________________
[ ] Translation table design documented
[ ] UI display strategy defined
[ ] Migration plan for codes created

================================================================================
DECISION SUMMARY & NEXT STEPS
================================================================================

After completing these 3 decisions:

âœ… Decision #1: Plan-Pack Relationships → Determines pack table structure
âœ… Decision #2: Plan-Elevation Modeling → Determines plans/elevations tables
âœ… Decision #3: Option Code Philosophy → Determines options/translations tables

These decisions UNLOCK:
  • Database schema design (Week 2, Tuesday)
  • Table creation (Week 2, Wednesday)
  • Relationship mapping (Week 2, Thursday)
  • First prototype queries (Week 2, Friday)

Without these decisions, we CANNOT proceed.

TIME INVESTMENT: 6 hours today = saves 140+ hours over 12 weeks

Next Session: Database Schema Design (Wednesday, November 12)
  Input: 3 decisions from today
  Output: Complete SQL schema with all tables, relationships, constraints
  
================================================================================
END DECISION FRAMEWORK
================================================================================
