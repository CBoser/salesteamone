
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerContact
 * 
 */
export type CustomerContact = $Result.DefaultSelection<Prisma.$CustomerContactPayload>
/**
 * Model CustomerPricingTier
 * 
 */
export type CustomerPricingTier = $Result.DefaultSelection<Prisma.$CustomerPricingTierPayload>
/**
 * Model CustomerExternalId
 * 
 */
export type CustomerExternalId = $Result.DefaultSelection<Prisma.$CustomerExternalIdPayload>
/**
 * Model CustomerPricing
 * 
 */
export type CustomerPricing = $Result.DefaultSelection<Prisma.$CustomerPricingPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model PlanElevation
 * 
 */
export type PlanElevation = $Result.DefaultSelection<Prisma.$PlanElevationPayload>
/**
 * Model PlanOption
 * 
 */
export type PlanOption = $Result.DefaultSelection<Prisma.$PlanOptionPayload>
/**
 * Model PlanTemplateItem
 * 
 */
export type PlanTemplateItem = $Result.DefaultSelection<Prisma.$PlanTemplateItemPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model PricingHistory
 * 
 */
export type PricingHistory = $Result.DefaultSelection<Prisma.$PricingHistoryPayload>
/**
 * Model RandomLengthsPricing
 * 
 */
export type RandomLengthsPricing = $Result.DefaultSelection<Prisma.$RandomLengthsPricingPayload>
/**
 * Model Community
 * 
 */
export type Community = $Result.DefaultSelection<Prisma.$CommunityPayload>
/**
 * Model Lot
 * 
 */
export type Lot = $Result.DefaultSelection<Prisma.$LotPayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model JobOption
 * 
 */
export type JobOption = $Result.DefaultSelection<Prisma.$JobOptionPayload>
/**
 * Model Takeoff
 * 
 */
export type Takeoff = $Result.DefaultSelection<Prisma.$TakeoffPayload>
/**
 * Model TakeoffLineItem
 * 
 */
export type TakeoffLineItem = $Result.DefaultSelection<Prisma.$TakeoffLineItemPayload>
/**
 * Model TakeoffValidation
 * 
 */
export type TakeoffValidation = $Result.DefaultSelection<Prisma.$TakeoffValidationPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model VariancePattern
 * 
 */
export type VariancePattern = $Result.DefaultSelection<Prisma.$VariancePatternPayload>
/**
 * Model VarianceReview
 * 
 */
export type VarianceReview = $Result.DefaultSelection<Prisma.$VarianceReviewPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  ESTIMATOR: 'ESTIMATOR',
  PROJECT_MANAGER: 'PROJECT_MANAGER',
  FIELD_USER: 'FIELD_USER',
  VIEWER: 'VIEWER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const CustomerType: {
  PRODUCTION: 'PRODUCTION',
  SEMI_CUSTOM: 'SEMI_CUSTOM',
  FULL_CUSTOM: 'FULL_CUSTOM'
};

export type CustomerType = (typeof CustomerType)[keyof typeof CustomerType]


export const PlanType: {
  SINGLE_STORY: 'SINGLE_STORY',
  TWO_STORY: 'TWO_STORY',
  THREE_STORY: 'THREE_STORY',
  DUPLEX: 'DUPLEX',
  TOWNHOME: 'TOWNHOME'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]


export const OptionCategory: {
  DECK: 'DECK',
  FENCING: 'FENCING',
  ROOM_ADDITION: 'ROOM_ADDITION',
  GARAGE: 'GARAGE',
  PATIO: 'PATIO',
  STRUCTURAL: 'STRUCTURAL',
  FINISH: 'FINISH',
  OTHER: 'OTHER'
};

export type OptionCategory = (typeof OptionCategory)[keyof typeof OptionCategory]


export const MaterialCategory: {
  DIMENSIONAL_LUMBER: 'DIMENSIONAL_LUMBER',
  ENGINEERED_LUMBER: 'ENGINEERED_LUMBER',
  SHEATHING: 'SHEATHING',
  PRESSURE_TREATED: 'PRESSURE_TREATED',
  HARDWARE: 'HARDWARE',
  CONCRETE: 'CONCRETE',
  ROOFING: 'ROOFING',
  SIDING: 'SIDING',
  INSULATION: 'INSULATION',
  DRYWALL: 'DRYWALL',
  OTHER: 'OTHER'
};

export type MaterialCategory = (typeof MaterialCategory)[keyof typeof MaterialCategory]


export const LotStatus: {
  AVAILABLE: 'AVAILABLE',
  RESERVED: 'RESERVED',
  SOLD: 'SOLD',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type LotStatus = (typeof LotStatus)[keyof typeof LotStatus]


export const JobStatus: {
  DRAFT: 'DRAFT',
  ESTIMATED: 'ESTIMATED',
  APPROVED: 'APPROVED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const TakeoffStatus: {
  DRAFT: 'DRAFT',
  IN_REVIEW: 'IN_REVIEW',
  VALIDATED: 'VALIDATED',
  APPROVED: 'APPROVED',
  ORDERED: 'ORDERED',
  DELIVERED: 'DELIVERED'
};

export type TakeoffStatus = (typeof TakeoffStatus)[keyof typeof TakeoffStatus]


export const POStatus: {
  DRAFT: 'DRAFT',
  APPROVED: 'APPROVED',
  SENT: 'SENT',
  CONFIRMED: 'CONFIRMED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type POStatus = (typeof POStatus)[keyof typeof POStatus]


export const VarianceScope: {
  PLAN_SPECIFIC: 'PLAN_SPECIFIC',
  CROSS_PLAN: 'CROSS_PLAN',
  COMMUNITY: 'COMMUNITY',
  BUILDER: 'BUILDER',
  REGIONAL: 'REGIONAL'
};

export type VarianceScope = (typeof VarianceScope)[keyof typeof VarianceScope]


export const PatternStatus: {
  DETECTED: 'DETECTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  APPLIED: 'APPLIED',
  REJECTED: 'REJECTED'
};

export type PatternStatus = (typeof PatternStatus)[keyof typeof PatternStatus]


export const ReviewDecision: {
  APPROVE: 'APPROVE',
  REJECT: 'REJECT',
  NEEDS_MORE_DATA: 'NEEDS_MORE_DATA',
  ESCALATE: 'ESCALATE'
};

export type ReviewDecision = (typeof ReviewDecision)[keyof typeof ReviewDecision]


export const NotificationType: {
  JOB_CREATED: 'JOB_CREATED',
  JOB_APPROVED: 'JOB_APPROVED',
  PO_APPROVED: 'PO_APPROVED',
  DELIVERY_SCHEDULED: 'DELIVERY_SCHEDULED',
  DELIVERY_LATE: 'DELIVERY_LATE',
  VARIANCE_DETECTED: 'VARIANCE_DETECTED',
  PATTERN_REVIEW_REQUIRED: 'PATTERN_REVIEW_REQUIRED',
  SYSTEM_ALERT: 'SYSTEM_ALERT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type CustomerType = $Enums.CustomerType

export const CustomerType: typeof $Enums.CustomerType

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

export type OptionCategory = $Enums.OptionCategory

export const OptionCategory: typeof $Enums.OptionCategory

export type MaterialCategory = $Enums.MaterialCategory

export const MaterialCategory: typeof $Enums.MaterialCategory

export type LotStatus = $Enums.LotStatus

export const LotStatus: typeof $Enums.LotStatus

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type TakeoffStatus = $Enums.TakeoffStatus

export const TakeoffStatus: typeof $Enums.TakeoffStatus

export type POStatus = $Enums.POStatus

export const POStatus: typeof $Enums.POStatus

export type VarianceScope = $Enums.VarianceScope

export const VarianceScope: typeof $Enums.VarianceScope

export type PatternStatus = $Enums.PatternStatus

export const PatternStatus: typeof $Enums.PatternStatus

export type ReviewDecision = $Enums.ReviewDecision

export const ReviewDecision: typeof $Enums.ReviewDecision

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerContact`: Exposes CRUD operations for the **CustomerContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerContacts
    * const customerContacts = await prisma.customerContact.findMany()
    * ```
    */
  get customerContact(): Prisma.CustomerContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerPricingTier`: Exposes CRUD operations for the **CustomerPricingTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerPricingTiers
    * const customerPricingTiers = await prisma.customerPricingTier.findMany()
    * ```
    */
  get customerPricingTier(): Prisma.CustomerPricingTierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerExternalId`: Exposes CRUD operations for the **CustomerExternalId** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerExternalIds
    * const customerExternalIds = await prisma.customerExternalId.findMany()
    * ```
    */
  get customerExternalId(): Prisma.CustomerExternalIdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerPricing`: Exposes CRUD operations for the **CustomerPricing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerPricings
    * const customerPricings = await prisma.customerPricing.findMany()
    * ```
    */
  get customerPricing(): Prisma.CustomerPricingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planElevation`: Exposes CRUD operations for the **PlanElevation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanElevations
    * const planElevations = await prisma.planElevation.findMany()
    * ```
    */
  get planElevation(): Prisma.PlanElevationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planOption`: Exposes CRUD operations for the **PlanOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanOptions
    * const planOptions = await prisma.planOption.findMany()
    * ```
    */
  get planOption(): Prisma.PlanOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planTemplateItem`: Exposes CRUD operations for the **PlanTemplateItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanTemplateItems
    * const planTemplateItems = await prisma.planTemplateItem.findMany()
    * ```
    */
  get planTemplateItem(): Prisma.PlanTemplateItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pricingHistory`: Exposes CRUD operations for the **PricingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingHistories
    * const pricingHistories = await prisma.pricingHistory.findMany()
    * ```
    */
  get pricingHistory(): Prisma.PricingHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.randomLengthsPricing`: Exposes CRUD operations for the **RandomLengthsPricing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RandomLengthsPricings
    * const randomLengthsPricings = await prisma.randomLengthsPricing.findMany()
    * ```
    */
  get randomLengthsPricing(): Prisma.RandomLengthsPricingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.community`: Exposes CRUD operations for the **Community** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communities
    * const communities = await prisma.community.findMany()
    * ```
    */
  get community(): Prisma.CommunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lot`: Exposes CRUD operations for the **Lot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lots
    * const lots = await prisma.lot.findMany()
    * ```
    */
  get lot(): Prisma.LotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobOption`: Exposes CRUD operations for the **JobOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobOptions
    * const jobOptions = await prisma.jobOption.findMany()
    * ```
    */
  get jobOption(): Prisma.JobOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.takeoff`: Exposes CRUD operations for the **Takeoff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Takeoffs
    * const takeoffs = await prisma.takeoff.findMany()
    * ```
    */
  get takeoff(): Prisma.TakeoffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.takeoffLineItem`: Exposes CRUD operations for the **TakeoffLineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TakeoffLineItems
    * const takeoffLineItems = await prisma.takeoffLineItem.findMany()
    * ```
    */
  get takeoffLineItem(): Prisma.TakeoffLineItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.takeoffValidation`: Exposes CRUD operations for the **TakeoffValidation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TakeoffValidations
    * const takeoffValidations = await prisma.takeoffValidation.findMany()
    * ```
    */
  get takeoffValidation(): Prisma.TakeoffValidationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variancePattern`: Exposes CRUD operations for the **VariancePattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VariancePatterns
    * const variancePatterns = await prisma.variancePattern.findMany()
    * ```
    */
  get variancePattern(): Prisma.VariancePatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.varianceReview`: Exposes CRUD operations for the **VarianceReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VarianceReviews
    * const varianceReviews = await prisma.varianceReview.findMany()
    * ```
    */
  get varianceReview(): Prisma.VarianceReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Customer: 'Customer',
    CustomerContact: 'CustomerContact',
    CustomerPricingTier: 'CustomerPricingTier',
    CustomerExternalId: 'CustomerExternalId',
    CustomerPricing: 'CustomerPricing',
    Plan: 'Plan',
    PlanElevation: 'PlanElevation',
    PlanOption: 'PlanOption',
    PlanTemplateItem: 'PlanTemplateItem',
    Material: 'Material',
    Vendor: 'Vendor',
    PricingHistory: 'PricingHistory',
    RandomLengthsPricing: 'RandomLengthsPricing',
    Community: 'Community',
    Lot: 'Lot',
    Job: 'Job',
    JobOption: 'JobOption',
    Takeoff: 'Takeoff',
    TakeoffLineItem: 'TakeoffLineItem',
    TakeoffValidation: 'TakeoffValidation',
    PurchaseOrder: 'PurchaseOrder',
    VariancePattern: 'VariancePattern',
    VarianceReview: 'VarianceReview',
    Notification: 'Notification',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "customer" | "customerContact" | "customerPricingTier" | "customerExternalId" | "customerPricing" | "plan" | "planElevation" | "planOption" | "planTemplateItem" | "material" | "vendor" | "pricingHistory" | "randomLengthsPricing" | "community" | "lot" | "job" | "jobOption" | "takeoff" | "takeoffLineItem" | "takeoffValidation" | "purchaseOrder" | "variancePattern" | "varianceReview" | "notification" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerContact: {
        payload: Prisma.$CustomerContactPayload<ExtArgs>
        fields: Prisma.CustomerContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          findFirst: {
            args: Prisma.CustomerContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          findMany: {
            args: Prisma.CustomerContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>[]
          }
          create: {
            args: Prisma.CustomerContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          createMany: {
            args: Prisma.CustomerContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>[]
          }
          delete: {
            args: Prisma.CustomerContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          update: {
            args: Prisma.CustomerContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          deleteMany: {
            args: Prisma.CustomerContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>[]
          }
          upsert: {
            args: Prisma.CustomerContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          aggregate: {
            args: Prisma.CustomerContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerContact>
          }
          groupBy: {
            args: Prisma.CustomerContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerContactCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerContactCountAggregateOutputType> | number
          }
        }
      }
      CustomerPricingTier: {
        payload: Prisma.$CustomerPricingTierPayload<ExtArgs>
        fields: Prisma.CustomerPricingTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerPricingTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerPricingTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload>
          }
          findFirst: {
            args: Prisma.CustomerPricingTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerPricingTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload>
          }
          findMany: {
            args: Prisma.CustomerPricingTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload>[]
          }
          create: {
            args: Prisma.CustomerPricingTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload>
          }
          createMany: {
            args: Prisma.CustomerPricingTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerPricingTierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload>[]
          }
          delete: {
            args: Prisma.CustomerPricingTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload>
          }
          update: {
            args: Prisma.CustomerPricingTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload>
          }
          deleteMany: {
            args: Prisma.CustomerPricingTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerPricingTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerPricingTierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload>[]
          }
          upsert: {
            args: Prisma.CustomerPricingTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingTierPayload>
          }
          aggregate: {
            args: Prisma.CustomerPricingTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerPricingTier>
          }
          groupBy: {
            args: Prisma.CustomerPricingTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerPricingTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerPricingTierCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerPricingTierCountAggregateOutputType> | number
          }
        }
      }
      CustomerExternalId: {
        payload: Prisma.$CustomerExternalIdPayload<ExtArgs>
        fields: Prisma.CustomerExternalIdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerExternalIdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerExternalIdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload>
          }
          findFirst: {
            args: Prisma.CustomerExternalIdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerExternalIdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload>
          }
          findMany: {
            args: Prisma.CustomerExternalIdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload>[]
          }
          create: {
            args: Prisma.CustomerExternalIdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload>
          }
          createMany: {
            args: Prisma.CustomerExternalIdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerExternalIdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload>[]
          }
          delete: {
            args: Prisma.CustomerExternalIdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload>
          }
          update: {
            args: Prisma.CustomerExternalIdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload>
          }
          deleteMany: {
            args: Prisma.CustomerExternalIdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerExternalIdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerExternalIdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload>[]
          }
          upsert: {
            args: Prisma.CustomerExternalIdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerExternalIdPayload>
          }
          aggregate: {
            args: Prisma.CustomerExternalIdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerExternalId>
          }
          groupBy: {
            args: Prisma.CustomerExternalIdGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerExternalIdGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerExternalIdCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerExternalIdCountAggregateOutputType> | number
          }
        }
      }
      CustomerPricing: {
        payload: Prisma.$CustomerPricingPayload<ExtArgs>
        fields: Prisma.CustomerPricingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerPricingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerPricingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload>
          }
          findFirst: {
            args: Prisma.CustomerPricingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerPricingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload>
          }
          findMany: {
            args: Prisma.CustomerPricingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload>[]
          }
          create: {
            args: Prisma.CustomerPricingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload>
          }
          createMany: {
            args: Prisma.CustomerPricingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerPricingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload>[]
          }
          delete: {
            args: Prisma.CustomerPricingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload>
          }
          update: {
            args: Prisma.CustomerPricingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload>
          }
          deleteMany: {
            args: Prisma.CustomerPricingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerPricingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerPricingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload>[]
          }
          upsert: {
            args: Prisma.CustomerPricingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingPayload>
          }
          aggregate: {
            args: Prisma.CustomerPricingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerPricing>
          }
          groupBy: {
            args: Prisma.CustomerPricingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerPricingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerPricingCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerPricingCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      PlanElevation: {
        payload: Prisma.$PlanElevationPayload<ExtArgs>
        fields: Prisma.PlanElevationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanElevationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanElevationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload>
          }
          findFirst: {
            args: Prisma.PlanElevationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanElevationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload>
          }
          findMany: {
            args: Prisma.PlanElevationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload>[]
          }
          create: {
            args: Prisma.PlanElevationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload>
          }
          createMany: {
            args: Prisma.PlanElevationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanElevationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload>[]
          }
          delete: {
            args: Prisma.PlanElevationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload>
          }
          update: {
            args: Prisma.PlanElevationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload>
          }
          deleteMany: {
            args: Prisma.PlanElevationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanElevationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanElevationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload>[]
          }
          upsert: {
            args: Prisma.PlanElevationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanElevationPayload>
          }
          aggregate: {
            args: Prisma.PlanElevationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanElevation>
          }
          groupBy: {
            args: Prisma.PlanElevationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanElevationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanElevationCountArgs<ExtArgs>
            result: $Utils.Optional<PlanElevationCountAggregateOutputType> | number
          }
        }
      }
      PlanOption: {
        payload: Prisma.$PlanOptionPayload<ExtArgs>
        fields: Prisma.PlanOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload>
          }
          findFirst: {
            args: Prisma.PlanOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload>
          }
          findMany: {
            args: Prisma.PlanOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload>[]
          }
          create: {
            args: Prisma.PlanOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload>
          }
          createMany: {
            args: Prisma.PlanOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload>[]
          }
          delete: {
            args: Prisma.PlanOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload>
          }
          update: {
            args: Prisma.PlanOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload>
          }
          deleteMany: {
            args: Prisma.PlanOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload>[]
          }
          upsert: {
            args: Prisma.PlanOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOptionPayload>
          }
          aggregate: {
            args: Prisma.PlanOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanOption>
          }
          groupBy: {
            args: Prisma.PlanOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanOptionCountArgs<ExtArgs>
            result: $Utils.Optional<PlanOptionCountAggregateOutputType> | number
          }
        }
      }
      PlanTemplateItem: {
        payload: Prisma.$PlanTemplateItemPayload<ExtArgs>
        fields: Prisma.PlanTemplateItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanTemplateItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanTemplateItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload>
          }
          findFirst: {
            args: Prisma.PlanTemplateItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanTemplateItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload>
          }
          findMany: {
            args: Prisma.PlanTemplateItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload>[]
          }
          create: {
            args: Prisma.PlanTemplateItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload>
          }
          createMany: {
            args: Prisma.PlanTemplateItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanTemplateItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload>[]
          }
          delete: {
            args: Prisma.PlanTemplateItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload>
          }
          update: {
            args: Prisma.PlanTemplateItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload>
          }
          deleteMany: {
            args: Prisma.PlanTemplateItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanTemplateItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanTemplateItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload>[]
          }
          upsert: {
            args: Prisma.PlanTemplateItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTemplateItemPayload>
          }
          aggregate: {
            args: Prisma.PlanTemplateItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanTemplateItem>
          }
          groupBy: {
            args: Prisma.PlanTemplateItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanTemplateItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanTemplateItemCountArgs<ExtArgs>
            result: $Utils.Optional<PlanTemplateItemCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      PricingHistory: {
        payload: Prisma.$PricingHistoryPayload<ExtArgs>
        fields: Prisma.PricingHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricingHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricingHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload>
          }
          findFirst: {
            args: Prisma.PricingHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricingHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload>
          }
          findMany: {
            args: Prisma.PricingHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload>[]
          }
          create: {
            args: Prisma.PricingHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload>
          }
          createMany: {
            args: Prisma.PricingHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PricingHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload>[]
          }
          delete: {
            args: Prisma.PricingHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload>
          }
          update: {
            args: Prisma.PricingHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PricingHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricingHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PricingHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PricingHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingHistoryPayload>
          }
          aggregate: {
            args: Prisma.PricingHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricingHistory>
          }
          groupBy: {
            args: Prisma.PricingHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricingHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PricingHistoryCountAggregateOutputType> | number
          }
        }
      }
      RandomLengthsPricing: {
        payload: Prisma.$RandomLengthsPricingPayload<ExtArgs>
        fields: Prisma.RandomLengthsPricingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RandomLengthsPricingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RandomLengthsPricingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload>
          }
          findFirst: {
            args: Prisma.RandomLengthsPricingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RandomLengthsPricingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload>
          }
          findMany: {
            args: Prisma.RandomLengthsPricingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload>[]
          }
          create: {
            args: Prisma.RandomLengthsPricingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload>
          }
          createMany: {
            args: Prisma.RandomLengthsPricingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RandomLengthsPricingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload>[]
          }
          delete: {
            args: Prisma.RandomLengthsPricingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload>
          }
          update: {
            args: Prisma.RandomLengthsPricingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload>
          }
          deleteMany: {
            args: Prisma.RandomLengthsPricingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RandomLengthsPricingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RandomLengthsPricingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload>[]
          }
          upsert: {
            args: Prisma.RandomLengthsPricingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomLengthsPricingPayload>
          }
          aggregate: {
            args: Prisma.RandomLengthsPricingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRandomLengthsPricing>
          }
          groupBy: {
            args: Prisma.RandomLengthsPricingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RandomLengthsPricingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RandomLengthsPricingCountArgs<ExtArgs>
            result: $Utils.Optional<RandomLengthsPricingCountAggregateOutputType> | number
          }
        }
      }
      Community: {
        payload: Prisma.$CommunityPayload<ExtArgs>
        fields: Prisma.CommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findFirst: {
            args: Prisma.CommunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findMany: {
            args: Prisma.CommunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          create: {
            args: Prisma.CommunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          createMany: {
            args: Prisma.CommunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          delete: {
            args: Prisma.CommunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          update: {
            args: Prisma.CommunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          deleteMany: {
            args: Prisma.CommunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          upsert: {
            args: Prisma.CommunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          aggregate: {
            args: Prisma.CommunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunity>
          }
          groupBy: {
            args: Prisma.CommunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityCountAggregateOutputType> | number
          }
        }
      }
      Lot: {
        payload: Prisma.$LotPayload<ExtArgs>
        fields: Prisma.LotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          findFirst: {
            args: Prisma.LotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          findMany: {
            args: Prisma.LotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>[]
          }
          create: {
            args: Prisma.LotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          createMany: {
            args: Prisma.LotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>[]
          }
          delete: {
            args: Prisma.LotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          update: {
            args: Prisma.LotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          deleteMany: {
            args: Prisma.LotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>[]
          }
          upsert: {
            args: Prisma.LotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          aggregate: {
            args: Prisma.LotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLot>
          }
          groupBy: {
            args: Prisma.LotGroupByArgs<ExtArgs>
            result: $Utils.Optional<LotGroupByOutputType>[]
          }
          count: {
            args: Prisma.LotCountArgs<ExtArgs>
            result: $Utils.Optional<LotCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      JobOption: {
        payload: Prisma.$JobOptionPayload<ExtArgs>
        fields: Prisma.JobOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload>
          }
          findFirst: {
            args: Prisma.JobOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload>
          }
          findMany: {
            args: Prisma.JobOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload>[]
          }
          create: {
            args: Prisma.JobOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload>
          }
          createMany: {
            args: Prisma.JobOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload>[]
          }
          delete: {
            args: Prisma.JobOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload>
          }
          update: {
            args: Prisma.JobOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload>
          }
          deleteMany: {
            args: Prisma.JobOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload>[]
          }
          upsert: {
            args: Prisma.JobOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobOptionPayload>
          }
          aggregate: {
            args: Prisma.JobOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobOption>
          }
          groupBy: {
            args: Prisma.JobOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobOptionCountArgs<ExtArgs>
            result: $Utils.Optional<JobOptionCountAggregateOutputType> | number
          }
        }
      }
      Takeoff: {
        payload: Prisma.$TakeoffPayload<ExtArgs>
        fields: Prisma.TakeoffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TakeoffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TakeoffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload>
          }
          findFirst: {
            args: Prisma.TakeoffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TakeoffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload>
          }
          findMany: {
            args: Prisma.TakeoffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload>[]
          }
          create: {
            args: Prisma.TakeoffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload>
          }
          createMany: {
            args: Prisma.TakeoffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TakeoffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload>[]
          }
          delete: {
            args: Prisma.TakeoffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload>
          }
          update: {
            args: Prisma.TakeoffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload>
          }
          deleteMany: {
            args: Prisma.TakeoffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TakeoffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TakeoffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload>[]
          }
          upsert: {
            args: Prisma.TakeoffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffPayload>
          }
          aggregate: {
            args: Prisma.TakeoffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTakeoff>
          }
          groupBy: {
            args: Prisma.TakeoffGroupByArgs<ExtArgs>
            result: $Utils.Optional<TakeoffGroupByOutputType>[]
          }
          count: {
            args: Prisma.TakeoffCountArgs<ExtArgs>
            result: $Utils.Optional<TakeoffCountAggregateOutputType> | number
          }
        }
      }
      TakeoffLineItem: {
        payload: Prisma.$TakeoffLineItemPayload<ExtArgs>
        fields: Prisma.TakeoffLineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TakeoffLineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TakeoffLineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload>
          }
          findFirst: {
            args: Prisma.TakeoffLineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TakeoffLineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload>
          }
          findMany: {
            args: Prisma.TakeoffLineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload>[]
          }
          create: {
            args: Prisma.TakeoffLineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload>
          }
          createMany: {
            args: Prisma.TakeoffLineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TakeoffLineItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload>[]
          }
          delete: {
            args: Prisma.TakeoffLineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload>
          }
          update: {
            args: Prisma.TakeoffLineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload>
          }
          deleteMany: {
            args: Prisma.TakeoffLineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TakeoffLineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TakeoffLineItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload>[]
          }
          upsert: {
            args: Prisma.TakeoffLineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffLineItemPayload>
          }
          aggregate: {
            args: Prisma.TakeoffLineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTakeoffLineItem>
          }
          groupBy: {
            args: Prisma.TakeoffLineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TakeoffLineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TakeoffLineItemCountArgs<ExtArgs>
            result: $Utils.Optional<TakeoffLineItemCountAggregateOutputType> | number
          }
        }
      }
      TakeoffValidation: {
        payload: Prisma.$TakeoffValidationPayload<ExtArgs>
        fields: Prisma.TakeoffValidationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TakeoffValidationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TakeoffValidationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload>
          }
          findFirst: {
            args: Prisma.TakeoffValidationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TakeoffValidationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload>
          }
          findMany: {
            args: Prisma.TakeoffValidationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload>[]
          }
          create: {
            args: Prisma.TakeoffValidationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload>
          }
          createMany: {
            args: Prisma.TakeoffValidationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TakeoffValidationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload>[]
          }
          delete: {
            args: Prisma.TakeoffValidationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload>
          }
          update: {
            args: Prisma.TakeoffValidationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload>
          }
          deleteMany: {
            args: Prisma.TakeoffValidationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TakeoffValidationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TakeoffValidationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload>[]
          }
          upsert: {
            args: Prisma.TakeoffValidationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakeoffValidationPayload>
          }
          aggregate: {
            args: Prisma.TakeoffValidationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTakeoffValidation>
          }
          groupBy: {
            args: Prisma.TakeoffValidationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TakeoffValidationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TakeoffValidationCountArgs<ExtArgs>
            result: $Utils.Optional<TakeoffValidationCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      VariancePattern: {
        payload: Prisma.$VariancePatternPayload<ExtArgs>
        fields: Prisma.VariancePatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariancePatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariancePatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload>
          }
          findFirst: {
            args: Prisma.VariancePatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariancePatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload>
          }
          findMany: {
            args: Prisma.VariancePatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload>[]
          }
          create: {
            args: Prisma.VariancePatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload>
          }
          createMany: {
            args: Prisma.VariancePatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariancePatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload>[]
          }
          delete: {
            args: Prisma.VariancePatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload>
          }
          update: {
            args: Prisma.VariancePatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload>
          }
          deleteMany: {
            args: Prisma.VariancePatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariancePatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariancePatternUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload>[]
          }
          upsert: {
            args: Prisma.VariancePatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariancePatternPayload>
          }
          aggregate: {
            args: Prisma.VariancePatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariancePattern>
          }
          groupBy: {
            args: Prisma.VariancePatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariancePatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariancePatternCountArgs<ExtArgs>
            result: $Utils.Optional<VariancePatternCountAggregateOutputType> | number
          }
        }
      }
      VarianceReview: {
        payload: Prisma.$VarianceReviewPayload<ExtArgs>
        fields: Prisma.VarianceReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VarianceReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VarianceReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload>
          }
          findFirst: {
            args: Prisma.VarianceReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VarianceReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload>
          }
          findMany: {
            args: Prisma.VarianceReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload>[]
          }
          create: {
            args: Prisma.VarianceReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload>
          }
          createMany: {
            args: Prisma.VarianceReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VarianceReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload>[]
          }
          delete: {
            args: Prisma.VarianceReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload>
          }
          update: {
            args: Prisma.VarianceReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload>
          }
          deleteMany: {
            args: Prisma.VarianceReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VarianceReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VarianceReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload>[]
          }
          upsert: {
            args: Prisma.VarianceReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceReviewPayload>
          }
          aggregate: {
            args: Prisma.VarianceReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVarianceReview>
          }
          groupBy: {
            args: Prisma.VarianceReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<VarianceReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.VarianceReviewCountArgs<ExtArgs>
            result: $Utils.Optional<VarianceReviewCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    customer?: CustomerOmit
    customerContact?: CustomerContactOmit
    customerPricingTier?: CustomerPricingTierOmit
    customerExternalId?: CustomerExternalIdOmit
    customerPricing?: CustomerPricingOmit
    plan?: PlanOmit
    planElevation?: PlanElevationOmit
    planOption?: PlanOptionOmit
    planTemplateItem?: PlanTemplateItemOmit
    material?: MaterialOmit
    vendor?: VendorOmit
    pricingHistory?: PricingHistoryOmit
    randomLengthsPricing?: RandomLengthsPricingOmit
    community?: CommunityOmit
    lot?: LotOmit
    job?: JobOmit
    jobOption?: JobOptionOmit
    takeoff?: TakeoffOmit
    takeoffLineItem?: TakeoffLineItemOmit
    takeoffValidation?: TakeoffValidationOmit
    purchaseOrder?: PurchaseOrderOmit
    variancePattern?: VariancePatternOmit
    varianceReview?: VarianceReviewOmit
    notification?: NotificationOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdJobs: number
    approvedJobs: number
    auditLogs: number
    notifications: number
    varianceReviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdJobs?: boolean | UserCountOutputTypeCountCreatedJobsArgs
    approvedJobs?: boolean | UserCountOutputTypeCountApprovedJobsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    varianceReviews?: boolean | UserCountOutputTypeCountVarianceReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVarianceReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VarianceReviewWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    contacts: number
    pricingTiers: number
    externalIds: number
    jobs: number
    communities: number
    customerPricing: number
    variancePatterns: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | CustomerCountOutputTypeCountContactsArgs
    pricingTiers?: boolean | CustomerCountOutputTypeCountPricingTiersArgs
    externalIds?: boolean | CustomerCountOutputTypeCountExternalIdsArgs
    jobs?: boolean | CustomerCountOutputTypeCountJobsArgs
    communities?: boolean | CustomerCountOutputTypeCountCommunitiesArgs
    customerPricing?: boolean | CustomerCountOutputTypeCountCustomerPricingArgs
    variancePatterns?: boolean | CustomerCountOutputTypeCountVariancePatternsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerContactWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPricingTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPricingTierWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountExternalIdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerExternalIdWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPricingWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountVariancePatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariancePatternWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    elevations: number
    options: number
    templateItems: number
    jobs: number
    variancePatterns: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elevations?: boolean | PlanCountOutputTypeCountElevationsArgs
    options?: boolean | PlanCountOutputTypeCountOptionsArgs
    templateItems?: boolean | PlanCountOutputTypeCountTemplateItemsArgs
    jobs?: boolean | PlanCountOutputTypeCountJobsArgs
    variancePatterns?: boolean | PlanCountOutputTypeCountVariancePatternsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountElevationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanElevationWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanOptionWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountTemplateItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanTemplateItemWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountVariancePatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariancePatternWhereInput
  }


  /**
   * Count Type PlanElevationCountOutputType
   */

  export type PlanElevationCountOutputType = {
    jobs: number
  }

  export type PlanElevationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | PlanElevationCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * PlanElevationCountOutputType without action
   */
  export type PlanElevationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevationCountOutputType
     */
    select?: PlanElevationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanElevationCountOutputType without action
   */
  export type PlanElevationCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }


  /**
   * Count Type PlanOptionCountOutputType
   */

  export type PlanOptionCountOutputType = {
    plans: number
    jobOptions: number
  }

  export type PlanOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | PlanOptionCountOutputTypeCountPlansArgs
    jobOptions?: boolean | PlanOptionCountOutputTypeCountJobOptionsArgs
  }

  // Custom InputTypes
  /**
   * PlanOptionCountOutputType without action
   */
  export type PlanOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOptionCountOutputType
     */
    select?: PlanOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanOptionCountOutputType without action
   */
  export type PlanOptionCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }

  /**
   * PlanOptionCountOutputType without action
   */
  export type PlanOptionCountOutputTypeCountJobOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobOptionWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    pricingHistory: number
    templateItems: number
    customerPricing: number
    takeoffLineItems: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricingHistory?: boolean | MaterialCountOutputTypeCountPricingHistoryArgs
    templateItems?: boolean | MaterialCountOutputTypeCountTemplateItemsArgs
    customerPricing?: boolean | MaterialCountOutputTypeCountCustomerPricingArgs
    takeoffLineItems?: boolean | MaterialCountOutputTypeCountTakeoffLineItemsArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountPricingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingHistoryWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountTemplateItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanTemplateItemWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountCustomerPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPricingWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountTakeoffLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakeoffLineItemWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    materials: number
    purchaseOrders: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | VendorCountOutputTypeCountMaterialsArgs
    purchaseOrders?: boolean | VendorCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type CommunityCountOutputType
   */

  export type CommunityCountOutputType = {
    lots: number
    jobs: number
    variancePatterns: number
  }

  export type CommunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lots?: boolean | CommunityCountOutputTypeCountLotsArgs
    jobs?: boolean | CommunityCountOutputTypeCountJobsArgs
    variancePatterns?: boolean | CommunityCountOutputTypeCountVariancePatternsArgs
  }

  // Custom InputTypes
  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCountOutputType
     */
    select?: CommunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountVariancePatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariancePatternWhereInput
  }


  /**
   * Count Type LotCountOutputType
   */

  export type LotCountOutputType = {
    jobs: number
  }

  export type LotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | LotCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotCountOutputType
     */
    select?: LotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    jobOptions: number
    purchaseOrders: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobOptions?: boolean | JobCountOutputTypeCountJobOptionsArgs
    purchaseOrders?: boolean | JobCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJobOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobOptionWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type TakeoffCountOutputType
   */

  export type TakeoffCountOutputType = {
    lineItems: number
  }

  export type TakeoffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | TakeoffCountOutputTypeCountLineItemsArgs
  }

  // Custom InputTypes
  /**
   * TakeoffCountOutputType without action
   */
  export type TakeoffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffCountOutputType
     */
    select?: TakeoffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TakeoffCountOutputType without action
   */
  export type TakeoffCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakeoffLineItemWhereInput
  }


  /**
   * Count Type VariancePatternCountOutputType
   */

  export type VariancePatternCountOutputType = {
    reviews: number
  }

  export type VariancePatternCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | VariancePatternCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * VariancePatternCountOutputType without action
   */
  export type VariancePatternCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePatternCountOutputType
     */
    select?: VariancePatternCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VariancePatternCountOutputType without action
   */
  export type VariancePatternCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VarianceReviewWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdJobs?: boolean | User$createdJobsArgs<ExtArgs>
    approvedJobs?: boolean | User$approvedJobsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    varianceReviews?: boolean | User$varianceReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "firstName" | "lastName" | "role" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdJobs?: boolean | User$createdJobsArgs<ExtArgs>
    approvedJobs?: boolean | User$approvedJobsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    varianceReviews?: boolean | User$varianceReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdJobs: Prisma.$JobPayload<ExtArgs>[]
      approvedJobs: Prisma.$JobPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      varianceReviews: Prisma.$VarianceReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string | null
      lastName: string | null
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdJobs<T extends User$createdJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedJobs<T extends User$approvedJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    varianceReviews<T extends User$varianceReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$varianceReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.createdJobs
   */
  export type User$createdJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * User.approvedJobs
   */
  export type User$approvedJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.varianceReviews
   */
  export type User$varianceReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    where?: VarianceReviewWhereInput
    orderBy?: VarianceReviewOrderByWithRelationInput | VarianceReviewOrderByWithRelationInput[]
    cursor?: VarianceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VarianceReviewScalarFieldEnum | VarianceReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    customerName: string | null
    customerType: $Enums.CustomerType | null
    pricingTier: string | null
    primaryContactId: string | null
    isActive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    customerName: string | null
    customerType: $Enums.CustomerType | null
    pricingTier: string | null
    primaryContactId: string | null
    isActive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    customerName: number
    customerType: number
    pricingTier: number
    primaryContactId: number
    isActive: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    customerName?: true
    customerType?: true
    pricingTier?: true
    primaryContactId?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    customerName?: true
    customerType?: true
    pricingTier?: true
    primaryContactId?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    customerName?: true
    customerType?: true
    pricingTier?: true
    primaryContactId?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier: string | null
    primaryContactId: string | null
    isActive: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    customerType?: boolean
    pricingTier?: boolean
    primaryContactId?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contacts?: boolean | Customer$contactsArgs<ExtArgs>
    pricingTiers?: boolean | Customer$pricingTiersArgs<ExtArgs>
    externalIds?: boolean | Customer$externalIdsArgs<ExtArgs>
    jobs?: boolean | Customer$jobsArgs<ExtArgs>
    communities?: boolean | Customer$communitiesArgs<ExtArgs>
    customerPricing?: boolean | Customer$customerPricingArgs<ExtArgs>
    variancePatterns?: boolean | Customer$variancePatternsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    customerType?: boolean
    pricingTier?: boolean
    primaryContactId?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    customerType?: boolean
    pricingTier?: boolean
    primaryContactId?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    customerName?: boolean
    customerType?: boolean
    pricingTier?: boolean
    primaryContactId?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerName" | "customerType" | "pricingTier" | "primaryContactId" | "isActive" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | Customer$contactsArgs<ExtArgs>
    pricingTiers?: boolean | Customer$pricingTiersArgs<ExtArgs>
    externalIds?: boolean | Customer$externalIdsArgs<ExtArgs>
    jobs?: boolean | Customer$jobsArgs<ExtArgs>
    communities?: boolean | Customer$communitiesArgs<ExtArgs>
    customerPricing?: boolean | Customer$customerPricingArgs<ExtArgs>
    variancePatterns?: boolean | Customer$variancePatternsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      contacts: Prisma.$CustomerContactPayload<ExtArgs>[]
      pricingTiers: Prisma.$CustomerPricingTierPayload<ExtArgs>[]
      externalIds: Prisma.$CustomerExternalIdPayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
      communities: Prisma.$CommunityPayload<ExtArgs>[]
      customerPricing: Prisma.$CustomerPricingPayload<ExtArgs>[]
      variancePatterns: Prisma.$VariancePatternPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerName: string
      customerType: $Enums.CustomerType
      pricingTier: string | null
      primaryContactId: string | null
      isActive: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends Customer$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pricingTiers<T extends Customer$pricingTiersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$pricingTiersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    externalIds<T extends Customer$externalIdsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$externalIdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends Customer$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communities<T extends Customer$communitiesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$communitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerPricing<T extends Customer$customerPricingArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerPricingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variancePatterns<T extends Customer$variancePatternsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$variancePatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly customerName: FieldRef<"Customer", 'String'>
    readonly customerType: FieldRef<"Customer", 'CustomerType'>
    readonly pricingTier: FieldRef<"Customer", 'String'>
    readonly primaryContactId: FieldRef<"Customer", 'String'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.contacts
   */
  export type Customer$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    where?: CustomerContactWhereInput
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    cursor?: CustomerContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerContactScalarFieldEnum | CustomerContactScalarFieldEnum[]
  }

  /**
   * Customer.pricingTiers
   */
  export type Customer$pricingTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    where?: CustomerPricingTierWhereInput
    orderBy?: CustomerPricingTierOrderByWithRelationInput | CustomerPricingTierOrderByWithRelationInput[]
    cursor?: CustomerPricingTierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPricingTierScalarFieldEnum | CustomerPricingTierScalarFieldEnum[]
  }

  /**
   * Customer.externalIds
   */
  export type Customer$externalIdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    where?: CustomerExternalIdWhereInput
    orderBy?: CustomerExternalIdOrderByWithRelationInput | CustomerExternalIdOrderByWithRelationInput[]
    cursor?: CustomerExternalIdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerExternalIdScalarFieldEnum | CustomerExternalIdScalarFieldEnum[]
  }

  /**
   * Customer.jobs
   */
  export type Customer$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Customer.communities
   */
  export type Customer$communitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    cursor?: CommunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Customer.customerPricing
   */
  export type Customer$customerPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    where?: CustomerPricingWhereInput
    orderBy?: CustomerPricingOrderByWithRelationInput | CustomerPricingOrderByWithRelationInput[]
    cursor?: CustomerPricingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPricingScalarFieldEnum | CustomerPricingScalarFieldEnum[]
  }

  /**
   * Customer.variancePatterns
   */
  export type Customer$variancePatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    where?: VariancePatternWhereInput
    orderBy?: VariancePatternOrderByWithRelationInput | VariancePatternOrderByWithRelationInput[]
    cursor?: VariancePatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariancePatternScalarFieldEnum | VariancePatternScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerContact
   */

  export type AggregateCustomerContact = {
    _count: CustomerContactCountAggregateOutputType | null
    _min: CustomerContactMinAggregateOutputType | null
    _max: CustomerContactMaxAggregateOutputType | null
  }

  export type CustomerContactMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    contactName: string | null
    role: string | null
    email: string | null
    phone: string | null
    receivesNotifications: boolean | null
    isPrimary: boolean | null
    createdAt: Date | null
  }

  export type CustomerContactMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    contactName: string | null
    role: string | null
    email: string | null
    phone: string | null
    receivesNotifications: boolean | null
    isPrimary: boolean | null
    createdAt: Date | null
  }

  export type CustomerContactCountAggregateOutputType = {
    id: number
    customerId: number
    contactName: number
    role: number
    email: number
    phone: number
    receivesNotifications: number
    isPrimary: number
    createdAt: number
    _all: number
  }


  export type CustomerContactMinAggregateInputType = {
    id?: true
    customerId?: true
    contactName?: true
    role?: true
    email?: true
    phone?: true
    receivesNotifications?: true
    isPrimary?: true
    createdAt?: true
  }

  export type CustomerContactMaxAggregateInputType = {
    id?: true
    customerId?: true
    contactName?: true
    role?: true
    email?: true
    phone?: true
    receivesNotifications?: true
    isPrimary?: true
    createdAt?: true
  }

  export type CustomerContactCountAggregateInputType = {
    id?: true
    customerId?: true
    contactName?: true
    role?: true
    email?: true
    phone?: true
    receivesNotifications?: true
    isPrimary?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerContact to aggregate.
     */
    where?: CustomerContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerContacts to fetch.
     */
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerContacts
    **/
    _count?: true | CustomerContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerContactMaxAggregateInputType
  }

  export type GetCustomerContactAggregateType<T extends CustomerContactAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerContact[P]>
      : GetScalarType<T[P], AggregateCustomerContact[P]>
  }




  export type CustomerContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerContactWhereInput
    orderBy?: CustomerContactOrderByWithAggregationInput | CustomerContactOrderByWithAggregationInput[]
    by: CustomerContactScalarFieldEnum[] | CustomerContactScalarFieldEnum
    having?: CustomerContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerContactCountAggregateInputType | true
    _min?: CustomerContactMinAggregateInputType
    _max?: CustomerContactMaxAggregateInputType
  }

  export type CustomerContactGroupByOutputType = {
    id: string
    customerId: string
    contactName: string
    role: string | null
    email: string | null
    phone: string | null
    receivesNotifications: boolean
    isPrimary: boolean
    createdAt: Date
    _count: CustomerContactCountAggregateOutputType | null
    _min: CustomerContactMinAggregateOutputType | null
    _max: CustomerContactMaxAggregateOutputType | null
  }

  type GetCustomerContactGroupByPayload<T extends CustomerContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerContactGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerContactGroupByOutputType[P]>
        }
      >
    >


  export type CustomerContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    contactName?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerContact"]>

  export type CustomerContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    contactName?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerContact"]>

  export type CustomerContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    contactName?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerContact"]>

  export type CustomerContactSelectScalar = {
    id?: boolean
    customerId?: boolean
    contactName?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: boolean
  }

  export type CustomerContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "contactName" | "role" | "email" | "phone" | "receivesNotifications" | "isPrimary" | "createdAt", ExtArgs["result"]["customerContact"]>
  export type CustomerContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerContact"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      contactName: string
      role: string | null
      email: string | null
      phone: string | null
      receivesNotifications: boolean
      isPrimary: boolean
      createdAt: Date
    }, ExtArgs["result"]["customerContact"]>
    composites: {}
  }

  type CustomerContactGetPayload<S extends boolean | null | undefined | CustomerContactDefaultArgs> = $Result.GetResult<Prisma.$CustomerContactPayload, S>

  type CustomerContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerContactCountAggregateInputType | true
    }

  export interface CustomerContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerContact'], meta: { name: 'CustomerContact' } }
    /**
     * Find zero or one CustomerContact that matches the filter.
     * @param {CustomerContactFindUniqueArgs} args - Arguments to find a CustomerContact
     * @example
     * // Get one CustomerContact
     * const customerContact = await prisma.customerContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerContactFindUniqueArgs>(args: SelectSubset<T, CustomerContactFindUniqueArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerContactFindUniqueOrThrowArgs} args - Arguments to find a CustomerContact
     * @example
     * // Get one CustomerContact
     * const customerContact = await prisma.customerContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerContactFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactFindFirstArgs} args - Arguments to find a CustomerContact
     * @example
     * // Get one CustomerContact
     * const customerContact = await prisma.customerContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerContactFindFirstArgs>(args?: SelectSubset<T, CustomerContactFindFirstArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactFindFirstOrThrowArgs} args - Arguments to find a CustomerContact
     * @example
     * // Get one CustomerContact
     * const customerContact = await prisma.customerContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerContactFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerContacts
     * const customerContacts = await prisma.customerContact.findMany()
     * 
     * // Get first 10 CustomerContacts
     * const customerContacts = await prisma.customerContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerContactWithIdOnly = await prisma.customerContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerContactFindManyArgs>(args?: SelectSubset<T, CustomerContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerContact.
     * @param {CustomerContactCreateArgs} args - Arguments to create a CustomerContact.
     * @example
     * // Create one CustomerContact
     * const CustomerContact = await prisma.customerContact.create({
     *   data: {
     *     // ... data to create a CustomerContact
     *   }
     * })
     * 
     */
    create<T extends CustomerContactCreateArgs>(args: SelectSubset<T, CustomerContactCreateArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerContacts.
     * @param {CustomerContactCreateManyArgs} args - Arguments to create many CustomerContacts.
     * @example
     * // Create many CustomerContacts
     * const customerContact = await prisma.customerContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerContactCreateManyArgs>(args?: SelectSubset<T, CustomerContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerContacts and returns the data saved in the database.
     * @param {CustomerContactCreateManyAndReturnArgs} args - Arguments to create many CustomerContacts.
     * @example
     * // Create many CustomerContacts
     * const customerContact = await prisma.customerContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerContacts and only return the `id`
     * const customerContactWithIdOnly = await prisma.customerContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerContactCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerContact.
     * @param {CustomerContactDeleteArgs} args - Arguments to delete one CustomerContact.
     * @example
     * // Delete one CustomerContact
     * const CustomerContact = await prisma.customerContact.delete({
     *   where: {
     *     // ... filter to delete one CustomerContact
     *   }
     * })
     * 
     */
    delete<T extends CustomerContactDeleteArgs>(args: SelectSubset<T, CustomerContactDeleteArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerContact.
     * @param {CustomerContactUpdateArgs} args - Arguments to update one CustomerContact.
     * @example
     * // Update one CustomerContact
     * const customerContact = await prisma.customerContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerContactUpdateArgs>(args: SelectSubset<T, CustomerContactUpdateArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerContacts.
     * @param {CustomerContactDeleteManyArgs} args - Arguments to filter CustomerContacts to delete.
     * @example
     * // Delete a few CustomerContacts
     * const { count } = await prisma.customerContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerContactDeleteManyArgs>(args?: SelectSubset<T, CustomerContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerContacts
     * const customerContact = await prisma.customerContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerContactUpdateManyArgs>(args: SelectSubset<T, CustomerContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerContacts and returns the data updated in the database.
     * @param {CustomerContactUpdateManyAndReturnArgs} args - Arguments to update many CustomerContacts.
     * @example
     * // Update many CustomerContacts
     * const customerContact = await prisma.customerContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerContacts and only return the `id`
     * const customerContactWithIdOnly = await prisma.customerContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerContactUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerContact.
     * @param {CustomerContactUpsertArgs} args - Arguments to update or create a CustomerContact.
     * @example
     * // Update or create a CustomerContact
     * const customerContact = await prisma.customerContact.upsert({
     *   create: {
     *     // ... data to create a CustomerContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerContact we want to update
     *   }
     * })
     */
    upsert<T extends CustomerContactUpsertArgs>(args: SelectSubset<T, CustomerContactUpsertArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactCountArgs} args - Arguments to filter CustomerContacts to count.
     * @example
     * // Count the number of CustomerContacts
     * const count = await prisma.customerContact.count({
     *   where: {
     *     // ... the filter for the CustomerContacts we want to count
     *   }
     * })
    **/
    count<T extends CustomerContactCountArgs>(
      args?: Subset<T, CustomerContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerContactAggregateArgs>(args: Subset<T, CustomerContactAggregateArgs>): Prisma.PrismaPromise<GetCustomerContactAggregateType<T>>

    /**
     * Group by CustomerContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerContactGroupByArgs['orderBy'] }
        : { orderBy?: CustomerContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerContact model
   */
  readonly fields: CustomerContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerContact model
   */
  interface CustomerContactFieldRefs {
    readonly id: FieldRef<"CustomerContact", 'String'>
    readonly customerId: FieldRef<"CustomerContact", 'String'>
    readonly contactName: FieldRef<"CustomerContact", 'String'>
    readonly role: FieldRef<"CustomerContact", 'String'>
    readonly email: FieldRef<"CustomerContact", 'String'>
    readonly phone: FieldRef<"CustomerContact", 'String'>
    readonly receivesNotifications: FieldRef<"CustomerContact", 'Boolean'>
    readonly isPrimary: FieldRef<"CustomerContact", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerContact findUnique
   */
  export type CustomerContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContact to fetch.
     */
    where: CustomerContactWhereUniqueInput
  }

  /**
   * CustomerContact findUniqueOrThrow
   */
  export type CustomerContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContact to fetch.
     */
    where: CustomerContactWhereUniqueInput
  }

  /**
   * CustomerContact findFirst
   */
  export type CustomerContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContact to fetch.
     */
    where?: CustomerContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerContacts to fetch.
     */
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerContacts.
     */
    cursor?: CustomerContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerContacts.
     */
    distinct?: CustomerContactScalarFieldEnum | CustomerContactScalarFieldEnum[]
  }

  /**
   * CustomerContact findFirstOrThrow
   */
  export type CustomerContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContact to fetch.
     */
    where?: CustomerContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerContacts to fetch.
     */
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerContacts.
     */
    cursor?: CustomerContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerContacts.
     */
    distinct?: CustomerContactScalarFieldEnum | CustomerContactScalarFieldEnum[]
  }

  /**
   * CustomerContact findMany
   */
  export type CustomerContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContacts to fetch.
     */
    where?: CustomerContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerContacts to fetch.
     */
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerContacts.
     */
    cursor?: CustomerContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerContacts.
     */
    skip?: number
    distinct?: CustomerContactScalarFieldEnum | CustomerContactScalarFieldEnum[]
  }

  /**
   * CustomerContact create
   */
  export type CustomerContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerContact.
     */
    data: XOR<CustomerContactCreateInput, CustomerContactUncheckedCreateInput>
  }

  /**
   * CustomerContact createMany
   */
  export type CustomerContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerContacts.
     */
    data: CustomerContactCreateManyInput | CustomerContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerContact createManyAndReturn
   */
  export type CustomerContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerContacts.
     */
    data: CustomerContactCreateManyInput | CustomerContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerContact update
   */
  export type CustomerContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerContact.
     */
    data: XOR<CustomerContactUpdateInput, CustomerContactUncheckedUpdateInput>
    /**
     * Choose, which CustomerContact to update.
     */
    where: CustomerContactWhereUniqueInput
  }

  /**
   * CustomerContact updateMany
   */
  export type CustomerContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerContacts.
     */
    data: XOR<CustomerContactUpdateManyMutationInput, CustomerContactUncheckedUpdateManyInput>
    /**
     * Filter which CustomerContacts to update
     */
    where?: CustomerContactWhereInput
    /**
     * Limit how many CustomerContacts to update.
     */
    limit?: number
  }

  /**
   * CustomerContact updateManyAndReturn
   */
  export type CustomerContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * The data used to update CustomerContacts.
     */
    data: XOR<CustomerContactUpdateManyMutationInput, CustomerContactUncheckedUpdateManyInput>
    /**
     * Filter which CustomerContacts to update
     */
    where?: CustomerContactWhereInput
    /**
     * Limit how many CustomerContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerContact upsert
   */
  export type CustomerContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerContact to update in case it exists.
     */
    where: CustomerContactWhereUniqueInput
    /**
     * In case the CustomerContact found by the `where` argument doesn't exist, create a new CustomerContact with this data.
     */
    create: XOR<CustomerContactCreateInput, CustomerContactUncheckedCreateInput>
    /**
     * In case the CustomerContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerContactUpdateInput, CustomerContactUncheckedUpdateInput>
  }

  /**
   * CustomerContact delete
   */
  export type CustomerContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter which CustomerContact to delete.
     */
    where: CustomerContactWhereUniqueInput
  }

  /**
   * CustomerContact deleteMany
   */
  export type CustomerContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerContacts to delete
     */
    where?: CustomerContactWhereInput
    /**
     * Limit how many CustomerContacts to delete.
     */
    limit?: number
  }

  /**
   * CustomerContact without action
   */
  export type CustomerContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
  }


  /**
   * Model CustomerPricingTier
   */

  export type AggregateCustomerPricingTier = {
    _count: CustomerPricingTierCountAggregateOutputType | null
    _avg: CustomerPricingTierAvgAggregateOutputType | null
    _sum: CustomerPricingTierSumAggregateOutputType | null
    _min: CustomerPricingTierMinAggregateOutputType | null
    _max: CustomerPricingTierMaxAggregateOutputType | null
  }

  export type CustomerPricingTierAvgAggregateOutputType = {
    discountPercentage: Decimal | null
  }

  export type CustomerPricingTierSumAggregateOutputType = {
    discountPercentage: Decimal | null
  }

  export type CustomerPricingTierMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    tierName: string | null
    discountPercentage: Decimal | null
    effectiveDate: Date | null
    expirationDate: Date | null
    createdAt: Date | null
  }

  export type CustomerPricingTierMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    tierName: string | null
    discountPercentage: Decimal | null
    effectiveDate: Date | null
    expirationDate: Date | null
    createdAt: Date | null
  }

  export type CustomerPricingTierCountAggregateOutputType = {
    id: number
    customerId: number
    tierName: number
    discountPercentage: number
    effectiveDate: number
    expirationDate: number
    createdAt: number
    _all: number
  }


  export type CustomerPricingTierAvgAggregateInputType = {
    discountPercentage?: true
  }

  export type CustomerPricingTierSumAggregateInputType = {
    discountPercentage?: true
  }

  export type CustomerPricingTierMinAggregateInputType = {
    id?: true
    customerId?: true
    tierName?: true
    discountPercentage?: true
    effectiveDate?: true
    expirationDate?: true
    createdAt?: true
  }

  export type CustomerPricingTierMaxAggregateInputType = {
    id?: true
    customerId?: true
    tierName?: true
    discountPercentage?: true
    effectiveDate?: true
    expirationDate?: true
    createdAt?: true
  }

  export type CustomerPricingTierCountAggregateInputType = {
    id?: true
    customerId?: true
    tierName?: true
    discountPercentage?: true
    effectiveDate?: true
    expirationDate?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerPricingTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPricingTier to aggregate.
     */
    where?: CustomerPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricingTiers to fetch.
     */
    orderBy?: CustomerPricingTierOrderByWithRelationInput | CustomerPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerPricingTiers
    **/
    _count?: true | CustomerPricingTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerPricingTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerPricingTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerPricingTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerPricingTierMaxAggregateInputType
  }

  export type GetCustomerPricingTierAggregateType<T extends CustomerPricingTierAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerPricingTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerPricingTier[P]>
      : GetScalarType<T[P], AggregateCustomerPricingTier[P]>
  }




  export type CustomerPricingTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPricingTierWhereInput
    orderBy?: CustomerPricingTierOrderByWithAggregationInput | CustomerPricingTierOrderByWithAggregationInput[]
    by: CustomerPricingTierScalarFieldEnum[] | CustomerPricingTierScalarFieldEnum
    having?: CustomerPricingTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerPricingTierCountAggregateInputType | true
    _avg?: CustomerPricingTierAvgAggregateInputType
    _sum?: CustomerPricingTierSumAggregateInputType
    _min?: CustomerPricingTierMinAggregateInputType
    _max?: CustomerPricingTierMaxAggregateInputType
  }

  export type CustomerPricingTierGroupByOutputType = {
    id: string
    customerId: string
    tierName: string
    discountPercentage: Decimal
    effectiveDate: Date
    expirationDate: Date | null
    createdAt: Date
    _count: CustomerPricingTierCountAggregateOutputType | null
    _avg: CustomerPricingTierAvgAggregateOutputType | null
    _sum: CustomerPricingTierSumAggregateOutputType | null
    _min: CustomerPricingTierMinAggregateOutputType | null
    _max: CustomerPricingTierMaxAggregateOutputType | null
  }

  type GetCustomerPricingTierGroupByPayload<T extends CustomerPricingTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerPricingTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerPricingTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerPricingTierGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerPricingTierGroupByOutputType[P]>
        }
      >
    >


  export type CustomerPricingTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    tierName?: boolean
    discountPercentage?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPricingTier"]>

  export type CustomerPricingTierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    tierName?: boolean
    discountPercentage?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPricingTier"]>

  export type CustomerPricingTierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    tierName?: boolean
    discountPercentage?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPricingTier"]>

  export type CustomerPricingTierSelectScalar = {
    id?: boolean
    customerId?: boolean
    tierName?: boolean
    discountPercentage?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    createdAt?: boolean
  }

  export type CustomerPricingTierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "tierName" | "discountPercentage" | "effectiveDate" | "expirationDate" | "createdAt", ExtArgs["result"]["customerPricingTier"]>
  export type CustomerPricingTierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerPricingTierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerPricingTierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerPricingTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerPricingTier"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      tierName: string
      discountPercentage: Prisma.Decimal
      effectiveDate: Date
      expirationDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["customerPricingTier"]>
    composites: {}
  }

  type CustomerPricingTierGetPayload<S extends boolean | null | undefined | CustomerPricingTierDefaultArgs> = $Result.GetResult<Prisma.$CustomerPricingTierPayload, S>

  type CustomerPricingTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerPricingTierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerPricingTierCountAggregateInputType | true
    }

  export interface CustomerPricingTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerPricingTier'], meta: { name: 'CustomerPricingTier' } }
    /**
     * Find zero or one CustomerPricingTier that matches the filter.
     * @param {CustomerPricingTierFindUniqueArgs} args - Arguments to find a CustomerPricingTier
     * @example
     * // Get one CustomerPricingTier
     * const customerPricingTier = await prisma.customerPricingTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerPricingTierFindUniqueArgs>(args: SelectSubset<T, CustomerPricingTierFindUniqueArgs<ExtArgs>>): Prisma__CustomerPricingTierClient<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerPricingTier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerPricingTierFindUniqueOrThrowArgs} args - Arguments to find a CustomerPricingTier
     * @example
     * // Get one CustomerPricingTier
     * const customerPricingTier = await prisma.customerPricingTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerPricingTierFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerPricingTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerPricingTierClient<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPricingTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingTierFindFirstArgs} args - Arguments to find a CustomerPricingTier
     * @example
     * // Get one CustomerPricingTier
     * const customerPricingTier = await prisma.customerPricingTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerPricingTierFindFirstArgs>(args?: SelectSubset<T, CustomerPricingTierFindFirstArgs<ExtArgs>>): Prisma__CustomerPricingTierClient<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPricingTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingTierFindFirstOrThrowArgs} args - Arguments to find a CustomerPricingTier
     * @example
     * // Get one CustomerPricingTier
     * const customerPricingTier = await prisma.customerPricingTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerPricingTierFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerPricingTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerPricingTierClient<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerPricingTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerPricingTiers
     * const customerPricingTiers = await prisma.customerPricingTier.findMany()
     * 
     * // Get first 10 CustomerPricingTiers
     * const customerPricingTiers = await prisma.customerPricingTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerPricingTierWithIdOnly = await prisma.customerPricingTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerPricingTierFindManyArgs>(args?: SelectSubset<T, CustomerPricingTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerPricingTier.
     * @param {CustomerPricingTierCreateArgs} args - Arguments to create a CustomerPricingTier.
     * @example
     * // Create one CustomerPricingTier
     * const CustomerPricingTier = await prisma.customerPricingTier.create({
     *   data: {
     *     // ... data to create a CustomerPricingTier
     *   }
     * })
     * 
     */
    create<T extends CustomerPricingTierCreateArgs>(args: SelectSubset<T, CustomerPricingTierCreateArgs<ExtArgs>>): Prisma__CustomerPricingTierClient<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerPricingTiers.
     * @param {CustomerPricingTierCreateManyArgs} args - Arguments to create many CustomerPricingTiers.
     * @example
     * // Create many CustomerPricingTiers
     * const customerPricingTier = await prisma.customerPricingTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerPricingTierCreateManyArgs>(args?: SelectSubset<T, CustomerPricingTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerPricingTiers and returns the data saved in the database.
     * @param {CustomerPricingTierCreateManyAndReturnArgs} args - Arguments to create many CustomerPricingTiers.
     * @example
     * // Create many CustomerPricingTiers
     * const customerPricingTier = await prisma.customerPricingTier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerPricingTiers and only return the `id`
     * const customerPricingTierWithIdOnly = await prisma.customerPricingTier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerPricingTierCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerPricingTierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerPricingTier.
     * @param {CustomerPricingTierDeleteArgs} args - Arguments to delete one CustomerPricingTier.
     * @example
     * // Delete one CustomerPricingTier
     * const CustomerPricingTier = await prisma.customerPricingTier.delete({
     *   where: {
     *     // ... filter to delete one CustomerPricingTier
     *   }
     * })
     * 
     */
    delete<T extends CustomerPricingTierDeleteArgs>(args: SelectSubset<T, CustomerPricingTierDeleteArgs<ExtArgs>>): Prisma__CustomerPricingTierClient<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerPricingTier.
     * @param {CustomerPricingTierUpdateArgs} args - Arguments to update one CustomerPricingTier.
     * @example
     * // Update one CustomerPricingTier
     * const customerPricingTier = await prisma.customerPricingTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerPricingTierUpdateArgs>(args: SelectSubset<T, CustomerPricingTierUpdateArgs<ExtArgs>>): Prisma__CustomerPricingTierClient<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerPricingTiers.
     * @param {CustomerPricingTierDeleteManyArgs} args - Arguments to filter CustomerPricingTiers to delete.
     * @example
     * // Delete a few CustomerPricingTiers
     * const { count } = await prisma.customerPricingTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerPricingTierDeleteManyArgs>(args?: SelectSubset<T, CustomerPricingTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerPricingTiers
     * const customerPricingTier = await prisma.customerPricingTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerPricingTierUpdateManyArgs>(args: SelectSubset<T, CustomerPricingTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPricingTiers and returns the data updated in the database.
     * @param {CustomerPricingTierUpdateManyAndReturnArgs} args - Arguments to update many CustomerPricingTiers.
     * @example
     * // Update many CustomerPricingTiers
     * const customerPricingTier = await prisma.customerPricingTier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerPricingTiers and only return the `id`
     * const customerPricingTierWithIdOnly = await prisma.customerPricingTier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerPricingTierUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerPricingTierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerPricingTier.
     * @param {CustomerPricingTierUpsertArgs} args - Arguments to update or create a CustomerPricingTier.
     * @example
     * // Update or create a CustomerPricingTier
     * const customerPricingTier = await prisma.customerPricingTier.upsert({
     *   create: {
     *     // ... data to create a CustomerPricingTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerPricingTier we want to update
     *   }
     * })
     */
    upsert<T extends CustomerPricingTierUpsertArgs>(args: SelectSubset<T, CustomerPricingTierUpsertArgs<ExtArgs>>): Prisma__CustomerPricingTierClient<$Result.GetResult<Prisma.$CustomerPricingTierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerPricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingTierCountArgs} args - Arguments to filter CustomerPricingTiers to count.
     * @example
     * // Count the number of CustomerPricingTiers
     * const count = await prisma.customerPricingTier.count({
     *   where: {
     *     // ... the filter for the CustomerPricingTiers we want to count
     *   }
     * })
    **/
    count<T extends CustomerPricingTierCountArgs>(
      args?: Subset<T, CustomerPricingTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerPricingTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerPricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerPricingTierAggregateArgs>(args: Subset<T, CustomerPricingTierAggregateArgs>): Prisma.PrismaPromise<GetCustomerPricingTierAggregateType<T>>

    /**
     * Group by CustomerPricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerPricingTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerPricingTierGroupByArgs['orderBy'] }
        : { orderBy?: CustomerPricingTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerPricingTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerPricingTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerPricingTier model
   */
  readonly fields: CustomerPricingTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerPricingTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerPricingTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerPricingTier model
   */
  interface CustomerPricingTierFieldRefs {
    readonly id: FieldRef<"CustomerPricingTier", 'String'>
    readonly customerId: FieldRef<"CustomerPricingTier", 'String'>
    readonly tierName: FieldRef<"CustomerPricingTier", 'String'>
    readonly discountPercentage: FieldRef<"CustomerPricingTier", 'Decimal'>
    readonly effectiveDate: FieldRef<"CustomerPricingTier", 'DateTime'>
    readonly expirationDate: FieldRef<"CustomerPricingTier", 'DateTime'>
    readonly createdAt: FieldRef<"CustomerPricingTier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerPricingTier findUnique
   */
  export type CustomerPricingTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingTier to fetch.
     */
    where: CustomerPricingTierWhereUniqueInput
  }

  /**
   * CustomerPricingTier findUniqueOrThrow
   */
  export type CustomerPricingTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingTier to fetch.
     */
    where: CustomerPricingTierWhereUniqueInput
  }

  /**
   * CustomerPricingTier findFirst
   */
  export type CustomerPricingTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingTier to fetch.
     */
    where?: CustomerPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricingTiers to fetch.
     */
    orderBy?: CustomerPricingTierOrderByWithRelationInput | CustomerPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPricingTiers.
     */
    cursor?: CustomerPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPricingTiers.
     */
    distinct?: CustomerPricingTierScalarFieldEnum | CustomerPricingTierScalarFieldEnum[]
  }

  /**
   * CustomerPricingTier findFirstOrThrow
   */
  export type CustomerPricingTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingTier to fetch.
     */
    where?: CustomerPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricingTiers to fetch.
     */
    orderBy?: CustomerPricingTierOrderByWithRelationInput | CustomerPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPricingTiers.
     */
    cursor?: CustomerPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPricingTiers.
     */
    distinct?: CustomerPricingTierScalarFieldEnum | CustomerPricingTierScalarFieldEnum[]
  }

  /**
   * CustomerPricingTier findMany
   */
  export type CustomerPricingTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingTiers to fetch.
     */
    where?: CustomerPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricingTiers to fetch.
     */
    orderBy?: CustomerPricingTierOrderByWithRelationInput | CustomerPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerPricingTiers.
     */
    cursor?: CustomerPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricingTiers.
     */
    skip?: number
    distinct?: CustomerPricingTierScalarFieldEnum | CustomerPricingTierScalarFieldEnum[]
  }

  /**
   * CustomerPricingTier create
   */
  export type CustomerPricingTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerPricingTier.
     */
    data: XOR<CustomerPricingTierCreateInput, CustomerPricingTierUncheckedCreateInput>
  }

  /**
   * CustomerPricingTier createMany
   */
  export type CustomerPricingTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerPricingTiers.
     */
    data: CustomerPricingTierCreateManyInput | CustomerPricingTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerPricingTier createManyAndReturn
   */
  export type CustomerPricingTierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerPricingTiers.
     */
    data: CustomerPricingTierCreateManyInput | CustomerPricingTierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPricingTier update
   */
  export type CustomerPricingTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerPricingTier.
     */
    data: XOR<CustomerPricingTierUpdateInput, CustomerPricingTierUncheckedUpdateInput>
    /**
     * Choose, which CustomerPricingTier to update.
     */
    where: CustomerPricingTierWhereUniqueInput
  }

  /**
   * CustomerPricingTier updateMany
   */
  export type CustomerPricingTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerPricingTiers.
     */
    data: XOR<CustomerPricingTierUpdateManyMutationInput, CustomerPricingTierUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPricingTiers to update
     */
    where?: CustomerPricingTierWhereInput
    /**
     * Limit how many CustomerPricingTiers to update.
     */
    limit?: number
  }

  /**
   * CustomerPricingTier updateManyAndReturn
   */
  export type CustomerPricingTierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * The data used to update CustomerPricingTiers.
     */
    data: XOR<CustomerPricingTierUpdateManyMutationInput, CustomerPricingTierUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPricingTiers to update
     */
    where?: CustomerPricingTierWhereInput
    /**
     * Limit how many CustomerPricingTiers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPricingTier upsert
   */
  export type CustomerPricingTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerPricingTier to update in case it exists.
     */
    where: CustomerPricingTierWhereUniqueInput
    /**
     * In case the CustomerPricingTier found by the `where` argument doesn't exist, create a new CustomerPricingTier with this data.
     */
    create: XOR<CustomerPricingTierCreateInput, CustomerPricingTierUncheckedCreateInput>
    /**
     * In case the CustomerPricingTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerPricingTierUpdateInput, CustomerPricingTierUncheckedUpdateInput>
  }

  /**
   * CustomerPricingTier delete
   */
  export type CustomerPricingTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
    /**
     * Filter which CustomerPricingTier to delete.
     */
    where: CustomerPricingTierWhereUniqueInput
  }

  /**
   * CustomerPricingTier deleteMany
   */
  export type CustomerPricingTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPricingTiers to delete
     */
    where?: CustomerPricingTierWhereInput
    /**
     * Limit how many CustomerPricingTiers to delete.
     */
    limit?: number
  }

  /**
   * CustomerPricingTier without action
   */
  export type CustomerPricingTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingTier
     */
    select?: CustomerPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingTier
     */
    omit?: CustomerPricingTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingTierInclude<ExtArgs> | null
  }


  /**
   * Model CustomerExternalId
   */

  export type AggregateCustomerExternalId = {
    _count: CustomerExternalIdCountAggregateOutputType | null
    _min: CustomerExternalIdMinAggregateOutputType | null
    _max: CustomerExternalIdMaxAggregateOutputType | null
  }

  export type CustomerExternalIdMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    externalSystem: string | null
    externalCustomerId: string | null
    externalCustomerName: string | null
    isPrimary: boolean | null
    createdAt: Date | null
  }

  export type CustomerExternalIdMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    externalSystem: string | null
    externalCustomerId: string | null
    externalCustomerName: string | null
    isPrimary: boolean | null
    createdAt: Date | null
  }

  export type CustomerExternalIdCountAggregateOutputType = {
    id: number
    customerId: number
    externalSystem: number
    externalCustomerId: number
    externalCustomerName: number
    isPrimary: number
    createdAt: number
    _all: number
  }


  export type CustomerExternalIdMinAggregateInputType = {
    id?: true
    customerId?: true
    externalSystem?: true
    externalCustomerId?: true
    externalCustomerName?: true
    isPrimary?: true
    createdAt?: true
  }

  export type CustomerExternalIdMaxAggregateInputType = {
    id?: true
    customerId?: true
    externalSystem?: true
    externalCustomerId?: true
    externalCustomerName?: true
    isPrimary?: true
    createdAt?: true
  }

  export type CustomerExternalIdCountAggregateInputType = {
    id?: true
    customerId?: true
    externalSystem?: true
    externalCustomerId?: true
    externalCustomerName?: true
    isPrimary?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerExternalIdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerExternalId to aggregate.
     */
    where?: CustomerExternalIdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerExternalIds to fetch.
     */
    orderBy?: CustomerExternalIdOrderByWithRelationInput | CustomerExternalIdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerExternalIdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerExternalIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerExternalIds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerExternalIds
    **/
    _count?: true | CustomerExternalIdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerExternalIdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerExternalIdMaxAggregateInputType
  }

  export type GetCustomerExternalIdAggregateType<T extends CustomerExternalIdAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerExternalId]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerExternalId[P]>
      : GetScalarType<T[P], AggregateCustomerExternalId[P]>
  }




  export type CustomerExternalIdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerExternalIdWhereInput
    orderBy?: CustomerExternalIdOrderByWithAggregationInput | CustomerExternalIdOrderByWithAggregationInput[]
    by: CustomerExternalIdScalarFieldEnum[] | CustomerExternalIdScalarFieldEnum
    having?: CustomerExternalIdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerExternalIdCountAggregateInputType | true
    _min?: CustomerExternalIdMinAggregateInputType
    _max?: CustomerExternalIdMaxAggregateInputType
  }

  export type CustomerExternalIdGroupByOutputType = {
    id: string
    customerId: string
    externalSystem: string
    externalCustomerId: string
    externalCustomerName: string | null
    isPrimary: boolean
    createdAt: Date
    _count: CustomerExternalIdCountAggregateOutputType | null
    _min: CustomerExternalIdMinAggregateOutputType | null
    _max: CustomerExternalIdMaxAggregateOutputType | null
  }

  type GetCustomerExternalIdGroupByPayload<T extends CustomerExternalIdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerExternalIdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerExternalIdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerExternalIdGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerExternalIdGroupByOutputType[P]>
        }
      >
    >


  export type CustomerExternalIdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    externalSystem?: boolean
    externalCustomerId?: boolean
    externalCustomerName?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerExternalId"]>

  export type CustomerExternalIdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    externalSystem?: boolean
    externalCustomerId?: boolean
    externalCustomerName?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerExternalId"]>

  export type CustomerExternalIdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    externalSystem?: boolean
    externalCustomerId?: boolean
    externalCustomerName?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerExternalId"]>

  export type CustomerExternalIdSelectScalar = {
    id?: boolean
    customerId?: boolean
    externalSystem?: boolean
    externalCustomerId?: boolean
    externalCustomerName?: boolean
    isPrimary?: boolean
    createdAt?: boolean
  }

  export type CustomerExternalIdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "externalSystem" | "externalCustomerId" | "externalCustomerName" | "isPrimary" | "createdAt", ExtArgs["result"]["customerExternalId"]>
  export type CustomerExternalIdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerExternalIdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerExternalIdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerExternalIdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerExternalId"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      externalSystem: string
      externalCustomerId: string
      externalCustomerName: string | null
      isPrimary: boolean
      createdAt: Date
    }, ExtArgs["result"]["customerExternalId"]>
    composites: {}
  }

  type CustomerExternalIdGetPayload<S extends boolean | null | undefined | CustomerExternalIdDefaultArgs> = $Result.GetResult<Prisma.$CustomerExternalIdPayload, S>

  type CustomerExternalIdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerExternalIdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerExternalIdCountAggregateInputType | true
    }

  export interface CustomerExternalIdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerExternalId'], meta: { name: 'CustomerExternalId' } }
    /**
     * Find zero or one CustomerExternalId that matches the filter.
     * @param {CustomerExternalIdFindUniqueArgs} args - Arguments to find a CustomerExternalId
     * @example
     * // Get one CustomerExternalId
     * const customerExternalId = await prisma.customerExternalId.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerExternalIdFindUniqueArgs>(args: SelectSubset<T, CustomerExternalIdFindUniqueArgs<ExtArgs>>): Prisma__CustomerExternalIdClient<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerExternalId that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerExternalIdFindUniqueOrThrowArgs} args - Arguments to find a CustomerExternalId
     * @example
     * // Get one CustomerExternalId
     * const customerExternalId = await prisma.customerExternalId.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerExternalIdFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerExternalIdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerExternalIdClient<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerExternalId that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExternalIdFindFirstArgs} args - Arguments to find a CustomerExternalId
     * @example
     * // Get one CustomerExternalId
     * const customerExternalId = await prisma.customerExternalId.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerExternalIdFindFirstArgs>(args?: SelectSubset<T, CustomerExternalIdFindFirstArgs<ExtArgs>>): Prisma__CustomerExternalIdClient<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerExternalId that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExternalIdFindFirstOrThrowArgs} args - Arguments to find a CustomerExternalId
     * @example
     * // Get one CustomerExternalId
     * const customerExternalId = await prisma.customerExternalId.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerExternalIdFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerExternalIdFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerExternalIdClient<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerExternalIds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExternalIdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerExternalIds
     * const customerExternalIds = await prisma.customerExternalId.findMany()
     * 
     * // Get first 10 CustomerExternalIds
     * const customerExternalIds = await prisma.customerExternalId.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerExternalIdWithIdOnly = await prisma.customerExternalId.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerExternalIdFindManyArgs>(args?: SelectSubset<T, CustomerExternalIdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerExternalId.
     * @param {CustomerExternalIdCreateArgs} args - Arguments to create a CustomerExternalId.
     * @example
     * // Create one CustomerExternalId
     * const CustomerExternalId = await prisma.customerExternalId.create({
     *   data: {
     *     // ... data to create a CustomerExternalId
     *   }
     * })
     * 
     */
    create<T extends CustomerExternalIdCreateArgs>(args: SelectSubset<T, CustomerExternalIdCreateArgs<ExtArgs>>): Prisma__CustomerExternalIdClient<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerExternalIds.
     * @param {CustomerExternalIdCreateManyArgs} args - Arguments to create many CustomerExternalIds.
     * @example
     * // Create many CustomerExternalIds
     * const customerExternalId = await prisma.customerExternalId.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerExternalIdCreateManyArgs>(args?: SelectSubset<T, CustomerExternalIdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerExternalIds and returns the data saved in the database.
     * @param {CustomerExternalIdCreateManyAndReturnArgs} args - Arguments to create many CustomerExternalIds.
     * @example
     * // Create many CustomerExternalIds
     * const customerExternalId = await prisma.customerExternalId.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerExternalIds and only return the `id`
     * const customerExternalIdWithIdOnly = await prisma.customerExternalId.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerExternalIdCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerExternalIdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerExternalId.
     * @param {CustomerExternalIdDeleteArgs} args - Arguments to delete one CustomerExternalId.
     * @example
     * // Delete one CustomerExternalId
     * const CustomerExternalId = await prisma.customerExternalId.delete({
     *   where: {
     *     // ... filter to delete one CustomerExternalId
     *   }
     * })
     * 
     */
    delete<T extends CustomerExternalIdDeleteArgs>(args: SelectSubset<T, CustomerExternalIdDeleteArgs<ExtArgs>>): Prisma__CustomerExternalIdClient<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerExternalId.
     * @param {CustomerExternalIdUpdateArgs} args - Arguments to update one CustomerExternalId.
     * @example
     * // Update one CustomerExternalId
     * const customerExternalId = await prisma.customerExternalId.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerExternalIdUpdateArgs>(args: SelectSubset<T, CustomerExternalIdUpdateArgs<ExtArgs>>): Prisma__CustomerExternalIdClient<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerExternalIds.
     * @param {CustomerExternalIdDeleteManyArgs} args - Arguments to filter CustomerExternalIds to delete.
     * @example
     * // Delete a few CustomerExternalIds
     * const { count } = await prisma.customerExternalId.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerExternalIdDeleteManyArgs>(args?: SelectSubset<T, CustomerExternalIdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerExternalIds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExternalIdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerExternalIds
     * const customerExternalId = await prisma.customerExternalId.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerExternalIdUpdateManyArgs>(args: SelectSubset<T, CustomerExternalIdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerExternalIds and returns the data updated in the database.
     * @param {CustomerExternalIdUpdateManyAndReturnArgs} args - Arguments to update many CustomerExternalIds.
     * @example
     * // Update many CustomerExternalIds
     * const customerExternalId = await prisma.customerExternalId.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerExternalIds and only return the `id`
     * const customerExternalIdWithIdOnly = await prisma.customerExternalId.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerExternalIdUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerExternalIdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerExternalId.
     * @param {CustomerExternalIdUpsertArgs} args - Arguments to update or create a CustomerExternalId.
     * @example
     * // Update or create a CustomerExternalId
     * const customerExternalId = await prisma.customerExternalId.upsert({
     *   create: {
     *     // ... data to create a CustomerExternalId
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerExternalId we want to update
     *   }
     * })
     */
    upsert<T extends CustomerExternalIdUpsertArgs>(args: SelectSubset<T, CustomerExternalIdUpsertArgs<ExtArgs>>): Prisma__CustomerExternalIdClient<$Result.GetResult<Prisma.$CustomerExternalIdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerExternalIds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExternalIdCountArgs} args - Arguments to filter CustomerExternalIds to count.
     * @example
     * // Count the number of CustomerExternalIds
     * const count = await prisma.customerExternalId.count({
     *   where: {
     *     // ... the filter for the CustomerExternalIds we want to count
     *   }
     * })
    **/
    count<T extends CustomerExternalIdCountArgs>(
      args?: Subset<T, CustomerExternalIdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerExternalIdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerExternalId.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExternalIdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerExternalIdAggregateArgs>(args: Subset<T, CustomerExternalIdAggregateArgs>): Prisma.PrismaPromise<GetCustomerExternalIdAggregateType<T>>

    /**
     * Group by CustomerExternalId.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExternalIdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerExternalIdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerExternalIdGroupByArgs['orderBy'] }
        : { orderBy?: CustomerExternalIdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerExternalIdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerExternalIdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerExternalId model
   */
  readonly fields: CustomerExternalIdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerExternalId.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerExternalIdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerExternalId model
   */
  interface CustomerExternalIdFieldRefs {
    readonly id: FieldRef<"CustomerExternalId", 'String'>
    readonly customerId: FieldRef<"CustomerExternalId", 'String'>
    readonly externalSystem: FieldRef<"CustomerExternalId", 'String'>
    readonly externalCustomerId: FieldRef<"CustomerExternalId", 'String'>
    readonly externalCustomerName: FieldRef<"CustomerExternalId", 'String'>
    readonly isPrimary: FieldRef<"CustomerExternalId", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerExternalId", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerExternalId findUnique
   */
  export type CustomerExternalIdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    /**
     * Filter, which CustomerExternalId to fetch.
     */
    where: CustomerExternalIdWhereUniqueInput
  }

  /**
   * CustomerExternalId findUniqueOrThrow
   */
  export type CustomerExternalIdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    /**
     * Filter, which CustomerExternalId to fetch.
     */
    where: CustomerExternalIdWhereUniqueInput
  }

  /**
   * CustomerExternalId findFirst
   */
  export type CustomerExternalIdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    /**
     * Filter, which CustomerExternalId to fetch.
     */
    where?: CustomerExternalIdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerExternalIds to fetch.
     */
    orderBy?: CustomerExternalIdOrderByWithRelationInput | CustomerExternalIdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerExternalIds.
     */
    cursor?: CustomerExternalIdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerExternalIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerExternalIds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerExternalIds.
     */
    distinct?: CustomerExternalIdScalarFieldEnum | CustomerExternalIdScalarFieldEnum[]
  }

  /**
   * CustomerExternalId findFirstOrThrow
   */
  export type CustomerExternalIdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    /**
     * Filter, which CustomerExternalId to fetch.
     */
    where?: CustomerExternalIdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerExternalIds to fetch.
     */
    orderBy?: CustomerExternalIdOrderByWithRelationInput | CustomerExternalIdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerExternalIds.
     */
    cursor?: CustomerExternalIdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerExternalIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerExternalIds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerExternalIds.
     */
    distinct?: CustomerExternalIdScalarFieldEnum | CustomerExternalIdScalarFieldEnum[]
  }

  /**
   * CustomerExternalId findMany
   */
  export type CustomerExternalIdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    /**
     * Filter, which CustomerExternalIds to fetch.
     */
    where?: CustomerExternalIdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerExternalIds to fetch.
     */
    orderBy?: CustomerExternalIdOrderByWithRelationInput | CustomerExternalIdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerExternalIds.
     */
    cursor?: CustomerExternalIdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerExternalIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerExternalIds.
     */
    skip?: number
    distinct?: CustomerExternalIdScalarFieldEnum | CustomerExternalIdScalarFieldEnum[]
  }

  /**
   * CustomerExternalId create
   */
  export type CustomerExternalIdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerExternalId.
     */
    data: XOR<CustomerExternalIdCreateInput, CustomerExternalIdUncheckedCreateInput>
  }

  /**
   * CustomerExternalId createMany
   */
  export type CustomerExternalIdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerExternalIds.
     */
    data: CustomerExternalIdCreateManyInput | CustomerExternalIdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerExternalId createManyAndReturn
   */
  export type CustomerExternalIdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerExternalIds.
     */
    data: CustomerExternalIdCreateManyInput | CustomerExternalIdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerExternalId update
   */
  export type CustomerExternalIdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerExternalId.
     */
    data: XOR<CustomerExternalIdUpdateInput, CustomerExternalIdUncheckedUpdateInput>
    /**
     * Choose, which CustomerExternalId to update.
     */
    where: CustomerExternalIdWhereUniqueInput
  }

  /**
   * CustomerExternalId updateMany
   */
  export type CustomerExternalIdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerExternalIds.
     */
    data: XOR<CustomerExternalIdUpdateManyMutationInput, CustomerExternalIdUncheckedUpdateManyInput>
    /**
     * Filter which CustomerExternalIds to update
     */
    where?: CustomerExternalIdWhereInput
    /**
     * Limit how many CustomerExternalIds to update.
     */
    limit?: number
  }

  /**
   * CustomerExternalId updateManyAndReturn
   */
  export type CustomerExternalIdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * The data used to update CustomerExternalIds.
     */
    data: XOR<CustomerExternalIdUpdateManyMutationInput, CustomerExternalIdUncheckedUpdateManyInput>
    /**
     * Filter which CustomerExternalIds to update
     */
    where?: CustomerExternalIdWhereInput
    /**
     * Limit how many CustomerExternalIds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerExternalId upsert
   */
  export type CustomerExternalIdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerExternalId to update in case it exists.
     */
    where: CustomerExternalIdWhereUniqueInput
    /**
     * In case the CustomerExternalId found by the `where` argument doesn't exist, create a new CustomerExternalId with this data.
     */
    create: XOR<CustomerExternalIdCreateInput, CustomerExternalIdUncheckedCreateInput>
    /**
     * In case the CustomerExternalId was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerExternalIdUpdateInput, CustomerExternalIdUncheckedUpdateInput>
  }

  /**
   * CustomerExternalId delete
   */
  export type CustomerExternalIdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
    /**
     * Filter which CustomerExternalId to delete.
     */
    where: CustomerExternalIdWhereUniqueInput
  }

  /**
   * CustomerExternalId deleteMany
   */
  export type CustomerExternalIdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerExternalIds to delete
     */
    where?: CustomerExternalIdWhereInput
    /**
     * Limit how many CustomerExternalIds to delete.
     */
    limit?: number
  }

  /**
   * CustomerExternalId without action
   */
  export type CustomerExternalIdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerExternalId
     */
    select?: CustomerExternalIdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerExternalId
     */
    omit?: CustomerExternalIdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerExternalIdInclude<ExtArgs> | null
  }


  /**
   * Model CustomerPricing
   */

  export type AggregateCustomerPricing = {
    _count: CustomerPricingCountAggregateOutputType | null
    _avg: CustomerPricingAvgAggregateOutputType | null
    _sum: CustomerPricingSumAggregateOutputType | null
    _min: CustomerPricingMinAggregateOutputType | null
    _max: CustomerPricingMaxAggregateOutputType | null
  }

  export type CustomerPricingAvgAggregateOutputType = {
    overridePrice: Decimal | null
    overrideMargin: Decimal | null
    discountPercentage: Decimal | null
  }

  export type CustomerPricingSumAggregateOutputType = {
    overridePrice: Decimal | null
    overrideMargin: Decimal | null
    discountPercentage: Decimal | null
  }

  export type CustomerPricingMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    materialId: string | null
    overridePrice: Decimal | null
    overrideMargin: Decimal | null
    discountPercentage: Decimal | null
    effectiveDate: Date | null
    expiresAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPricingMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    materialId: string | null
    overridePrice: Decimal | null
    overrideMargin: Decimal | null
    discountPercentage: Decimal | null
    effectiveDate: Date | null
    expiresAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPricingCountAggregateOutputType = {
    id: number
    customerId: number
    materialId: number
    overridePrice: number
    overrideMargin: number
    discountPercentage: number
    effectiveDate: number
    expiresAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerPricingAvgAggregateInputType = {
    overridePrice?: true
    overrideMargin?: true
    discountPercentage?: true
  }

  export type CustomerPricingSumAggregateInputType = {
    overridePrice?: true
    overrideMargin?: true
    discountPercentage?: true
  }

  export type CustomerPricingMinAggregateInputType = {
    id?: true
    customerId?: true
    materialId?: true
    overridePrice?: true
    overrideMargin?: true
    discountPercentage?: true
    effectiveDate?: true
    expiresAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPricingMaxAggregateInputType = {
    id?: true
    customerId?: true
    materialId?: true
    overridePrice?: true
    overrideMargin?: true
    discountPercentage?: true
    effectiveDate?: true
    expiresAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPricingCountAggregateInputType = {
    id?: true
    customerId?: true
    materialId?: true
    overridePrice?: true
    overrideMargin?: true
    discountPercentage?: true
    effectiveDate?: true
    expiresAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerPricingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPricing to aggregate.
     */
    where?: CustomerPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricings to fetch.
     */
    orderBy?: CustomerPricingOrderByWithRelationInput | CustomerPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerPricings
    **/
    _count?: true | CustomerPricingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerPricingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerPricingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerPricingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerPricingMaxAggregateInputType
  }

  export type GetCustomerPricingAggregateType<T extends CustomerPricingAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerPricing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerPricing[P]>
      : GetScalarType<T[P], AggregateCustomerPricing[P]>
  }




  export type CustomerPricingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPricingWhereInput
    orderBy?: CustomerPricingOrderByWithAggregationInput | CustomerPricingOrderByWithAggregationInput[]
    by: CustomerPricingScalarFieldEnum[] | CustomerPricingScalarFieldEnum
    having?: CustomerPricingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerPricingCountAggregateInputType | true
    _avg?: CustomerPricingAvgAggregateInputType
    _sum?: CustomerPricingSumAggregateInputType
    _min?: CustomerPricingMinAggregateInputType
    _max?: CustomerPricingMaxAggregateInputType
  }

  export type CustomerPricingGroupByOutputType = {
    id: string
    customerId: string
    materialId: string
    overridePrice: Decimal | null
    overrideMargin: Decimal | null
    discountPercentage: Decimal | null
    effectiveDate: Date
    expiresAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerPricingCountAggregateOutputType | null
    _avg: CustomerPricingAvgAggregateOutputType | null
    _sum: CustomerPricingSumAggregateOutputType | null
    _min: CustomerPricingMinAggregateOutputType | null
    _max: CustomerPricingMaxAggregateOutputType | null
  }

  type GetCustomerPricingGroupByPayload<T extends CustomerPricingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerPricingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerPricingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerPricingGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerPricingGroupByOutputType[P]>
        }
      >
    >


  export type CustomerPricingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    materialId?: boolean
    overridePrice?: boolean
    overrideMargin?: boolean
    discountPercentage?: boolean
    effectiveDate?: boolean
    expiresAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPricing"]>

  export type CustomerPricingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    materialId?: boolean
    overridePrice?: boolean
    overrideMargin?: boolean
    discountPercentage?: boolean
    effectiveDate?: boolean
    expiresAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPricing"]>

  export type CustomerPricingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    materialId?: boolean
    overridePrice?: boolean
    overrideMargin?: boolean
    discountPercentage?: boolean
    effectiveDate?: boolean
    expiresAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPricing"]>

  export type CustomerPricingSelectScalar = {
    id?: boolean
    customerId?: boolean
    materialId?: boolean
    overridePrice?: boolean
    overrideMargin?: boolean
    discountPercentage?: boolean
    effectiveDate?: boolean
    expiresAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerPricingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "materialId" | "overridePrice" | "overrideMargin" | "discountPercentage" | "effectiveDate" | "expiresAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["customerPricing"]>
  export type CustomerPricingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type CustomerPricingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type CustomerPricingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $CustomerPricingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerPricing"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      materialId: string
      overridePrice: Prisma.Decimal | null
      overrideMargin: Prisma.Decimal | null
      discountPercentage: Prisma.Decimal | null
      effectiveDate: Date
      expiresAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerPricing"]>
    composites: {}
  }

  type CustomerPricingGetPayload<S extends boolean | null | undefined | CustomerPricingDefaultArgs> = $Result.GetResult<Prisma.$CustomerPricingPayload, S>

  type CustomerPricingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerPricingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerPricingCountAggregateInputType | true
    }

  export interface CustomerPricingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerPricing'], meta: { name: 'CustomerPricing' } }
    /**
     * Find zero or one CustomerPricing that matches the filter.
     * @param {CustomerPricingFindUniqueArgs} args - Arguments to find a CustomerPricing
     * @example
     * // Get one CustomerPricing
     * const customerPricing = await prisma.customerPricing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerPricingFindUniqueArgs>(args: SelectSubset<T, CustomerPricingFindUniqueArgs<ExtArgs>>): Prisma__CustomerPricingClient<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerPricing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerPricingFindUniqueOrThrowArgs} args - Arguments to find a CustomerPricing
     * @example
     * // Get one CustomerPricing
     * const customerPricing = await prisma.customerPricing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerPricingFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerPricingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerPricingClient<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPricing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingFindFirstArgs} args - Arguments to find a CustomerPricing
     * @example
     * // Get one CustomerPricing
     * const customerPricing = await prisma.customerPricing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerPricingFindFirstArgs>(args?: SelectSubset<T, CustomerPricingFindFirstArgs<ExtArgs>>): Prisma__CustomerPricingClient<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPricing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingFindFirstOrThrowArgs} args - Arguments to find a CustomerPricing
     * @example
     * // Get one CustomerPricing
     * const customerPricing = await prisma.customerPricing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerPricingFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerPricingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerPricingClient<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerPricings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerPricings
     * const customerPricings = await prisma.customerPricing.findMany()
     * 
     * // Get first 10 CustomerPricings
     * const customerPricings = await prisma.customerPricing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerPricingWithIdOnly = await prisma.customerPricing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerPricingFindManyArgs>(args?: SelectSubset<T, CustomerPricingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerPricing.
     * @param {CustomerPricingCreateArgs} args - Arguments to create a CustomerPricing.
     * @example
     * // Create one CustomerPricing
     * const CustomerPricing = await prisma.customerPricing.create({
     *   data: {
     *     // ... data to create a CustomerPricing
     *   }
     * })
     * 
     */
    create<T extends CustomerPricingCreateArgs>(args: SelectSubset<T, CustomerPricingCreateArgs<ExtArgs>>): Prisma__CustomerPricingClient<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerPricings.
     * @param {CustomerPricingCreateManyArgs} args - Arguments to create many CustomerPricings.
     * @example
     * // Create many CustomerPricings
     * const customerPricing = await prisma.customerPricing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerPricingCreateManyArgs>(args?: SelectSubset<T, CustomerPricingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerPricings and returns the data saved in the database.
     * @param {CustomerPricingCreateManyAndReturnArgs} args - Arguments to create many CustomerPricings.
     * @example
     * // Create many CustomerPricings
     * const customerPricing = await prisma.customerPricing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerPricings and only return the `id`
     * const customerPricingWithIdOnly = await prisma.customerPricing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerPricingCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerPricingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerPricing.
     * @param {CustomerPricingDeleteArgs} args - Arguments to delete one CustomerPricing.
     * @example
     * // Delete one CustomerPricing
     * const CustomerPricing = await prisma.customerPricing.delete({
     *   where: {
     *     // ... filter to delete one CustomerPricing
     *   }
     * })
     * 
     */
    delete<T extends CustomerPricingDeleteArgs>(args: SelectSubset<T, CustomerPricingDeleteArgs<ExtArgs>>): Prisma__CustomerPricingClient<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerPricing.
     * @param {CustomerPricingUpdateArgs} args - Arguments to update one CustomerPricing.
     * @example
     * // Update one CustomerPricing
     * const customerPricing = await prisma.customerPricing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerPricingUpdateArgs>(args: SelectSubset<T, CustomerPricingUpdateArgs<ExtArgs>>): Prisma__CustomerPricingClient<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerPricings.
     * @param {CustomerPricingDeleteManyArgs} args - Arguments to filter CustomerPricings to delete.
     * @example
     * // Delete a few CustomerPricings
     * const { count } = await prisma.customerPricing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerPricingDeleteManyArgs>(args?: SelectSubset<T, CustomerPricingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerPricings
     * const customerPricing = await prisma.customerPricing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerPricingUpdateManyArgs>(args: SelectSubset<T, CustomerPricingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPricings and returns the data updated in the database.
     * @param {CustomerPricingUpdateManyAndReturnArgs} args - Arguments to update many CustomerPricings.
     * @example
     * // Update many CustomerPricings
     * const customerPricing = await prisma.customerPricing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerPricings and only return the `id`
     * const customerPricingWithIdOnly = await prisma.customerPricing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerPricingUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerPricingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerPricing.
     * @param {CustomerPricingUpsertArgs} args - Arguments to update or create a CustomerPricing.
     * @example
     * // Update or create a CustomerPricing
     * const customerPricing = await prisma.customerPricing.upsert({
     *   create: {
     *     // ... data to create a CustomerPricing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerPricing we want to update
     *   }
     * })
     */
    upsert<T extends CustomerPricingUpsertArgs>(args: SelectSubset<T, CustomerPricingUpsertArgs<ExtArgs>>): Prisma__CustomerPricingClient<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingCountArgs} args - Arguments to filter CustomerPricings to count.
     * @example
     * // Count the number of CustomerPricings
     * const count = await prisma.customerPricing.count({
     *   where: {
     *     // ... the filter for the CustomerPricings we want to count
     *   }
     * })
    **/
    count<T extends CustomerPricingCountArgs>(
      args?: Subset<T, CustomerPricingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerPricingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerPricingAggregateArgs>(args: Subset<T, CustomerPricingAggregateArgs>): Prisma.PrismaPromise<GetCustomerPricingAggregateType<T>>

    /**
     * Group by CustomerPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerPricingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerPricingGroupByArgs['orderBy'] }
        : { orderBy?: CustomerPricingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerPricingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerPricingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerPricing model
   */
  readonly fields: CustomerPricingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerPricing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerPricingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerPricing model
   */
  interface CustomerPricingFieldRefs {
    readonly id: FieldRef<"CustomerPricing", 'String'>
    readonly customerId: FieldRef<"CustomerPricing", 'String'>
    readonly materialId: FieldRef<"CustomerPricing", 'String'>
    readonly overridePrice: FieldRef<"CustomerPricing", 'Decimal'>
    readonly overrideMargin: FieldRef<"CustomerPricing", 'Decimal'>
    readonly discountPercentage: FieldRef<"CustomerPricing", 'Decimal'>
    readonly effectiveDate: FieldRef<"CustomerPricing", 'DateTime'>
    readonly expiresAt: FieldRef<"CustomerPricing", 'DateTime'>
    readonly notes: FieldRef<"CustomerPricing", 'String'>
    readonly createdAt: FieldRef<"CustomerPricing", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerPricing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerPricing findUnique
   */
  export type CustomerPricingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricing to fetch.
     */
    where: CustomerPricingWhereUniqueInput
  }

  /**
   * CustomerPricing findUniqueOrThrow
   */
  export type CustomerPricingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricing to fetch.
     */
    where: CustomerPricingWhereUniqueInput
  }

  /**
   * CustomerPricing findFirst
   */
  export type CustomerPricingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricing to fetch.
     */
    where?: CustomerPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricings to fetch.
     */
    orderBy?: CustomerPricingOrderByWithRelationInput | CustomerPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPricings.
     */
    cursor?: CustomerPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPricings.
     */
    distinct?: CustomerPricingScalarFieldEnum | CustomerPricingScalarFieldEnum[]
  }

  /**
   * CustomerPricing findFirstOrThrow
   */
  export type CustomerPricingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricing to fetch.
     */
    where?: CustomerPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricings to fetch.
     */
    orderBy?: CustomerPricingOrderByWithRelationInput | CustomerPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPricings.
     */
    cursor?: CustomerPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPricings.
     */
    distinct?: CustomerPricingScalarFieldEnum | CustomerPricingScalarFieldEnum[]
  }

  /**
   * CustomerPricing findMany
   */
  export type CustomerPricingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricings to fetch.
     */
    where?: CustomerPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricings to fetch.
     */
    orderBy?: CustomerPricingOrderByWithRelationInput | CustomerPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerPricings.
     */
    cursor?: CustomerPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricings.
     */
    skip?: number
    distinct?: CustomerPricingScalarFieldEnum | CustomerPricingScalarFieldEnum[]
  }

  /**
   * CustomerPricing create
   */
  export type CustomerPricingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerPricing.
     */
    data: XOR<CustomerPricingCreateInput, CustomerPricingUncheckedCreateInput>
  }

  /**
   * CustomerPricing createMany
   */
  export type CustomerPricingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerPricings.
     */
    data: CustomerPricingCreateManyInput | CustomerPricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerPricing createManyAndReturn
   */
  export type CustomerPricingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerPricings.
     */
    data: CustomerPricingCreateManyInput | CustomerPricingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPricing update
   */
  export type CustomerPricingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerPricing.
     */
    data: XOR<CustomerPricingUpdateInput, CustomerPricingUncheckedUpdateInput>
    /**
     * Choose, which CustomerPricing to update.
     */
    where: CustomerPricingWhereUniqueInput
  }

  /**
   * CustomerPricing updateMany
   */
  export type CustomerPricingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerPricings.
     */
    data: XOR<CustomerPricingUpdateManyMutationInput, CustomerPricingUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPricings to update
     */
    where?: CustomerPricingWhereInput
    /**
     * Limit how many CustomerPricings to update.
     */
    limit?: number
  }

  /**
   * CustomerPricing updateManyAndReturn
   */
  export type CustomerPricingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * The data used to update CustomerPricings.
     */
    data: XOR<CustomerPricingUpdateManyMutationInput, CustomerPricingUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPricings to update
     */
    where?: CustomerPricingWhereInput
    /**
     * Limit how many CustomerPricings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPricing upsert
   */
  export type CustomerPricingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerPricing to update in case it exists.
     */
    where: CustomerPricingWhereUniqueInput
    /**
     * In case the CustomerPricing found by the `where` argument doesn't exist, create a new CustomerPricing with this data.
     */
    create: XOR<CustomerPricingCreateInput, CustomerPricingUncheckedCreateInput>
    /**
     * In case the CustomerPricing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerPricingUpdateInput, CustomerPricingUncheckedUpdateInput>
  }

  /**
   * CustomerPricing delete
   */
  export type CustomerPricingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    /**
     * Filter which CustomerPricing to delete.
     */
    where: CustomerPricingWhereUniqueInput
  }

  /**
   * CustomerPricing deleteMany
   */
  export type CustomerPricingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPricings to delete
     */
    where?: CustomerPricingWhereInput
    /**
     * Limit how many CustomerPricings to delete.
     */
    limit?: number
  }

  /**
   * CustomerPricing without action
   */
  export type CustomerPricingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    sqft: number | null
    bedrooms: number | null
    bathrooms: Decimal | null
    version: number | null
  }

  export type PlanSumAggregateOutputType = {
    sqft: number | null
    bedrooms: number | null
    bathrooms: Decimal | null
    version: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    type: $Enums.PlanType | null
    sqft: number | null
    bedrooms: number | null
    bathrooms: Decimal | null
    garage: string | null
    style: string | null
    version: number | null
    isActive: boolean | null
    pdssUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    type: $Enums.PlanType | null
    sqft: number | null
    bedrooms: number | null
    bathrooms: Decimal | null
    garage: string | null
    style: string | null
    version: number | null
    isActive: boolean | null
    pdssUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    code: number
    name: number
    type: number
    sqft: number
    bedrooms: number
    bathrooms: number
    garage: number
    style: number
    version: number
    isActive: number
    pdssUrl: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    sqft?: true
    bedrooms?: true
    bathrooms?: true
    version?: true
  }

  export type PlanSumAggregateInputType = {
    sqft?: true
    bedrooms?: true
    bathrooms?: true
    version?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    sqft?: true
    bedrooms?: true
    bathrooms?: true
    garage?: true
    style?: true
    version?: true
    isActive?: true
    pdssUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    sqft?: true
    bedrooms?: true
    bathrooms?: true
    garage?: true
    style?: true
    version?: true
    isActive?: true
    pdssUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    sqft?: true
    bedrooms?: true
    bathrooms?: true
    garage?: true
    style?: true
    version?: true
    isActive?: true
    pdssUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    code: string
    name: string | null
    type: $Enums.PlanType
    sqft: number | null
    bedrooms: number | null
    bathrooms: Decimal | null
    garage: string | null
    style: string | null
    version: number
    isActive: boolean
    pdssUrl: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    sqft?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    garage?: boolean
    style?: boolean
    version?: boolean
    isActive?: boolean
    pdssUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    elevations?: boolean | Plan$elevationsArgs<ExtArgs>
    options?: boolean | Plan$optionsArgs<ExtArgs>
    templateItems?: boolean | Plan$templateItemsArgs<ExtArgs>
    jobs?: boolean | Plan$jobsArgs<ExtArgs>
    variancePatterns?: boolean | Plan$variancePatternsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    sqft?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    garage?: boolean
    style?: boolean
    version?: boolean
    isActive?: boolean
    pdssUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    sqft?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    garage?: boolean
    style?: boolean
    version?: boolean
    isActive?: boolean
    pdssUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    sqft?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    garage?: boolean
    style?: boolean
    version?: boolean
    isActive?: boolean
    pdssUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "type" | "sqft" | "bedrooms" | "bathrooms" | "garage" | "style" | "version" | "isActive" | "pdssUrl" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elevations?: boolean | Plan$elevationsArgs<ExtArgs>
    options?: boolean | Plan$optionsArgs<ExtArgs>
    templateItems?: boolean | Plan$templateItemsArgs<ExtArgs>
    jobs?: boolean | Plan$jobsArgs<ExtArgs>
    variancePatterns?: boolean | Plan$variancePatternsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      elevations: Prisma.$PlanElevationPayload<ExtArgs>[]
      options: Prisma.$PlanOptionPayload<ExtArgs>[]
      templateItems: Prisma.$PlanTemplateItemPayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
      variancePatterns: Prisma.$VariancePatternPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string | null
      type: $Enums.PlanType
      sqft: number | null
      bedrooms: number | null
      bathrooms: Prisma.Decimal | null
      garage: string | null
      style: string | null
      version: number
      isActive: boolean
      pdssUrl: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    elevations<T extends Plan$elevationsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$elevationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    options<T extends Plan$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    templateItems<T extends Plan$templateItemsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$templateItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends Plan$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variancePatterns<T extends Plan$variancePatternsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$variancePatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly code: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly type: FieldRef<"Plan", 'PlanType'>
    readonly sqft: FieldRef<"Plan", 'Int'>
    readonly bedrooms: FieldRef<"Plan", 'Int'>
    readonly bathrooms: FieldRef<"Plan", 'Decimal'>
    readonly garage: FieldRef<"Plan", 'String'>
    readonly style: FieldRef<"Plan", 'String'>
    readonly version: FieldRef<"Plan", 'Int'>
    readonly isActive: FieldRef<"Plan", 'Boolean'>
    readonly pdssUrl: FieldRef<"Plan", 'String'>
    readonly notes: FieldRef<"Plan", 'String'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.elevations
   */
  export type Plan$elevationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    where?: PlanElevationWhereInput
    orderBy?: PlanElevationOrderByWithRelationInput | PlanElevationOrderByWithRelationInput[]
    cursor?: PlanElevationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanElevationScalarFieldEnum | PlanElevationScalarFieldEnum[]
  }

  /**
   * Plan.options
   */
  export type Plan$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    where?: PlanOptionWhereInput
    orderBy?: PlanOptionOrderByWithRelationInput | PlanOptionOrderByWithRelationInput[]
    cursor?: PlanOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanOptionScalarFieldEnum | PlanOptionScalarFieldEnum[]
  }

  /**
   * Plan.templateItems
   */
  export type Plan$templateItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    where?: PlanTemplateItemWhereInput
    orderBy?: PlanTemplateItemOrderByWithRelationInput | PlanTemplateItemOrderByWithRelationInput[]
    cursor?: PlanTemplateItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanTemplateItemScalarFieldEnum | PlanTemplateItemScalarFieldEnum[]
  }

  /**
   * Plan.jobs
   */
  export type Plan$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Plan.variancePatterns
   */
  export type Plan$variancePatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    where?: VariancePatternWhereInput
    orderBy?: VariancePatternOrderByWithRelationInput | VariancePatternOrderByWithRelationInput[]
    cursor?: VariancePatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariancePatternScalarFieldEnum | VariancePatternScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanElevation
   */

  export type AggregatePlanElevation = {
    _count: PlanElevationCountAggregateOutputType | null
    _min: PlanElevationMinAggregateOutputType | null
    _max: PlanElevationMaxAggregateOutputType | null
  }

  export type PlanElevationMinAggregateOutputType = {
    id: string | null
    planId: string | null
    code: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanElevationMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    code: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanElevationCountAggregateOutputType = {
    id: number
    planId: number
    code: number
    name: number
    description: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanElevationMinAggregateInputType = {
    id?: true
    planId?: true
    code?: true
    name?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanElevationMaxAggregateInputType = {
    id?: true
    planId?: true
    code?: true
    name?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanElevationCountAggregateInputType = {
    id?: true
    planId?: true
    code?: true
    name?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanElevationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanElevation to aggregate.
     */
    where?: PlanElevationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanElevations to fetch.
     */
    orderBy?: PlanElevationOrderByWithRelationInput | PlanElevationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanElevationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanElevations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanElevations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanElevations
    **/
    _count?: true | PlanElevationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanElevationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanElevationMaxAggregateInputType
  }

  export type GetPlanElevationAggregateType<T extends PlanElevationAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanElevation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanElevation[P]>
      : GetScalarType<T[P], AggregatePlanElevation[P]>
  }




  export type PlanElevationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanElevationWhereInput
    orderBy?: PlanElevationOrderByWithAggregationInput | PlanElevationOrderByWithAggregationInput[]
    by: PlanElevationScalarFieldEnum[] | PlanElevationScalarFieldEnum
    having?: PlanElevationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanElevationCountAggregateInputType | true
    _min?: PlanElevationMinAggregateInputType
    _max?: PlanElevationMaxAggregateInputType
  }

  export type PlanElevationGroupByOutputType = {
    id: string
    planId: string
    code: string
    name: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlanElevationCountAggregateOutputType | null
    _min: PlanElevationMinAggregateOutputType | null
    _max: PlanElevationMaxAggregateOutputType | null
  }

  type GetPlanElevationGroupByPayload<T extends PlanElevationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanElevationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanElevationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanElevationGroupByOutputType[P]>
            : GetScalarType<T[P], PlanElevationGroupByOutputType[P]>
        }
      >
    >


  export type PlanElevationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    jobs?: boolean | PlanElevation$jobsArgs<ExtArgs>
    _count?: boolean | PlanElevationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planElevation"]>

  export type PlanElevationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planElevation"]>

  export type PlanElevationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planElevation"]>

  export type PlanElevationSelectScalar = {
    id?: boolean
    planId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanElevationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "code" | "name" | "description" | "imageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["planElevation"]>
  export type PlanElevationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    jobs?: boolean | PlanElevation$jobsArgs<ExtArgs>
    _count?: boolean | PlanElevationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanElevationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanElevationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PlanElevationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanElevation"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
      jobs: Prisma.$JobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      code: string
      name: string | null
      description: string | null
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planElevation"]>
    composites: {}
  }

  type PlanElevationGetPayload<S extends boolean | null | undefined | PlanElevationDefaultArgs> = $Result.GetResult<Prisma.$PlanElevationPayload, S>

  type PlanElevationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanElevationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanElevationCountAggregateInputType | true
    }

  export interface PlanElevationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanElevation'], meta: { name: 'PlanElevation' } }
    /**
     * Find zero or one PlanElevation that matches the filter.
     * @param {PlanElevationFindUniqueArgs} args - Arguments to find a PlanElevation
     * @example
     * // Get one PlanElevation
     * const planElevation = await prisma.planElevation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanElevationFindUniqueArgs>(args: SelectSubset<T, PlanElevationFindUniqueArgs<ExtArgs>>): Prisma__PlanElevationClient<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanElevation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanElevationFindUniqueOrThrowArgs} args - Arguments to find a PlanElevation
     * @example
     * // Get one PlanElevation
     * const planElevation = await prisma.planElevation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanElevationFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanElevationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanElevationClient<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanElevation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanElevationFindFirstArgs} args - Arguments to find a PlanElevation
     * @example
     * // Get one PlanElevation
     * const planElevation = await prisma.planElevation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanElevationFindFirstArgs>(args?: SelectSubset<T, PlanElevationFindFirstArgs<ExtArgs>>): Prisma__PlanElevationClient<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanElevation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanElevationFindFirstOrThrowArgs} args - Arguments to find a PlanElevation
     * @example
     * // Get one PlanElevation
     * const planElevation = await prisma.planElevation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanElevationFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanElevationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanElevationClient<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanElevations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanElevationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanElevations
     * const planElevations = await prisma.planElevation.findMany()
     * 
     * // Get first 10 PlanElevations
     * const planElevations = await prisma.planElevation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planElevationWithIdOnly = await prisma.planElevation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanElevationFindManyArgs>(args?: SelectSubset<T, PlanElevationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanElevation.
     * @param {PlanElevationCreateArgs} args - Arguments to create a PlanElevation.
     * @example
     * // Create one PlanElevation
     * const PlanElevation = await prisma.planElevation.create({
     *   data: {
     *     // ... data to create a PlanElevation
     *   }
     * })
     * 
     */
    create<T extends PlanElevationCreateArgs>(args: SelectSubset<T, PlanElevationCreateArgs<ExtArgs>>): Prisma__PlanElevationClient<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanElevations.
     * @param {PlanElevationCreateManyArgs} args - Arguments to create many PlanElevations.
     * @example
     * // Create many PlanElevations
     * const planElevation = await prisma.planElevation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanElevationCreateManyArgs>(args?: SelectSubset<T, PlanElevationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanElevations and returns the data saved in the database.
     * @param {PlanElevationCreateManyAndReturnArgs} args - Arguments to create many PlanElevations.
     * @example
     * // Create many PlanElevations
     * const planElevation = await prisma.planElevation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanElevations and only return the `id`
     * const planElevationWithIdOnly = await prisma.planElevation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanElevationCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanElevationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanElevation.
     * @param {PlanElevationDeleteArgs} args - Arguments to delete one PlanElevation.
     * @example
     * // Delete one PlanElevation
     * const PlanElevation = await prisma.planElevation.delete({
     *   where: {
     *     // ... filter to delete one PlanElevation
     *   }
     * })
     * 
     */
    delete<T extends PlanElevationDeleteArgs>(args: SelectSubset<T, PlanElevationDeleteArgs<ExtArgs>>): Prisma__PlanElevationClient<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanElevation.
     * @param {PlanElevationUpdateArgs} args - Arguments to update one PlanElevation.
     * @example
     * // Update one PlanElevation
     * const planElevation = await prisma.planElevation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanElevationUpdateArgs>(args: SelectSubset<T, PlanElevationUpdateArgs<ExtArgs>>): Prisma__PlanElevationClient<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanElevations.
     * @param {PlanElevationDeleteManyArgs} args - Arguments to filter PlanElevations to delete.
     * @example
     * // Delete a few PlanElevations
     * const { count } = await prisma.planElevation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanElevationDeleteManyArgs>(args?: SelectSubset<T, PlanElevationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanElevations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanElevationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanElevations
     * const planElevation = await prisma.planElevation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanElevationUpdateManyArgs>(args: SelectSubset<T, PlanElevationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanElevations and returns the data updated in the database.
     * @param {PlanElevationUpdateManyAndReturnArgs} args - Arguments to update many PlanElevations.
     * @example
     * // Update many PlanElevations
     * const planElevation = await prisma.planElevation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanElevations and only return the `id`
     * const planElevationWithIdOnly = await prisma.planElevation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanElevationUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanElevationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanElevation.
     * @param {PlanElevationUpsertArgs} args - Arguments to update or create a PlanElevation.
     * @example
     * // Update or create a PlanElevation
     * const planElevation = await prisma.planElevation.upsert({
     *   create: {
     *     // ... data to create a PlanElevation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanElevation we want to update
     *   }
     * })
     */
    upsert<T extends PlanElevationUpsertArgs>(args: SelectSubset<T, PlanElevationUpsertArgs<ExtArgs>>): Prisma__PlanElevationClient<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanElevations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanElevationCountArgs} args - Arguments to filter PlanElevations to count.
     * @example
     * // Count the number of PlanElevations
     * const count = await prisma.planElevation.count({
     *   where: {
     *     // ... the filter for the PlanElevations we want to count
     *   }
     * })
    **/
    count<T extends PlanElevationCountArgs>(
      args?: Subset<T, PlanElevationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanElevationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanElevation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanElevationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanElevationAggregateArgs>(args: Subset<T, PlanElevationAggregateArgs>): Prisma.PrismaPromise<GetPlanElevationAggregateType<T>>

    /**
     * Group by PlanElevation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanElevationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanElevationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanElevationGroupByArgs['orderBy'] }
        : { orderBy?: PlanElevationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanElevationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanElevationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanElevation model
   */
  readonly fields: PlanElevationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanElevation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanElevationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobs<T extends PlanElevation$jobsArgs<ExtArgs> = {}>(args?: Subset<T, PlanElevation$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanElevation model
   */
  interface PlanElevationFieldRefs {
    readonly id: FieldRef<"PlanElevation", 'String'>
    readonly planId: FieldRef<"PlanElevation", 'String'>
    readonly code: FieldRef<"PlanElevation", 'String'>
    readonly name: FieldRef<"PlanElevation", 'String'>
    readonly description: FieldRef<"PlanElevation", 'String'>
    readonly imageUrl: FieldRef<"PlanElevation", 'String'>
    readonly createdAt: FieldRef<"PlanElevation", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanElevation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanElevation findUnique
   */
  export type PlanElevationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    /**
     * Filter, which PlanElevation to fetch.
     */
    where: PlanElevationWhereUniqueInput
  }

  /**
   * PlanElevation findUniqueOrThrow
   */
  export type PlanElevationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    /**
     * Filter, which PlanElevation to fetch.
     */
    where: PlanElevationWhereUniqueInput
  }

  /**
   * PlanElevation findFirst
   */
  export type PlanElevationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    /**
     * Filter, which PlanElevation to fetch.
     */
    where?: PlanElevationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanElevations to fetch.
     */
    orderBy?: PlanElevationOrderByWithRelationInput | PlanElevationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanElevations.
     */
    cursor?: PlanElevationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanElevations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanElevations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanElevations.
     */
    distinct?: PlanElevationScalarFieldEnum | PlanElevationScalarFieldEnum[]
  }

  /**
   * PlanElevation findFirstOrThrow
   */
  export type PlanElevationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    /**
     * Filter, which PlanElevation to fetch.
     */
    where?: PlanElevationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanElevations to fetch.
     */
    orderBy?: PlanElevationOrderByWithRelationInput | PlanElevationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanElevations.
     */
    cursor?: PlanElevationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanElevations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanElevations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanElevations.
     */
    distinct?: PlanElevationScalarFieldEnum | PlanElevationScalarFieldEnum[]
  }

  /**
   * PlanElevation findMany
   */
  export type PlanElevationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    /**
     * Filter, which PlanElevations to fetch.
     */
    where?: PlanElevationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanElevations to fetch.
     */
    orderBy?: PlanElevationOrderByWithRelationInput | PlanElevationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanElevations.
     */
    cursor?: PlanElevationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanElevations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanElevations.
     */
    skip?: number
    distinct?: PlanElevationScalarFieldEnum | PlanElevationScalarFieldEnum[]
  }

  /**
   * PlanElevation create
   */
  export type PlanElevationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanElevation.
     */
    data: XOR<PlanElevationCreateInput, PlanElevationUncheckedCreateInput>
  }

  /**
   * PlanElevation createMany
   */
  export type PlanElevationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanElevations.
     */
    data: PlanElevationCreateManyInput | PlanElevationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanElevation createManyAndReturn
   */
  export type PlanElevationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * The data used to create many PlanElevations.
     */
    data: PlanElevationCreateManyInput | PlanElevationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanElevation update
   */
  export type PlanElevationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanElevation.
     */
    data: XOR<PlanElevationUpdateInput, PlanElevationUncheckedUpdateInput>
    /**
     * Choose, which PlanElevation to update.
     */
    where: PlanElevationWhereUniqueInput
  }

  /**
   * PlanElevation updateMany
   */
  export type PlanElevationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanElevations.
     */
    data: XOR<PlanElevationUpdateManyMutationInput, PlanElevationUncheckedUpdateManyInput>
    /**
     * Filter which PlanElevations to update
     */
    where?: PlanElevationWhereInput
    /**
     * Limit how many PlanElevations to update.
     */
    limit?: number
  }

  /**
   * PlanElevation updateManyAndReturn
   */
  export type PlanElevationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * The data used to update PlanElevations.
     */
    data: XOR<PlanElevationUpdateManyMutationInput, PlanElevationUncheckedUpdateManyInput>
    /**
     * Filter which PlanElevations to update
     */
    where?: PlanElevationWhereInput
    /**
     * Limit how many PlanElevations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanElevation upsert
   */
  export type PlanElevationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanElevation to update in case it exists.
     */
    where: PlanElevationWhereUniqueInput
    /**
     * In case the PlanElevation found by the `where` argument doesn't exist, create a new PlanElevation with this data.
     */
    create: XOR<PlanElevationCreateInput, PlanElevationUncheckedCreateInput>
    /**
     * In case the PlanElevation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanElevationUpdateInput, PlanElevationUncheckedUpdateInput>
  }

  /**
   * PlanElevation delete
   */
  export type PlanElevationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    /**
     * Filter which PlanElevation to delete.
     */
    where: PlanElevationWhereUniqueInput
  }

  /**
   * PlanElevation deleteMany
   */
  export type PlanElevationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanElevations to delete
     */
    where?: PlanElevationWhereInput
    /**
     * Limit how many PlanElevations to delete.
     */
    limit?: number
  }

  /**
   * PlanElevation.jobs
   */
  export type PlanElevation$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * PlanElevation without action
   */
  export type PlanElevationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
  }


  /**
   * Model PlanOption
   */

  export type AggregatePlanOption = {
    _count: PlanOptionCountAggregateOutputType | null
    _avg: PlanOptionAvgAggregateOutputType | null
    _sum: PlanOptionSumAggregateOutputType | null
    _min: PlanOptionMinAggregateOutputType | null
    _max: PlanOptionMaxAggregateOutputType | null
  }

  export type PlanOptionAvgAggregateOutputType = {
    basePrice: Decimal | null
  }

  export type PlanOptionSumAggregateOutputType = {
    basePrice: Decimal | null
  }

  export type PlanOptionMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    category: $Enums.OptionCategory | null
    basePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanOptionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    category: $Enums.OptionCategory | null
    basePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanOptionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    category: number
    basePrice: number
    triggersPacks: number
    appliesTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanOptionAvgAggregateInputType = {
    basePrice?: true
  }

  export type PlanOptionSumAggregateInputType = {
    basePrice?: true
  }

  export type PlanOptionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    basePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanOptionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    basePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanOptionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    basePrice?: true
    triggersPacks?: true
    appliesTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanOption to aggregate.
     */
    where?: PlanOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanOptions to fetch.
     */
    orderBy?: PlanOptionOrderByWithRelationInput | PlanOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanOptions
    **/
    _count?: true | PlanOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanOptionMaxAggregateInputType
  }

  export type GetPlanOptionAggregateType<T extends PlanOptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanOption[P]>
      : GetScalarType<T[P], AggregatePlanOption[P]>
  }




  export type PlanOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanOptionWhereInput
    orderBy?: PlanOptionOrderByWithAggregationInput | PlanOptionOrderByWithAggregationInput[]
    by: PlanOptionScalarFieldEnum[] | PlanOptionScalarFieldEnum
    having?: PlanOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanOptionCountAggregateInputType | true
    _avg?: PlanOptionAvgAggregateInputType
    _sum?: PlanOptionSumAggregateInputType
    _min?: PlanOptionMinAggregateInputType
    _max?: PlanOptionMaxAggregateInputType
  }

  export type PlanOptionGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    category: $Enums.OptionCategory
    basePrice: Decimal
    triggersPacks: string[]
    appliesTo: string[]
    createdAt: Date
    updatedAt: Date
    _count: PlanOptionCountAggregateOutputType | null
    _avg: PlanOptionAvgAggregateOutputType | null
    _sum: PlanOptionSumAggregateOutputType | null
    _min: PlanOptionMinAggregateOutputType | null
    _max: PlanOptionMaxAggregateOutputType | null
  }

  type GetPlanOptionGroupByPayload<T extends PlanOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanOptionGroupByOutputType[P]>
            : GetScalarType<T[P], PlanOptionGroupByOutputType[P]>
        }
      >
    >


  export type PlanOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    triggersPacks?: boolean
    appliesTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plans?: boolean | PlanOption$plansArgs<ExtArgs>
    jobOptions?: boolean | PlanOption$jobOptionsArgs<ExtArgs>
    _count?: boolean | PlanOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planOption"]>

  export type PlanOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    triggersPacks?: boolean
    appliesTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planOption"]>

  export type PlanOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    triggersPacks?: boolean
    appliesTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planOption"]>

  export type PlanOptionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    triggersPacks?: boolean
    appliesTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "category" | "basePrice" | "triggersPacks" | "appliesTo" | "createdAt" | "updatedAt", ExtArgs["result"]["planOption"]>
  export type PlanOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | PlanOption$plansArgs<ExtArgs>
    jobOptions?: boolean | PlanOption$jobOptionsArgs<ExtArgs>
    _count?: boolean | PlanOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlanOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanOption"
    objects: {
      plans: Prisma.$PlanPayload<ExtArgs>[]
      jobOptions: Prisma.$JobOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      category: $Enums.OptionCategory
      basePrice: Prisma.Decimal
      triggersPacks: string[]
      appliesTo: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planOption"]>
    composites: {}
  }

  type PlanOptionGetPayload<S extends boolean | null | undefined | PlanOptionDefaultArgs> = $Result.GetResult<Prisma.$PlanOptionPayload, S>

  type PlanOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanOptionCountAggregateInputType | true
    }

  export interface PlanOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanOption'], meta: { name: 'PlanOption' } }
    /**
     * Find zero or one PlanOption that matches the filter.
     * @param {PlanOptionFindUniqueArgs} args - Arguments to find a PlanOption
     * @example
     * // Get one PlanOption
     * const planOption = await prisma.planOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanOptionFindUniqueArgs>(args: SelectSubset<T, PlanOptionFindUniqueArgs<ExtArgs>>): Prisma__PlanOptionClient<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanOptionFindUniqueOrThrowArgs} args - Arguments to find a PlanOption
     * @example
     * // Get one PlanOption
     * const planOption = await prisma.planOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanOptionClient<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOptionFindFirstArgs} args - Arguments to find a PlanOption
     * @example
     * // Get one PlanOption
     * const planOption = await prisma.planOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanOptionFindFirstArgs>(args?: SelectSubset<T, PlanOptionFindFirstArgs<ExtArgs>>): Prisma__PlanOptionClient<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOptionFindFirstOrThrowArgs} args - Arguments to find a PlanOption
     * @example
     * // Get one PlanOption
     * const planOption = await prisma.planOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanOptionClient<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanOptions
     * const planOptions = await prisma.planOption.findMany()
     * 
     * // Get first 10 PlanOptions
     * const planOptions = await prisma.planOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planOptionWithIdOnly = await prisma.planOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanOptionFindManyArgs>(args?: SelectSubset<T, PlanOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanOption.
     * @param {PlanOptionCreateArgs} args - Arguments to create a PlanOption.
     * @example
     * // Create one PlanOption
     * const PlanOption = await prisma.planOption.create({
     *   data: {
     *     // ... data to create a PlanOption
     *   }
     * })
     * 
     */
    create<T extends PlanOptionCreateArgs>(args: SelectSubset<T, PlanOptionCreateArgs<ExtArgs>>): Prisma__PlanOptionClient<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanOptions.
     * @param {PlanOptionCreateManyArgs} args - Arguments to create many PlanOptions.
     * @example
     * // Create many PlanOptions
     * const planOption = await prisma.planOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanOptionCreateManyArgs>(args?: SelectSubset<T, PlanOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanOptions and returns the data saved in the database.
     * @param {PlanOptionCreateManyAndReturnArgs} args - Arguments to create many PlanOptions.
     * @example
     * // Create many PlanOptions
     * const planOption = await prisma.planOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanOptions and only return the `id`
     * const planOptionWithIdOnly = await prisma.planOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanOption.
     * @param {PlanOptionDeleteArgs} args - Arguments to delete one PlanOption.
     * @example
     * // Delete one PlanOption
     * const PlanOption = await prisma.planOption.delete({
     *   where: {
     *     // ... filter to delete one PlanOption
     *   }
     * })
     * 
     */
    delete<T extends PlanOptionDeleteArgs>(args: SelectSubset<T, PlanOptionDeleteArgs<ExtArgs>>): Prisma__PlanOptionClient<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanOption.
     * @param {PlanOptionUpdateArgs} args - Arguments to update one PlanOption.
     * @example
     * // Update one PlanOption
     * const planOption = await prisma.planOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanOptionUpdateArgs>(args: SelectSubset<T, PlanOptionUpdateArgs<ExtArgs>>): Prisma__PlanOptionClient<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanOptions.
     * @param {PlanOptionDeleteManyArgs} args - Arguments to filter PlanOptions to delete.
     * @example
     * // Delete a few PlanOptions
     * const { count } = await prisma.planOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanOptionDeleteManyArgs>(args?: SelectSubset<T, PlanOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanOptions
     * const planOption = await prisma.planOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanOptionUpdateManyArgs>(args: SelectSubset<T, PlanOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanOptions and returns the data updated in the database.
     * @param {PlanOptionUpdateManyAndReturnArgs} args - Arguments to update many PlanOptions.
     * @example
     * // Update many PlanOptions
     * const planOption = await prisma.planOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanOptions and only return the `id`
     * const planOptionWithIdOnly = await prisma.planOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanOption.
     * @param {PlanOptionUpsertArgs} args - Arguments to update or create a PlanOption.
     * @example
     * // Update or create a PlanOption
     * const planOption = await prisma.planOption.upsert({
     *   create: {
     *     // ... data to create a PlanOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanOption we want to update
     *   }
     * })
     */
    upsert<T extends PlanOptionUpsertArgs>(args: SelectSubset<T, PlanOptionUpsertArgs<ExtArgs>>): Prisma__PlanOptionClient<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOptionCountArgs} args - Arguments to filter PlanOptions to count.
     * @example
     * // Count the number of PlanOptions
     * const count = await prisma.planOption.count({
     *   where: {
     *     // ... the filter for the PlanOptions we want to count
     *   }
     * })
    **/
    count<T extends PlanOptionCountArgs>(
      args?: Subset<T, PlanOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanOptionAggregateArgs>(args: Subset<T, PlanOptionAggregateArgs>): Prisma.PrismaPromise<GetPlanOptionAggregateType<T>>

    /**
     * Group by PlanOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanOptionGroupByArgs['orderBy'] }
        : { orderBy?: PlanOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanOption model
   */
  readonly fields: PlanOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plans<T extends PlanOption$plansArgs<ExtArgs> = {}>(args?: Subset<T, PlanOption$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobOptions<T extends PlanOption$jobOptionsArgs<ExtArgs> = {}>(args?: Subset<T, PlanOption$jobOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanOption model
   */
  interface PlanOptionFieldRefs {
    readonly id: FieldRef<"PlanOption", 'String'>
    readonly code: FieldRef<"PlanOption", 'String'>
    readonly name: FieldRef<"PlanOption", 'String'>
    readonly description: FieldRef<"PlanOption", 'String'>
    readonly category: FieldRef<"PlanOption", 'OptionCategory'>
    readonly basePrice: FieldRef<"PlanOption", 'Decimal'>
    readonly triggersPacks: FieldRef<"PlanOption", 'String[]'>
    readonly appliesTo: FieldRef<"PlanOption", 'String[]'>
    readonly createdAt: FieldRef<"PlanOption", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanOption findUnique
   */
  export type PlanOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanOption to fetch.
     */
    where: PlanOptionWhereUniqueInput
  }

  /**
   * PlanOption findUniqueOrThrow
   */
  export type PlanOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanOption to fetch.
     */
    where: PlanOptionWhereUniqueInput
  }

  /**
   * PlanOption findFirst
   */
  export type PlanOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanOption to fetch.
     */
    where?: PlanOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanOptions to fetch.
     */
    orderBy?: PlanOptionOrderByWithRelationInput | PlanOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanOptions.
     */
    cursor?: PlanOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanOptions.
     */
    distinct?: PlanOptionScalarFieldEnum | PlanOptionScalarFieldEnum[]
  }

  /**
   * PlanOption findFirstOrThrow
   */
  export type PlanOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanOption to fetch.
     */
    where?: PlanOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanOptions to fetch.
     */
    orderBy?: PlanOptionOrderByWithRelationInput | PlanOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanOptions.
     */
    cursor?: PlanOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanOptions.
     */
    distinct?: PlanOptionScalarFieldEnum | PlanOptionScalarFieldEnum[]
  }

  /**
   * PlanOption findMany
   */
  export type PlanOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanOptions to fetch.
     */
    where?: PlanOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanOptions to fetch.
     */
    orderBy?: PlanOptionOrderByWithRelationInput | PlanOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanOptions.
     */
    cursor?: PlanOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanOptions.
     */
    skip?: number
    distinct?: PlanOptionScalarFieldEnum | PlanOptionScalarFieldEnum[]
  }

  /**
   * PlanOption create
   */
  export type PlanOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanOption.
     */
    data: XOR<PlanOptionCreateInput, PlanOptionUncheckedCreateInput>
  }

  /**
   * PlanOption createMany
   */
  export type PlanOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanOptions.
     */
    data: PlanOptionCreateManyInput | PlanOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanOption createManyAndReturn
   */
  export type PlanOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * The data used to create many PlanOptions.
     */
    data: PlanOptionCreateManyInput | PlanOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanOption update
   */
  export type PlanOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanOption.
     */
    data: XOR<PlanOptionUpdateInput, PlanOptionUncheckedUpdateInput>
    /**
     * Choose, which PlanOption to update.
     */
    where: PlanOptionWhereUniqueInput
  }

  /**
   * PlanOption updateMany
   */
  export type PlanOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanOptions.
     */
    data: XOR<PlanOptionUpdateManyMutationInput, PlanOptionUncheckedUpdateManyInput>
    /**
     * Filter which PlanOptions to update
     */
    where?: PlanOptionWhereInput
    /**
     * Limit how many PlanOptions to update.
     */
    limit?: number
  }

  /**
   * PlanOption updateManyAndReturn
   */
  export type PlanOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * The data used to update PlanOptions.
     */
    data: XOR<PlanOptionUpdateManyMutationInput, PlanOptionUncheckedUpdateManyInput>
    /**
     * Filter which PlanOptions to update
     */
    where?: PlanOptionWhereInput
    /**
     * Limit how many PlanOptions to update.
     */
    limit?: number
  }

  /**
   * PlanOption upsert
   */
  export type PlanOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanOption to update in case it exists.
     */
    where: PlanOptionWhereUniqueInput
    /**
     * In case the PlanOption found by the `where` argument doesn't exist, create a new PlanOption with this data.
     */
    create: XOR<PlanOptionCreateInput, PlanOptionUncheckedCreateInput>
    /**
     * In case the PlanOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanOptionUpdateInput, PlanOptionUncheckedUpdateInput>
  }

  /**
   * PlanOption delete
   */
  export type PlanOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
    /**
     * Filter which PlanOption to delete.
     */
    where: PlanOptionWhereUniqueInput
  }

  /**
   * PlanOption deleteMany
   */
  export type PlanOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanOptions to delete
     */
    where?: PlanOptionWhereInput
    /**
     * Limit how many PlanOptions to delete.
     */
    limit?: number
  }

  /**
   * PlanOption.plans
   */
  export type PlanOption$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * PlanOption.jobOptions
   */
  export type PlanOption$jobOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    where?: JobOptionWhereInput
    orderBy?: JobOptionOrderByWithRelationInput | JobOptionOrderByWithRelationInput[]
    cursor?: JobOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobOptionScalarFieldEnum | JobOptionScalarFieldEnum[]
  }

  /**
   * PlanOption without action
   */
  export type PlanOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOption
     */
    select?: PlanOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOption
     */
    omit?: PlanOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOptionInclude<ExtArgs> | null
  }


  /**
   * Model PlanTemplateItem
   */

  export type AggregatePlanTemplateItem = {
    _count: PlanTemplateItemCountAggregateOutputType | null
    _avg: PlanTemplateItemAvgAggregateOutputType | null
    _sum: PlanTemplateItemSumAggregateOutputType | null
    _min: PlanTemplateItemMinAggregateOutputType | null
    _max: PlanTemplateItemMaxAggregateOutputType | null
  }

  export type PlanTemplateItemAvgAggregateOutputType = {
    quantity: Decimal | null
    wasteFactor: Decimal | null
    averageVariance: Decimal | null
    varianceCount: number | null
    confidenceScore: Decimal | null
  }

  export type PlanTemplateItemSumAggregateOutputType = {
    quantity: Decimal | null
    wasteFactor: Decimal | null
    averageVariance: Decimal | null
    varianceCount: number | null
    confidenceScore: Decimal | null
  }

  export type PlanTemplateItemMinAggregateOutputType = {
    id: string | null
    planId: string | null
    materialId: string | null
    quantity: Decimal | null
    unit: string | null
    wasteFactor: Decimal | null
    category: string | null
    subcategory: string | null
    averageVariance: Decimal | null
    varianceCount: number | null
    lastVarianceDate: Date | null
    confidenceScore: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanTemplateItemMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    materialId: string | null
    quantity: Decimal | null
    unit: string | null
    wasteFactor: Decimal | null
    category: string | null
    subcategory: string | null
    averageVariance: Decimal | null
    varianceCount: number | null
    lastVarianceDate: Date | null
    confidenceScore: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanTemplateItemCountAggregateOutputType = {
    id: number
    planId: number
    materialId: number
    quantity: number
    unit: number
    wasteFactor: number
    category: number
    subcategory: number
    averageVariance: number
    varianceCount: number
    lastVarianceDate: number
    confidenceScore: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanTemplateItemAvgAggregateInputType = {
    quantity?: true
    wasteFactor?: true
    averageVariance?: true
    varianceCount?: true
    confidenceScore?: true
  }

  export type PlanTemplateItemSumAggregateInputType = {
    quantity?: true
    wasteFactor?: true
    averageVariance?: true
    varianceCount?: true
    confidenceScore?: true
  }

  export type PlanTemplateItemMinAggregateInputType = {
    id?: true
    planId?: true
    materialId?: true
    quantity?: true
    unit?: true
    wasteFactor?: true
    category?: true
    subcategory?: true
    averageVariance?: true
    varianceCount?: true
    lastVarianceDate?: true
    confidenceScore?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanTemplateItemMaxAggregateInputType = {
    id?: true
    planId?: true
    materialId?: true
    quantity?: true
    unit?: true
    wasteFactor?: true
    category?: true
    subcategory?: true
    averageVariance?: true
    varianceCount?: true
    lastVarianceDate?: true
    confidenceScore?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanTemplateItemCountAggregateInputType = {
    id?: true
    planId?: true
    materialId?: true
    quantity?: true
    unit?: true
    wasteFactor?: true
    category?: true
    subcategory?: true
    averageVariance?: true
    varianceCount?: true
    lastVarianceDate?: true
    confidenceScore?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanTemplateItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanTemplateItem to aggregate.
     */
    where?: PlanTemplateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanTemplateItems to fetch.
     */
    orderBy?: PlanTemplateItemOrderByWithRelationInput | PlanTemplateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanTemplateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanTemplateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanTemplateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanTemplateItems
    **/
    _count?: true | PlanTemplateItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanTemplateItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanTemplateItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanTemplateItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanTemplateItemMaxAggregateInputType
  }

  export type GetPlanTemplateItemAggregateType<T extends PlanTemplateItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanTemplateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanTemplateItem[P]>
      : GetScalarType<T[P], AggregatePlanTemplateItem[P]>
  }




  export type PlanTemplateItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanTemplateItemWhereInput
    orderBy?: PlanTemplateItemOrderByWithAggregationInput | PlanTemplateItemOrderByWithAggregationInput[]
    by: PlanTemplateItemScalarFieldEnum[] | PlanTemplateItemScalarFieldEnum
    having?: PlanTemplateItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanTemplateItemCountAggregateInputType | true
    _avg?: PlanTemplateItemAvgAggregateInputType
    _sum?: PlanTemplateItemSumAggregateInputType
    _min?: PlanTemplateItemMinAggregateInputType
    _max?: PlanTemplateItemMaxAggregateInputType
  }

  export type PlanTemplateItemGroupByOutputType = {
    id: string
    planId: string
    materialId: string
    quantity: Decimal
    unit: string
    wasteFactor: Decimal
    category: string
    subcategory: string | null
    averageVariance: Decimal | null
    varianceCount: number
    lastVarianceDate: Date | null
    confidenceScore: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlanTemplateItemCountAggregateOutputType | null
    _avg: PlanTemplateItemAvgAggregateOutputType | null
    _sum: PlanTemplateItemSumAggregateOutputType | null
    _min: PlanTemplateItemMinAggregateOutputType | null
    _max: PlanTemplateItemMaxAggregateOutputType | null
  }

  type GetPlanTemplateItemGroupByPayload<T extends PlanTemplateItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanTemplateItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanTemplateItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanTemplateItemGroupByOutputType[P]>
            : GetScalarType<T[P], PlanTemplateItemGroupByOutputType[P]>
        }
      >
    >


  export type PlanTemplateItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    wasteFactor?: boolean
    category?: boolean
    subcategory?: boolean
    averageVariance?: boolean
    varianceCount?: boolean
    lastVarianceDate?: boolean
    confidenceScore?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planTemplateItem"]>

  export type PlanTemplateItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    wasteFactor?: boolean
    category?: boolean
    subcategory?: boolean
    averageVariance?: boolean
    varianceCount?: boolean
    lastVarianceDate?: boolean
    confidenceScore?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planTemplateItem"]>

  export type PlanTemplateItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    wasteFactor?: boolean
    category?: boolean
    subcategory?: boolean
    averageVariance?: boolean
    varianceCount?: boolean
    lastVarianceDate?: boolean
    confidenceScore?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planTemplateItem"]>

  export type PlanTemplateItemSelectScalar = {
    id?: boolean
    planId?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    wasteFactor?: boolean
    category?: boolean
    subcategory?: boolean
    averageVariance?: boolean
    varianceCount?: boolean
    lastVarianceDate?: boolean
    confidenceScore?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanTemplateItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "materialId" | "quantity" | "unit" | "wasteFactor" | "category" | "subcategory" | "averageVariance" | "varianceCount" | "lastVarianceDate" | "confidenceScore" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["planTemplateItem"]>
  export type PlanTemplateItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type PlanTemplateItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type PlanTemplateItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $PlanTemplateItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanTemplateItem"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      materialId: string
      quantity: Prisma.Decimal
      unit: string
      wasteFactor: Prisma.Decimal
      category: string
      subcategory: string | null
      averageVariance: Prisma.Decimal | null
      varianceCount: number
      lastVarianceDate: Date | null
      confidenceScore: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planTemplateItem"]>
    composites: {}
  }

  type PlanTemplateItemGetPayload<S extends boolean | null | undefined | PlanTemplateItemDefaultArgs> = $Result.GetResult<Prisma.$PlanTemplateItemPayload, S>

  type PlanTemplateItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanTemplateItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanTemplateItemCountAggregateInputType | true
    }

  export interface PlanTemplateItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanTemplateItem'], meta: { name: 'PlanTemplateItem' } }
    /**
     * Find zero or one PlanTemplateItem that matches the filter.
     * @param {PlanTemplateItemFindUniqueArgs} args - Arguments to find a PlanTemplateItem
     * @example
     * // Get one PlanTemplateItem
     * const planTemplateItem = await prisma.planTemplateItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanTemplateItemFindUniqueArgs>(args: SelectSubset<T, PlanTemplateItemFindUniqueArgs<ExtArgs>>): Prisma__PlanTemplateItemClient<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanTemplateItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanTemplateItemFindUniqueOrThrowArgs} args - Arguments to find a PlanTemplateItem
     * @example
     * // Get one PlanTemplateItem
     * const planTemplateItem = await prisma.planTemplateItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanTemplateItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanTemplateItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanTemplateItemClient<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanTemplateItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTemplateItemFindFirstArgs} args - Arguments to find a PlanTemplateItem
     * @example
     * // Get one PlanTemplateItem
     * const planTemplateItem = await prisma.planTemplateItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanTemplateItemFindFirstArgs>(args?: SelectSubset<T, PlanTemplateItemFindFirstArgs<ExtArgs>>): Prisma__PlanTemplateItemClient<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanTemplateItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTemplateItemFindFirstOrThrowArgs} args - Arguments to find a PlanTemplateItem
     * @example
     * // Get one PlanTemplateItem
     * const planTemplateItem = await prisma.planTemplateItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanTemplateItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanTemplateItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanTemplateItemClient<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanTemplateItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTemplateItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanTemplateItems
     * const planTemplateItems = await prisma.planTemplateItem.findMany()
     * 
     * // Get first 10 PlanTemplateItems
     * const planTemplateItems = await prisma.planTemplateItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planTemplateItemWithIdOnly = await prisma.planTemplateItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanTemplateItemFindManyArgs>(args?: SelectSubset<T, PlanTemplateItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanTemplateItem.
     * @param {PlanTemplateItemCreateArgs} args - Arguments to create a PlanTemplateItem.
     * @example
     * // Create one PlanTemplateItem
     * const PlanTemplateItem = await prisma.planTemplateItem.create({
     *   data: {
     *     // ... data to create a PlanTemplateItem
     *   }
     * })
     * 
     */
    create<T extends PlanTemplateItemCreateArgs>(args: SelectSubset<T, PlanTemplateItemCreateArgs<ExtArgs>>): Prisma__PlanTemplateItemClient<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanTemplateItems.
     * @param {PlanTemplateItemCreateManyArgs} args - Arguments to create many PlanTemplateItems.
     * @example
     * // Create many PlanTemplateItems
     * const planTemplateItem = await prisma.planTemplateItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanTemplateItemCreateManyArgs>(args?: SelectSubset<T, PlanTemplateItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanTemplateItems and returns the data saved in the database.
     * @param {PlanTemplateItemCreateManyAndReturnArgs} args - Arguments to create many PlanTemplateItems.
     * @example
     * // Create many PlanTemplateItems
     * const planTemplateItem = await prisma.planTemplateItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanTemplateItems and only return the `id`
     * const planTemplateItemWithIdOnly = await prisma.planTemplateItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanTemplateItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanTemplateItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanTemplateItem.
     * @param {PlanTemplateItemDeleteArgs} args - Arguments to delete one PlanTemplateItem.
     * @example
     * // Delete one PlanTemplateItem
     * const PlanTemplateItem = await prisma.planTemplateItem.delete({
     *   where: {
     *     // ... filter to delete one PlanTemplateItem
     *   }
     * })
     * 
     */
    delete<T extends PlanTemplateItemDeleteArgs>(args: SelectSubset<T, PlanTemplateItemDeleteArgs<ExtArgs>>): Prisma__PlanTemplateItemClient<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanTemplateItem.
     * @param {PlanTemplateItemUpdateArgs} args - Arguments to update one PlanTemplateItem.
     * @example
     * // Update one PlanTemplateItem
     * const planTemplateItem = await prisma.planTemplateItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanTemplateItemUpdateArgs>(args: SelectSubset<T, PlanTemplateItemUpdateArgs<ExtArgs>>): Prisma__PlanTemplateItemClient<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanTemplateItems.
     * @param {PlanTemplateItemDeleteManyArgs} args - Arguments to filter PlanTemplateItems to delete.
     * @example
     * // Delete a few PlanTemplateItems
     * const { count } = await prisma.planTemplateItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanTemplateItemDeleteManyArgs>(args?: SelectSubset<T, PlanTemplateItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanTemplateItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTemplateItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanTemplateItems
     * const planTemplateItem = await prisma.planTemplateItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanTemplateItemUpdateManyArgs>(args: SelectSubset<T, PlanTemplateItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanTemplateItems and returns the data updated in the database.
     * @param {PlanTemplateItemUpdateManyAndReturnArgs} args - Arguments to update many PlanTemplateItems.
     * @example
     * // Update many PlanTemplateItems
     * const planTemplateItem = await prisma.planTemplateItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanTemplateItems and only return the `id`
     * const planTemplateItemWithIdOnly = await prisma.planTemplateItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanTemplateItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanTemplateItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanTemplateItem.
     * @param {PlanTemplateItemUpsertArgs} args - Arguments to update or create a PlanTemplateItem.
     * @example
     * // Update or create a PlanTemplateItem
     * const planTemplateItem = await prisma.planTemplateItem.upsert({
     *   create: {
     *     // ... data to create a PlanTemplateItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanTemplateItem we want to update
     *   }
     * })
     */
    upsert<T extends PlanTemplateItemUpsertArgs>(args: SelectSubset<T, PlanTemplateItemUpsertArgs<ExtArgs>>): Prisma__PlanTemplateItemClient<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanTemplateItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTemplateItemCountArgs} args - Arguments to filter PlanTemplateItems to count.
     * @example
     * // Count the number of PlanTemplateItems
     * const count = await prisma.planTemplateItem.count({
     *   where: {
     *     // ... the filter for the PlanTemplateItems we want to count
     *   }
     * })
    **/
    count<T extends PlanTemplateItemCountArgs>(
      args?: Subset<T, PlanTemplateItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanTemplateItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanTemplateItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTemplateItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanTemplateItemAggregateArgs>(args: Subset<T, PlanTemplateItemAggregateArgs>): Prisma.PrismaPromise<GetPlanTemplateItemAggregateType<T>>

    /**
     * Group by PlanTemplateItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTemplateItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanTemplateItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanTemplateItemGroupByArgs['orderBy'] }
        : { orderBy?: PlanTemplateItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanTemplateItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanTemplateItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanTemplateItem model
   */
  readonly fields: PlanTemplateItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanTemplateItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanTemplateItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanTemplateItem model
   */
  interface PlanTemplateItemFieldRefs {
    readonly id: FieldRef<"PlanTemplateItem", 'String'>
    readonly planId: FieldRef<"PlanTemplateItem", 'String'>
    readonly materialId: FieldRef<"PlanTemplateItem", 'String'>
    readonly quantity: FieldRef<"PlanTemplateItem", 'Decimal'>
    readonly unit: FieldRef<"PlanTemplateItem", 'String'>
    readonly wasteFactor: FieldRef<"PlanTemplateItem", 'Decimal'>
    readonly category: FieldRef<"PlanTemplateItem", 'String'>
    readonly subcategory: FieldRef<"PlanTemplateItem", 'String'>
    readonly averageVariance: FieldRef<"PlanTemplateItem", 'Decimal'>
    readonly varianceCount: FieldRef<"PlanTemplateItem", 'Int'>
    readonly lastVarianceDate: FieldRef<"PlanTemplateItem", 'DateTime'>
    readonly confidenceScore: FieldRef<"PlanTemplateItem", 'Decimal'>
    readonly notes: FieldRef<"PlanTemplateItem", 'String'>
    readonly createdAt: FieldRef<"PlanTemplateItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanTemplateItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanTemplateItem findUnique
   */
  export type PlanTemplateItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanTemplateItem to fetch.
     */
    where: PlanTemplateItemWhereUniqueInput
  }

  /**
   * PlanTemplateItem findUniqueOrThrow
   */
  export type PlanTemplateItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanTemplateItem to fetch.
     */
    where: PlanTemplateItemWhereUniqueInput
  }

  /**
   * PlanTemplateItem findFirst
   */
  export type PlanTemplateItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanTemplateItem to fetch.
     */
    where?: PlanTemplateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanTemplateItems to fetch.
     */
    orderBy?: PlanTemplateItemOrderByWithRelationInput | PlanTemplateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanTemplateItems.
     */
    cursor?: PlanTemplateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanTemplateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanTemplateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanTemplateItems.
     */
    distinct?: PlanTemplateItemScalarFieldEnum | PlanTemplateItemScalarFieldEnum[]
  }

  /**
   * PlanTemplateItem findFirstOrThrow
   */
  export type PlanTemplateItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanTemplateItem to fetch.
     */
    where?: PlanTemplateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanTemplateItems to fetch.
     */
    orderBy?: PlanTemplateItemOrderByWithRelationInput | PlanTemplateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanTemplateItems.
     */
    cursor?: PlanTemplateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanTemplateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanTemplateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanTemplateItems.
     */
    distinct?: PlanTemplateItemScalarFieldEnum | PlanTemplateItemScalarFieldEnum[]
  }

  /**
   * PlanTemplateItem findMany
   */
  export type PlanTemplateItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanTemplateItems to fetch.
     */
    where?: PlanTemplateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanTemplateItems to fetch.
     */
    orderBy?: PlanTemplateItemOrderByWithRelationInput | PlanTemplateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanTemplateItems.
     */
    cursor?: PlanTemplateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanTemplateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanTemplateItems.
     */
    skip?: number
    distinct?: PlanTemplateItemScalarFieldEnum | PlanTemplateItemScalarFieldEnum[]
  }

  /**
   * PlanTemplateItem create
   */
  export type PlanTemplateItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanTemplateItem.
     */
    data: XOR<PlanTemplateItemCreateInput, PlanTemplateItemUncheckedCreateInput>
  }

  /**
   * PlanTemplateItem createMany
   */
  export type PlanTemplateItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanTemplateItems.
     */
    data: PlanTemplateItemCreateManyInput | PlanTemplateItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanTemplateItem createManyAndReturn
   */
  export type PlanTemplateItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * The data used to create many PlanTemplateItems.
     */
    data: PlanTemplateItemCreateManyInput | PlanTemplateItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanTemplateItem update
   */
  export type PlanTemplateItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanTemplateItem.
     */
    data: XOR<PlanTemplateItemUpdateInput, PlanTemplateItemUncheckedUpdateInput>
    /**
     * Choose, which PlanTemplateItem to update.
     */
    where: PlanTemplateItemWhereUniqueInput
  }

  /**
   * PlanTemplateItem updateMany
   */
  export type PlanTemplateItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanTemplateItems.
     */
    data: XOR<PlanTemplateItemUpdateManyMutationInput, PlanTemplateItemUncheckedUpdateManyInput>
    /**
     * Filter which PlanTemplateItems to update
     */
    where?: PlanTemplateItemWhereInput
    /**
     * Limit how many PlanTemplateItems to update.
     */
    limit?: number
  }

  /**
   * PlanTemplateItem updateManyAndReturn
   */
  export type PlanTemplateItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * The data used to update PlanTemplateItems.
     */
    data: XOR<PlanTemplateItemUpdateManyMutationInput, PlanTemplateItemUncheckedUpdateManyInput>
    /**
     * Filter which PlanTemplateItems to update
     */
    where?: PlanTemplateItemWhereInput
    /**
     * Limit how many PlanTemplateItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanTemplateItem upsert
   */
  export type PlanTemplateItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanTemplateItem to update in case it exists.
     */
    where: PlanTemplateItemWhereUniqueInput
    /**
     * In case the PlanTemplateItem found by the `where` argument doesn't exist, create a new PlanTemplateItem with this data.
     */
    create: XOR<PlanTemplateItemCreateInput, PlanTemplateItemUncheckedCreateInput>
    /**
     * In case the PlanTemplateItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanTemplateItemUpdateInput, PlanTemplateItemUncheckedUpdateInput>
  }

  /**
   * PlanTemplateItem delete
   */
  export type PlanTemplateItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    /**
     * Filter which PlanTemplateItem to delete.
     */
    where: PlanTemplateItemWhereUniqueInput
  }

  /**
   * PlanTemplateItem deleteMany
   */
  export type PlanTemplateItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanTemplateItems to delete
     */
    where?: PlanTemplateItemWhereInput
    /**
     * Limit how many PlanTemplateItems to delete.
     */
    limit?: number
  }

  /**
   * PlanTemplateItem without action
   */
  export type PlanTemplateItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    vendorCost: Decimal | null
    freight: Decimal | null
    rlBasePrice: Decimal | null
  }

  export type MaterialSumAggregateOutputType = {
    vendorCost: Decimal | null
    freight: Decimal | null
    rlBasePrice: Decimal | null
  }

  export type MaterialMinAggregateOutputType = {
    id: string | null
    sku: string | null
    description: string | null
    category: $Enums.MaterialCategory | null
    subcategory: string | null
    unitOfMeasure: string | null
    vendorCost: Decimal | null
    freight: Decimal | null
    isRLLinked: boolean | null
    rlTag: string | null
    rlBasePrice: Decimal | null
    rlLastUpdated: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    vendorId: string | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    description: string | null
    category: $Enums.MaterialCategory | null
    subcategory: string | null
    unitOfMeasure: string | null
    vendorCost: Decimal | null
    freight: Decimal | null
    isRLLinked: boolean | null
    rlTag: string | null
    rlBasePrice: Decimal | null
    rlLastUpdated: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    vendorId: string | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    sku: number
    description: number
    category: number
    subcategory: number
    unitOfMeasure: number
    vendorCost: number
    freight: number
    isRLLinked: number
    rlTag: number
    rlBasePrice: number
    rlLastUpdated: number
    lengthAdders: number
    gradeMultipliers: number
    isActive: number
    createdAt: number
    updatedAt: number
    vendorId: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    vendorCost?: true
    freight?: true
    rlBasePrice?: true
  }

  export type MaterialSumAggregateInputType = {
    vendorCost?: true
    freight?: true
    rlBasePrice?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    sku?: true
    description?: true
    category?: true
    subcategory?: true
    unitOfMeasure?: true
    vendorCost?: true
    freight?: true
    isRLLinked?: true
    rlTag?: true
    rlBasePrice?: true
    rlLastUpdated?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    vendorId?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    sku?: true
    description?: true
    category?: true
    subcategory?: true
    unitOfMeasure?: true
    vendorCost?: true
    freight?: true
    isRLLinked?: true
    rlTag?: true
    rlBasePrice?: true
    rlLastUpdated?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    vendorId?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    sku?: true
    description?: true
    category?: true
    subcategory?: true
    unitOfMeasure?: true
    vendorCost?: true
    freight?: true
    isRLLinked?: true
    rlTag?: true
    rlBasePrice?: true
    rlLastUpdated?: true
    lengthAdders?: true
    gradeMultipliers?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    vendorId?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory: string | null
    unitOfMeasure: string
    vendorCost: Decimal
    freight: Decimal
    isRLLinked: boolean
    rlTag: string | null
    rlBasePrice: Decimal | null
    rlLastUpdated: Date | null
    lengthAdders: JsonValue | null
    gradeMultipliers: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    vendorId: string | null
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    description?: boolean
    category?: boolean
    subcategory?: boolean
    unitOfMeasure?: boolean
    vendorCost?: boolean
    freight?: boolean
    isRLLinked?: boolean
    rlTag?: boolean
    rlBasePrice?: boolean
    rlLastUpdated?: boolean
    lengthAdders?: boolean
    gradeMultipliers?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorId?: boolean
    vendor?: boolean | Material$vendorArgs<ExtArgs>
    pricingHistory?: boolean | Material$pricingHistoryArgs<ExtArgs>
    templateItems?: boolean | Material$templateItemsArgs<ExtArgs>
    customerPricing?: boolean | Material$customerPricingArgs<ExtArgs>
    takeoffLineItems?: boolean | Material$takeoffLineItemsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    description?: boolean
    category?: boolean
    subcategory?: boolean
    unitOfMeasure?: boolean
    vendorCost?: boolean
    freight?: boolean
    isRLLinked?: boolean
    rlTag?: boolean
    rlBasePrice?: boolean
    rlLastUpdated?: boolean
    lengthAdders?: boolean
    gradeMultipliers?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorId?: boolean
    vendor?: boolean | Material$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    description?: boolean
    category?: boolean
    subcategory?: boolean
    unitOfMeasure?: boolean
    vendorCost?: boolean
    freight?: boolean
    isRLLinked?: boolean
    rlTag?: boolean
    rlBasePrice?: boolean
    rlLastUpdated?: boolean
    lengthAdders?: boolean
    gradeMultipliers?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorId?: boolean
    vendor?: boolean | Material$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    sku?: boolean
    description?: boolean
    category?: boolean
    subcategory?: boolean
    unitOfMeasure?: boolean
    vendorCost?: boolean
    freight?: boolean
    isRLLinked?: boolean
    rlTag?: boolean
    rlBasePrice?: boolean
    rlLastUpdated?: boolean
    lengthAdders?: boolean
    gradeMultipliers?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorId?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "description" | "category" | "subcategory" | "unitOfMeasure" | "vendorCost" | "freight" | "isRLLinked" | "rlTag" | "rlBasePrice" | "rlLastUpdated" | "lengthAdders" | "gradeMultipliers" | "isActive" | "createdAt" | "updatedAt" | "vendorId", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | Material$vendorArgs<ExtArgs>
    pricingHistory?: boolean | Material$pricingHistoryArgs<ExtArgs>
    templateItems?: boolean | Material$templateItemsArgs<ExtArgs>
    customerPricing?: boolean | Material$customerPricingArgs<ExtArgs>
    takeoffLineItems?: boolean | Material$takeoffLineItemsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | Material$vendorArgs<ExtArgs>
  }
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | Material$vendorArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs> | null
      pricingHistory: Prisma.$PricingHistoryPayload<ExtArgs>[]
      templateItems: Prisma.$PlanTemplateItemPayload<ExtArgs>[]
      customerPricing: Prisma.$CustomerPricingPayload<ExtArgs>[]
      takeoffLineItems: Prisma.$TakeoffLineItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      description: string
      category: $Enums.MaterialCategory
      subcategory: string | null
      unitOfMeasure: string
      vendorCost: Prisma.Decimal
      freight: Prisma.Decimal
      isRLLinked: boolean
      rlTag: string | null
      rlBasePrice: Prisma.Decimal | null
      rlLastUpdated: Date | null
      lengthAdders: Prisma.JsonValue | null
      gradeMultipliers: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      vendorId: string | null
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends Material$vendorArgs<ExtArgs> = {}>(args?: Subset<T, Material$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pricingHistory<T extends Material$pricingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Material$pricingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    templateItems<T extends Material$templateItemsArgs<ExtArgs> = {}>(args?: Subset<T, Material$templateItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanTemplateItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerPricing<T extends Material$customerPricingArgs<ExtArgs> = {}>(args?: Subset<T, Material$customerPricingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    takeoffLineItems<T extends Material$takeoffLineItemsArgs<ExtArgs> = {}>(args?: Subset<T, Material$takeoffLineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'String'>
    readonly sku: FieldRef<"Material", 'String'>
    readonly description: FieldRef<"Material", 'String'>
    readonly category: FieldRef<"Material", 'MaterialCategory'>
    readonly subcategory: FieldRef<"Material", 'String'>
    readonly unitOfMeasure: FieldRef<"Material", 'String'>
    readonly vendorCost: FieldRef<"Material", 'Decimal'>
    readonly freight: FieldRef<"Material", 'Decimal'>
    readonly isRLLinked: FieldRef<"Material", 'Boolean'>
    readonly rlTag: FieldRef<"Material", 'String'>
    readonly rlBasePrice: FieldRef<"Material", 'Decimal'>
    readonly rlLastUpdated: FieldRef<"Material", 'DateTime'>
    readonly lengthAdders: FieldRef<"Material", 'Json'>
    readonly gradeMultipliers: FieldRef<"Material", 'Json'>
    readonly isActive: FieldRef<"Material", 'Boolean'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly updatedAt: FieldRef<"Material", 'DateTime'>
    readonly vendorId: FieldRef<"Material", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material.vendor
   */
  export type Material$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * Material.pricingHistory
   */
  export type Material$pricingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    where?: PricingHistoryWhereInput
    orderBy?: PricingHistoryOrderByWithRelationInput | PricingHistoryOrderByWithRelationInput[]
    cursor?: PricingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PricingHistoryScalarFieldEnum | PricingHistoryScalarFieldEnum[]
  }

  /**
   * Material.templateItems
   */
  export type Material$templateItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTemplateItem
     */
    select?: PlanTemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTemplateItem
     */
    omit?: PlanTemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanTemplateItemInclude<ExtArgs> | null
    where?: PlanTemplateItemWhereInput
    orderBy?: PlanTemplateItemOrderByWithRelationInput | PlanTemplateItemOrderByWithRelationInput[]
    cursor?: PlanTemplateItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanTemplateItemScalarFieldEnum | PlanTemplateItemScalarFieldEnum[]
  }

  /**
   * Material.customerPricing
   */
  export type Material$customerPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricing
     */
    select?: CustomerPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricing
     */
    omit?: CustomerPricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingInclude<ExtArgs> | null
    where?: CustomerPricingWhereInput
    orderBy?: CustomerPricingOrderByWithRelationInput | CustomerPricingOrderByWithRelationInput[]
    cursor?: CustomerPricingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPricingScalarFieldEnum | CustomerPricingScalarFieldEnum[]
  }

  /**
   * Material.takeoffLineItems
   */
  export type Material$takeoffLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    where?: TakeoffLineItemWhereInput
    orderBy?: TakeoffLineItemOrderByWithRelationInput | TakeoffLineItemOrderByWithRelationInput[]
    cursor?: TakeoffLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TakeoffLineItemScalarFieldEnum | TakeoffLineItemScalarFieldEnum[]
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    leadTimeDays: number | null
  }

  export type VendorSumAggregateOutputType = {
    leadTimeDays: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    primaryContact: string | null
    email: string | null
    phone: string | null
    paymentTerms: string | null
    leadTimeDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    primaryContact: string | null
    email: string | null
    phone: string | null
    paymentTerms: string | null
    leadTimeDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    code: number
    primaryContact: number
    email: number
    phone: number
    paymentTerms: number
    leadTimeDays: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    leadTimeDays?: true
  }

  export type VendorSumAggregateInputType = {
    leadTimeDays?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    primaryContact?: true
    email?: true
    phone?: true
    paymentTerms?: true
    leadTimeDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    primaryContact?: true
    email?: true
    phone?: true
    paymentTerms?: true
    leadTimeDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    primaryContact?: true
    email?: true
    phone?: true
    paymentTerms?: true
    leadTimeDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    name: string
    code: string
    primaryContact: string | null
    email: string | null
    phone: string | null
    paymentTerms: string | null
    leadTimeDays: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    primaryContact?: boolean
    email?: boolean
    phone?: boolean
    paymentTerms?: boolean
    leadTimeDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materials?: boolean | Vendor$materialsArgs<ExtArgs>
    purchaseOrders?: boolean | Vendor$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    primaryContact?: boolean
    email?: boolean
    phone?: boolean
    paymentTerms?: boolean
    leadTimeDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    primaryContact?: boolean
    email?: boolean
    phone?: boolean
    paymentTerms?: boolean
    leadTimeDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    primaryContact?: boolean
    email?: boolean
    phone?: boolean
    paymentTerms?: boolean
    leadTimeDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "primaryContact" | "email" | "phone" | "paymentTerms" | "leadTimeDays" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | Vendor$materialsArgs<ExtArgs>
    purchaseOrders?: boolean | Vendor$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VendorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      primaryContact: string | null
      email: string | null
      phone: string | null
      paymentTerms: string | null
      leadTimeDays: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors and returns the data updated in the database.
     * @param {VendorUpdateManyAndReturnArgs} args - Arguments to update many Vendors.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materials<T extends Vendor$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Vendor$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly code: FieldRef<"Vendor", 'String'>
    readonly primaryContact: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly paymentTerms: FieldRef<"Vendor", 'String'>
    readonly leadTimeDays: FieldRef<"Vendor", 'Int'>
    readonly isActive: FieldRef<"Vendor", 'Boolean'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor updateManyAndReturn
   */
  export type VendorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.materials
   */
  export type Vendor$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Vendor.purchaseOrders
   */
  export type Vendor$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model PricingHistory
   */

  export type AggregatePricingHistory = {
    _count: PricingHistoryCountAggregateOutputType | null
    _avg: PricingHistoryAvgAggregateOutputType | null
    _sum: PricingHistorySumAggregateOutputType | null
    _min: PricingHistoryMinAggregateOutputType | null
    _max: PricingHistoryMaxAggregateOutputType | null
  }

  export type PricingHistoryAvgAggregateOutputType = {
    baseVendorCost: Decimal | null
    commodityAdjustment: Decimal | null
    freight: Decimal | null
    totalCost: Decimal | null
    marginPercentage: Decimal | null
    marginAmount: Decimal | null
    unitPrice: Decimal | null
  }

  export type PricingHistorySumAggregateOutputType = {
    baseVendorCost: Decimal | null
    commodityAdjustment: Decimal | null
    freight: Decimal | null
    totalCost: Decimal | null
    marginPercentage: Decimal | null
    marginAmount: Decimal | null
    unitPrice: Decimal | null
  }

  export type PricingHistoryMinAggregateOutputType = {
    id: string | null
    materialId: string | null
    baseVendorCost: Decimal | null
    commodityAdjustment: Decimal | null
    freight: Decimal | null
    totalCost: Decimal | null
    marginPercentage: Decimal | null
    marginAmount: Decimal | null
    unitPrice: Decimal | null
    effectiveDate: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PricingHistoryMaxAggregateOutputType = {
    id: string | null
    materialId: string | null
    baseVendorCost: Decimal | null
    commodityAdjustment: Decimal | null
    freight: Decimal | null
    totalCost: Decimal | null
    marginPercentage: Decimal | null
    marginAmount: Decimal | null
    unitPrice: Decimal | null
    effectiveDate: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PricingHistoryCountAggregateOutputType = {
    id: number
    materialId: number
    baseVendorCost: number
    commodityAdjustment: number
    freight: number
    totalCost: number
    marginPercentage: number
    marginAmount: number
    unitPrice: number
    calculationSteps: number
    effectiveDate: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type PricingHistoryAvgAggregateInputType = {
    baseVendorCost?: true
    commodityAdjustment?: true
    freight?: true
    totalCost?: true
    marginPercentage?: true
    marginAmount?: true
    unitPrice?: true
  }

  export type PricingHistorySumAggregateInputType = {
    baseVendorCost?: true
    commodityAdjustment?: true
    freight?: true
    totalCost?: true
    marginPercentage?: true
    marginAmount?: true
    unitPrice?: true
  }

  export type PricingHistoryMinAggregateInputType = {
    id?: true
    materialId?: true
    baseVendorCost?: true
    commodityAdjustment?: true
    freight?: true
    totalCost?: true
    marginPercentage?: true
    marginAmount?: true
    unitPrice?: true
    effectiveDate?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PricingHistoryMaxAggregateInputType = {
    id?: true
    materialId?: true
    baseVendorCost?: true
    commodityAdjustment?: true
    freight?: true
    totalCost?: true
    marginPercentage?: true
    marginAmount?: true
    unitPrice?: true
    effectiveDate?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PricingHistoryCountAggregateInputType = {
    id?: true
    materialId?: true
    baseVendorCost?: true
    commodityAdjustment?: true
    freight?: true
    totalCost?: true
    marginPercentage?: true
    marginAmount?: true
    unitPrice?: true
    calculationSteps?: true
    effectiveDate?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type PricingHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingHistory to aggregate.
     */
    where?: PricingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingHistories to fetch.
     */
    orderBy?: PricingHistoryOrderByWithRelationInput | PricingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PricingHistories
    **/
    _count?: true | PricingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingHistoryMaxAggregateInputType
  }

  export type GetPricingHistoryAggregateType<T extends PricingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingHistory[P]>
      : GetScalarType<T[P], AggregatePricingHistory[P]>
  }




  export type PricingHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingHistoryWhereInput
    orderBy?: PricingHistoryOrderByWithAggregationInput | PricingHistoryOrderByWithAggregationInput[]
    by: PricingHistoryScalarFieldEnum[] | PricingHistoryScalarFieldEnum
    having?: PricingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingHistoryCountAggregateInputType | true
    _avg?: PricingHistoryAvgAggregateInputType
    _sum?: PricingHistorySumAggregateInputType
    _min?: PricingHistoryMinAggregateInputType
    _max?: PricingHistoryMaxAggregateInputType
  }

  export type PricingHistoryGroupByOutputType = {
    id: string
    materialId: string
    baseVendorCost: Decimal
    commodityAdjustment: Decimal
    freight: Decimal
    totalCost: Decimal
    marginPercentage: Decimal
    marginAmount: Decimal
    unitPrice: Decimal
    calculationSteps: JsonValue
    effectiveDate: Date
    expiresAt: Date | null
    createdAt: Date
    _count: PricingHistoryCountAggregateOutputType | null
    _avg: PricingHistoryAvgAggregateOutputType | null
    _sum: PricingHistorySumAggregateOutputType | null
    _min: PricingHistoryMinAggregateOutputType | null
    _max: PricingHistoryMaxAggregateOutputType | null
  }

  type GetPricingHistoryGroupByPayload<T extends PricingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PricingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PricingHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    baseVendorCost?: boolean
    commodityAdjustment?: boolean
    freight?: boolean
    totalCost?: boolean
    marginPercentage?: boolean
    marginAmount?: boolean
    unitPrice?: boolean
    calculationSteps?: boolean
    effectiveDate?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingHistory"]>

  export type PricingHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    baseVendorCost?: boolean
    commodityAdjustment?: boolean
    freight?: boolean
    totalCost?: boolean
    marginPercentage?: boolean
    marginAmount?: boolean
    unitPrice?: boolean
    calculationSteps?: boolean
    effectiveDate?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingHistory"]>

  export type PricingHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    baseVendorCost?: boolean
    commodityAdjustment?: boolean
    freight?: boolean
    totalCost?: boolean
    marginPercentage?: boolean
    marginAmount?: boolean
    unitPrice?: boolean
    calculationSteps?: boolean
    effectiveDate?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingHistory"]>

  export type PricingHistorySelectScalar = {
    id?: boolean
    materialId?: boolean
    baseVendorCost?: boolean
    commodityAdjustment?: boolean
    freight?: boolean
    totalCost?: boolean
    marginPercentage?: boolean
    marginAmount?: boolean
    unitPrice?: boolean
    calculationSteps?: boolean
    effectiveDate?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type PricingHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materialId" | "baseVendorCost" | "commodityAdjustment" | "freight" | "totalCost" | "marginPercentage" | "marginAmount" | "unitPrice" | "calculationSteps" | "effectiveDate" | "expiresAt" | "createdAt", ExtArgs["result"]["pricingHistory"]>
  export type PricingHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type PricingHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type PricingHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $PricingHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PricingHistory"
    objects: {
      material: Prisma.$MaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      materialId: string
      baseVendorCost: Prisma.Decimal
      commodityAdjustment: Prisma.Decimal
      freight: Prisma.Decimal
      totalCost: Prisma.Decimal
      marginPercentage: Prisma.Decimal
      marginAmount: Prisma.Decimal
      unitPrice: Prisma.Decimal
      calculationSteps: Prisma.JsonValue
      effectiveDate: Date
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["pricingHistory"]>
    composites: {}
  }

  type PricingHistoryGetPayload<S extends boolean | null | undefined | PricingHistoryDefaultArgs> = $Result.GetResult<Prisma.$PricingHistoryPayload, S>

  type PricingHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PricingHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PricingHistoryCountAggregateInputType | true
    }

  export interface PricingHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PricingHistory'], meta: { name: 'PricingHistory' } }
    /**
     * Find zero or one PricingHistory that matches the filter.
     * @param {PricingHistoryFindUniqueArgs} args - Arguments to find a PricingHistory
     * @example
     * // Get one PricingHistory
     * const pricingHistory = await prisma.pricingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricingHistoryFindUniqueArgs>(args: SelectSubset<T, PricingHistoryFindUniqueArgs<ExtArgs>>): Prisma__PricingHistoryClient<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PricingHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PricingHistoryFindUniqueOrThrowArgs} args - Arguments to find a PricingHistory
     * @example
     * // Get one PricingHistory
     * const pricingHistory = await prisma.pricingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricingHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PricingHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricingHistoryClient<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingHistoryFindFirstArgs} args - Arguments to find a PricingHistory
     * @example
     * // Get one PricingHistory
     * const pricingHistory = await prisma.pricingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricingHistoryFindFirstArgs>(args?: SelectSubset<T, PricingHistoryFindFirstArgs<ExtArgs>>): Prisma__PricingHistoryClient<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingHistoryFindFirstOrThrowArgs} args - Arguments to find a PricingHistory
     * @example
     * // Get one PricingHistory
     * const pricingHistory = await prisma.pricingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricingHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PricingHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricingHistoryClient<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PricingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingHistories
     * const pricingHistories = await prisma.pricingHistory.findMany()
     * 
     * // Get first 10 PricingHistories
     * const pricingHistories = await prisma.pricingHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingHistoryWithIdOnly = await prisma.pricingHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PricingHistoryFindManyArgs>(args?: SelectSubset<T, PricingHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PricingHistory.
     * @param {PricingHistoryCreateArgs} args - Arguments to create a PricingHistory.
     * @example
     * // Create one PricingHistory
     * const PricingHistory = await prisma.pricingHistory.create({
     *   data: {
     *     // ... data to create a PricingHistory
     *   }
     * })
     * 
     */
    create<T extends PricingHistoryCreateArgs>(args: SelectSubset<T, PricingHistoryCreateArgs<ExtArgs>>): Prisma__PricingHistoryClient<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PricingHistories.
     * @param {PricingHistoryCreateManyArgs} args - Arguments to create many PricingHistories.
     * @example
     * // Create many PricingHistories
     * const pricingHistory = await prisma.pricingHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricingHistoryCreateManyArgs>(args?: SelectSubset<T, PricingHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PricingHistories and returns the data saved in the database.
     * @param {PricingHistoryCreateManyAndReturnArgs} args - Arguments to create many PricingHistories.
     * @example
     * // Create many PricingHistories
     * const pricingHistory = await prisma.pricingHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PricingHistories and only return the `id`
     * const pricingHistoryWithIdOnly = await prisma.pricingHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PricingHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PricingHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PricingHistory.
     * @param {PricingHistoryDeleteArgs} args - Arguments to delete one PricingHistory.
     * @example
     * // Delete one PricingHistory
     * const PricingHistory = await prisma.pricingHistory.delete({
     *   where: {
     *     // ... filter to delete one PricingHistory
     *   }
     * })
     * 
     */
    delete<T extends PricingHistoryDeleteArgs>(args: SelectSubset<T, PricingHistoryDeleteArgs<ExtArgs>>): Prisma__PricingHistoryClient<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PricingHistory.
     * @param {PricingHistoryUpdateArgs} args - Arguments to update one PricingHistory.
     * @example
     * // Update one PricingHistory
     * const pricingHistory = await prisma.pricingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricingHistoryUpdateArgs>(args: SelectSubset<T, PricingHistoryUpdateArgs<ExtArgs>>): Prisma__PricingHistoryClient<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PricingHistories.
     * @param {PricingHistoryDeleteManyArgs} args - Arguments to filter PricingHistories to delete.
     * @example
     * // Delete a few PricingHistories
     * const { count } = await prisma.pricingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricingHistoryDeleteManyArgs>(args?: SelectSubset<T, PricingHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingHistories
     * const pricingHistory = await prisma.pricingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricingHistoryUpdateManyArgs>(args: SelectSubset<T, PricingHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingHistories and returns the data updated in the database.
     * @param {PricingHistoryUpdateManyAndReturnArgs} args - Arguments to update many PricingHistories.
     * @example
     * // Update many PricingHistories
     * const pricingHistory = await prisma.pricingHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PricingHistories and only return the `id`
     * const pricingHistoryWithIdOnly = await prisma.pricingHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PricingHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PricingHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PricingHistory.
     * @param {PricingHistoryUpsertArgs} args - Arguments to update or create a PricingHistory.
     * @example
     * // Update or create a PricingHistory
     * const pricingHistory = await prisma.pricingHistory.upsert({
     *   create: {
     *     // ... data to create a PricingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingHistory we want to update
     *   }
     * })
     */
    upsert<T extends PricingHistoryUpsertArgs>(args: SelectSubset<T, PricingHistoryUpsertArgs<ExtArgs>>): Prisma__PricingHistoryClient<$Result.GetResult<Prisma.$PricingHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PricingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingHistoryCountArgs} args - Arguments to filter PricingHistories to count.
     * @example
     * // Count the number of PricingHistories
     * const count = await prisma.pricingHistory.count({
     *   where: {
     *     // ... the filter for the PricingHistories we want to count
     *   }
     * })
    **/
    count<T extends PricingHistoryCountArgs>(
      args?: Subset<T, PricingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingHistoryAggregateArgs>(args: Subset<T, PricingHistoryAggregateArgs>): Prisma.PrismaPromise<GetPricingHistoryAggregateType<T>>

    /**
     * Group by PricingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PricingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PricingHistory model
   */
  readonly fields: PricingHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PricingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricingHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PricingHistory model
   */
  interface PricingHistoryFieldRefs {
    readonly id: FieldRef<"PricingHistory", 'String'>
    readonly materialId: FieldRef<"PricingHistory", 'String'>
    readonly baseVendorCost: FieldRef<"PricingHistory", 'Decimal'>
    readonly commodityAdjustment: FieldRef<"PricingHistory", 'Decimal'>
    readonly freight: FieldRef<"PricingHistory", 'Decimal'>
    readonly totalCost: FieldRef<"PricingHistory", 'Decimal'>
    readonly marginPercentage: FieldRef<"PricingHistory", 'Decimal'>
    readonly marginAmount: FieldRef<"PricingHistory", 'Decimal'>
    readonly unitPrice: FieldRef<"PricingHistory", 'Decimal'>
    readonly calculationSteps: FieldRef<"PricingHistory", 'Json'>
    readonly effectiveDate: FieldRef<"PricingHistory", 'DateTime'>
    readonly expiresAt: FieldRef<"PricingHistory", 'DateTime'>
    readonly createdAt: FieldRef<"PricingHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PricingHistory findUnique
   */
  export type PricingHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PricingHistory to fetch.
     */
    where: PricingHistoryWhereUniqueInput
  }

  /**
   * PricingHistory findUniqueOrThrow
   */
  export type PricingHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PricingHistory to fetch.
     */
    where: PricingHistoryWhereUniqueInput
  }

  /**
   * PricingHistory findFirst
   */
  export type PricingHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PricingHistory to fetch.
     */
    where?: PricingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingHistories to fetch.
     */
    orderBy?: PricingHistoryOrderByWithRelationInput | PricingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingHistories.
     */
    cursor?: PricingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingHistories.
     */
    distinct?: PricingHistoryScalarFieldEnum | PricingHistoryScalarFieldEnum[]
  }

  /**
   * PricingHistory findFirstOrThrow
   */
  export type PricingHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PricingHistory to fetch.
     */
    where?: PricingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingHistories to fetch.
     */
    orderBy?: PricingHistoryOrderByWithRelationInput | PricingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingHistories.
     */
    cursor?: PricingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingHistories.
     */
    distinct?: PricingHistoryScalarFieldEnum | PricingHistoryScalarFieldEnum[]
  }

  /**
   * PricingHistory findMany
   */
  export type PricingHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PricingHistories to fetch.
     */
    where?: PricingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingHistories to fetch.
     */
    orderBy?: PricingHistoryOrderByWithRelationInput | PricingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PricingHistories.
     */
    cursor?: PricingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingHistories.
     */
    skip?: number
    distinct?: PricingHistoryScalarFieldEnum | PricingHistoryScalarFieldEnum[]
  }

  /**
   * PricingHistory create
   */
  export type PricingHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PricingHistory.
     */
    data: XOR<PricingHistoryCreateInput, PricingHistoryUncheckedCreateInput>
  }

  /**
   * PricingHistory createMany
   */
  export type PricingHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PricingHistories.
     */
    data: PricingHistoryCreateManyInput | PricingHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricingHistory createManyAndReturn
   */
  export type PricingHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PricingHistories.
     */
    data: PricingHistoryCreateManyInput | PricingHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PricingHistory update
   */
  export type PricingHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PricingHistory.
     */
    data: XOR<PricingHistoryUpdateInput, PricingHistoryUncheckedUpdateInput>
    /**
     * Choose, which PricingHistory to update.
     */
    where: PricingHistoryWhereUniqueInput
  }

  /**
   * PricingHistory updateMany
   */
  export type PricingHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PricingHistories.
     */
    data: XOR<PricingHistoryUpdateManyMutationInput, PricingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PricingHistories to update
     */
    where?: PricingHistoryWhereInput
    /**
     * Limit how many PricingHistories to update.
     */
    limit?: number
  }

  /**
   * PricingHistory updateManyAndReturn
   */
  export type PricingHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PricingHistories.
     */
    data: XOR<PricingHistoryUpdateManyMutationInput, PricingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PricingHistories to update
     */
    where?: PricingHistoryWhereInput
    /**
     * Limit how many PricingHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PricingHistory upsert
   */
  export type PricingHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PricingHistory to update in case it exists.
     */
    where: PricingHistoryWhereUniqueInput
    /**
     * In case the PricingHistory found by the `where` argument doesn't exist, create a new PricingHistory with this data.
     */
    create: XOR<PricingHistoryCreateInput, PricingHistoryUncheckedCreateInput>
    /**
     * In case the PricingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricingHistoryUpdateInput, PricingHistoryUncheckedUpdateInput>
  }

  /**
   * PricingHistory delete
   */
  export type PricingHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
    /**
     * Filter which PricingHistory to delete.
     */
    where: PricingHistoryWhereUniqueInput
  }

  /**
   * PricingHistory deleteMany
   */
  export type PricingHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingHistories to delete
     */
    where?: PricingHistoryWhereInput
    /**
     * Limit how many PricingHistories to delete.
     */
    limit?: number
  }

  /**
   * PricingHistory without action
   */
  export type PricingHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingHistory
     */
    select?: PricingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingHistory
     */
    omit?: PricingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingHistoryInclude<ExtArgs> | null
  }


  /**
   * Model RandomLengthsPricing
   */

  export type AggregateRandomLengthsPricing = {
    _count: RandomLengthsPricingCountAggregateOutputType | null
    _avg: RandomLengthsPricingAvgAggregateOutputType | null
    _sum: RandomLengthsPricingSumAggregateOutputType | null
    _min: RandomLengthsPricingMinAggregateOutputType | null
    _max: RandomLengthsPricingMaxAggregateOutputType | null
  }

  export type RandomLengthsPricingAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type RandomLengthsPricingSumAggregateOutputType = {
    price: Decimal | null
  }

  export type RandomLengthsPricingMinAggregateOutputType = {
    id: string | null
    tag: string | null
    description: string | null
    price: Decimal | null
    unit: string | null
    region: string | null
    grade: string | null
    effectiveDate: Date | null
    source: string | null
    createdAt: Date | null
  }

  export type RandomLengthsPricingMaxAggregateOutputType = {
    id: string | null
    tag: string | null
    description: string | null
    price: Decimal | null
    unit: string | null
    region: string | null
    grade: string | null
    effectiveDate: Date | null
    source: string | null
    createdAt: Date | null
  }

  export type RandomLengthsPricingCountAggregateOutputType = {
    id: number
    tag: number
    description: number
    price: number
    unit: number
    region: number
    grade: number
    effectiveDate: number
    source: number
    createdAt: number
    _all: number
  }


  export type RandomLengthsPricingAvgAggregateInputType = {
    price?: true
  }

  export type RandomLengthsPricingSumAggregateInputType = {
    price?: true
  }

  export type RandomLengthsPricingMinAggregateInputType = {
    id?: true
    tag?: true
    description?: true
    price?: true
    unit?: true
    region?: true
    grade?: true
    effectiveDate?: true
    source?: true
    createdAt?: true
  }

  export type RandomLengthsPricingMaxAggregateInputType = {
    id?: true
    tag?: true
    description?: true
    price?: true
    unit?: true
    region?: true
    grade?: true
    effectiveDate?: true
    source?: true
    createdAt?: true
  }

  export type RandomLengthsPricingCountAggregateInputType = {
    id?: true
    tag?: true
    description?: true
    price?: true
    unit?: true
    region?: true
    grade?: true
    effectiveDate?: true
    source?: true
    createdAt?: true
    _all?: true
  }

  export type RandomLengthsPricingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RandomLengthsPricing to aggregate.
     */
    where?: RandomLengthsPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RandomLengthsPricings to fetch.
     */
    orderBy?: RandomLengthsPricingOrderByWithRelationInput | RandomLengthsPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RandomLengthsPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RandomLengthsPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RandomLengthsPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RandomLengthsPricings
    **/
    _count?: true | RandomLengthsPricingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RandomLengthsPricingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RandomLengthsPricingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RandomLengthsPricingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RandomLengthsPricingMaxAggregateInputType
  }

  export type GetRandomLengthsPricingAggregateType<T extends RandomLengthsPricingAggregateArgs> = {
        [P in keyof T & keyof AggregateRandomLengthsPricing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRandomLengthsPricing[P]>
      : GetScalarType<T[P], AggregateRandomLengthsPricing[P]>
  }




  export type RandomLengthsPricingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RandomLengthsPricingWhereInput
    orderBy?: RandomLengthsPricingOrderByWithAggregationInput | RandomLengthsPricingOrderByWithAggregationInput[]
    by: RandomLengthsPricingScalarFieldEnum[] | RandomLengthsPricingScalarFieldEnum
    having?: RandomLengthsPricingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RandomLengthsPricingCountAggregateInputType | true
    _avg?: RandomLengthsPricingAvgAggregateInputType
    _sum?: RandomLengthsPricingSumAggregateInputType
    _min?: RandomLengthsPricingMinAggregateInputType
    _max?: RandomLengthsPricingMaxAggregateInputType
  }

  export type RandomLengthsPricingGroupByOutputType = {
    id: string
    tag: string
    description: string
    price: Decimal
    unit: string
    region: string | null
    grade: string | null
    effectiveDate: Date
    source: string
    createdAt: Date
    _count: RandomLengthsPricingCountAggregateOutputType | null
    _avg: RandomLengthsPricingAvgAggregateOutputType | null
    _sum: RandomLengthsPricingSumAggregateOutputType | null
    _min: RandomLengthsPricingMinAggregateOutputType | null
    _max: RandomLengthsPricingMaxAggregateOutputType | null
  }

  type GetRandomLengthsPricingGroupByPayload<T extends RandomLengthsPricingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RandomLengthsPricingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RandomLengthsPricingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RandomLengthsPricingGroupByOutputType[P]>
            : GetScalarType<T[P], RandomLengthsPricingGroupByOutputType[P]>
        }
      >
    >


  export type RandomLengthsPricingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    description?: boolean
    price?: boolean
    unit?: boolean
    region?: boolean
    grade?: boolean
    effectiveDate?: boolean
    source?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["randomLengthsPricing"]>

  export type RandomLengthsPricingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    description?: boolean
    price?: boolean
    unit?: boolean
    region?: boolean
    grade?: boolean
    effectiveDate?: boolean
    source?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["randomLengthsPricing"]>

  export type RandomLengthsPricingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    description?: boolean
    price?: boolean
    unit?: boolean
    region?: boolean
    grade?: boolean
    effectiveDate?: boolean
    source?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["randomLengthsPricing"]>

  export type RandomLengthsPricingSelectScalar = {
    id?: boolean
    tag?: boolean
    description?: boolean
    price?: boolean
    unit?: boolean
    region?: boolean
    grade?: boolean
    effectiveDate?: boolean
    source?: boolean
    createdAt?: boolean
  }

  export type RandomLengthsPricingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag" | "description" | "price" | "unit" | "region" | "grade" | "effectiveDate" | "source" | "createdAt", ExtArgs["result"]["randomLengthsPricing"]>

  export type $RandomLengthsPricingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RandomLengthsPricing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag: string
      description: string
      price: Prisma.Decimal
      unit: string
      region: string | null
      grade: string | null
      effectiveDate: Date
      source: string
      createdAt: Date
    }, ExtArgs["result"]["randomLengthsPricing"]>
    composites: {}
  }

  type RandomLengthsPricingGetPayload<S extends boolean | null | undefined | RandomLengthsPricingDefaultArgs> = $Result.GetResult<Prisma.$RandomLengthsPricingPayload, S>

  type RandomLengthsPricingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RandomLengthsPricingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RandomLengthsPricingCountAggregateInputType | true
    }

  export interface RandomLengthsPricingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RandomLengthsPricing'], meta: { name: 'RandomLengthsPricing' } }
    /**
     * Find zero or one RandomLengthsPricing that matches the filter.
     * @param {RandomLengthsPricingFindUniqueArgs} args - Arguments to find a RandomLengthsPricing
     * @example
     * // Get one RandomLengthsPricing
     * const randomLengthsPricing = await prisma.randomLengthsPricing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RandomLengthsPricingFindUniqueArgs>(args: SelectSubset<T, RandomLengthsPricingFindUniqueArgs<ExtArgs>>): Prisma__RandomLengthsPricingClient<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RandomLengthsPricing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RandomLengthsPricingFindUniqueOrThrowArgs} args - Arguments to find a RandomLengthsPricing
     * @example
     * // Get one RandomLengthsPricing
     * const randomLengthsPricing = await prisma.randomLengthsPricing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RandomLengthsPricingFindUniqueOrThrowArgs>(args: SelectSubset<T, RandomLengthsPricingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RandomLengthsPricingClient<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RandomLengthsPricing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomLengthsPricingFindFirstArgs} args - Arguments to find a RandomLengthsPricing
     * @example
     * // Get one RandomLengthsPricing
     * const randomLengthsPricing = await prisma.randomLengthsPricing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RandomLengthsPricingFindFirstArgs>(args?: SelectSubset<T, RandomLengthsPricingFindFirstArgs<ExtArgs>>): Prisma__RandomLengthsPricingClient<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RandomLengthsPricing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomLengthsPricingFindFirstOrThrowArgs} args - Arguments to find a RandomLengthsPricing
     * @example
     * // Get one RandomLengthsPricing
     * const randomLengthsPricing = await prisma.randomLengthsPricing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RandomLengthsPricingFindFirstOrThrowArgs>(args?: SelectSubset<T, RandomLengthsPricingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RandomLengthsPricingClient<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RandomLengthsPricings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomLengthsPricingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RandomLengthsPricings
     * const randomLengthsPricings = await prisma.randomLengthsPricing.findMany()
     * 
     * // Get first 10 RandomLengthsPricings
     * const randomLengthsPricings = await prisma.randomLengthsPricing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const randomLengthsPricingWithIdOnly = await prisma.randomLengthsPricing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RandomLengthsPricingFindManyArgs>(args?: SelectSubset<T, RandomLengthsPricingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RandomLengthsPricing.
     * @param {RandomLengthsPricingCreateArgs} args - Arguments to create a RandomLengthsPricing.
     * @example
     * // Create one RandomLengthsPricing
     * const RandomLengthsPricing = await prisma.randomLengthsPricing.create({
     *   data: {
     *     // ... data to create a RandomLengthsPricing
     *   }
     * })
     * 
     */
    create<T extends RandomLengthsPricingCreateArgs>(args: SelectSubset<T, RandomLengthsPricingCreateArgs<ExtArgs>>): Prisma__RandomLengthsPricingClient<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RandomLengthsPricings.
     * @param {RandomLengthsPricingCreateManyArgs} args - Arguments to create many RandomLengthsPricings.
     * @example
     * // Create many RandomLengthsPricings
     * const randomLengthsPricing = await prisma.randomLengthsPricing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RandomLengthsPricingCreateManyArgs>(args?: SelectSubset<T, RandomLengthsPricingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RandomLengthsPricings and returns the data saved in the database.
     * @param {RandomLengthsPricingCreateManyAndReturnArgs} args - Arguments to create many RandomLengthsPricings.
     * @example
     * // Create many RandomLengthsPricings
     * const randomLengthsPricing = await prisma.randomLengthsPricing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RandomLengthsPricings and only return the `id`
     * const randomLengthsPricingWithIdOnly = await prisma.randomLengthsPricing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RandomLengthsPricingCreateManyAndReturnArgs>(args?: SelectSubset<T, RandomLengthsPricingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RandomLengthsPricing.
     * @param {RandomLengthsPricingDeleteArgs} args - Arguments to delete one RandomLengthsPricing.
     * @example
     * // Delete one RandomLengthsPricing
     * const RandomLengthsPricing = await prisma.randomLengthsPricing.delete({
     *   where: {
     *     // ... filter to delete one RandomLengthsPricing
     *   }
     * })
     * 
     */
    delete<T extends RandomLengthsPricingDeleteArgs>(args: SelectSubset<T, RandomLengthsPricingDeleteArgs<ExtArgs>>): Prisma__RandomLengthsPricingClient<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RandomLengthsPricing.
     * @param {RandomLengthsPricingUpdateArgs} args - Arguments to update one RandomLengthsPricing.
     * @example
     * // Update one RandomLengthsPricing
     * const randomLengthsPricing = await prisma.randomLengthsPricing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RandomLengthsPricingUpdateArgs>(args: SelectSubset<T, RandomLengthsPricingUpdateArgs<ExtArgs>>): Prisma__RandomLengthsPricingClient<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RandomLengthsPricings.
     * @param {RandomLengthsPricingDeleteManyArgs} args - Arguments to filter RandomLengthsPricings to delete.
     * @example
     * // Delete a few RandomLengthsPricings
     * const { count } = await prisma.randomLengthsPricing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RandomLengthsPricingDeleteManyArgs>(args?: SelectSubset<T, RandomLengthsPricingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RandomLengthsPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomLengthsPricingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RandomLengthsPricings
     * const randomLengthsPricing = await prisma.randomLengthsPricing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RandomLengthsPricingUpdateManyArgs>(args: SelectSubset<T, RandomLengthsPricingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RandomLengthsPricings and returns the data updated in the database.
     * @param {RandomLengthsPricingUpdateManyAndReturnArgs} args - Arguments to update many RandomLengthsPricings.
     * @example
     * // Update many RandomLengthsPricings
     * const randomLengthsPricing = await prisma.randomLengthsPricing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RandomLengthsPricings and only return the `id`
     * const randomLengthsPricingWithIdOnly = await prisma.randomLengthsPricing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RandomLengthsPricingUpdateManyAndReturnArgs>(args: SelectSubset<T, RandomLengthsPricingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RandomLengthsPricing.
     * @param {RandomLengthsPricingUpsertArgs} args - Arguments to update or create a RandomLengthsPricing.
     * @example
     * // Update or create a RandomLengthsPricing
     * const randomLengthsPricing = await prisma.randomLengthsPricing.upsert({
     *   create: {
     *     // ... data to create a RandomLengthsPricing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RandomLengthsPricing we want to update
     *   }
     * })
     */
    upsert<T extends RandomLengthsPricingUpsertArgs>(args: SelectSubset<T, RandomLengthsPricingUpsertArgs<ExtArgs>>): Prisma__RandomLengthsPricingClient<$Result.GetResult<Prisma.$RandomLengthsPricingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RandomLengthsPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomLengthsPricingCountArgs} args - Arguments to filter RandomLengthsPricings to count.
     * @example
     * // Count the number of RandomLengthsPricings
     * const count = await prisma.randomLengthsPricing.count({
     *   where: {
     *     // ... the filter for the RandomLengthsPricings we want to count
     *   }
     * })
    **/
    count<T extends RandomLengthsPricingCountArgs>(
      args?: Subset<T, RandomLengthsPricingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RandomLengthsPricingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RandomLengthsPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomLengthsPricingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RandomLengthsPricingAggregateArgs>(args: Subset<T, RandomLengthsPricingAggregateArgs>): Prisma.PrismaPromise<GetRandomLengthsPricingAggregateType<T>>

    /**
     * Group by RandomLengthsPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomLengthsPricingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RandomLengthsPricingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RandomLengthsPricingGroupByArgs['orderBy'] }
        : { orderBy?: RandomLengthsPricingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RandomLengthsPricingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRandomLengthsPricingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RandomLengthsPricing model
   */
  readonly fields: RandomLengthsPricingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RandomLengthsPricing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RandomLengthsPricingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RandomLengthsPricing model
   */
  interface RandomLengthsPricingFieldRefs {
    readonly id: FieldRef<"RandomLengthsPricing", 'String'>
    readonly tag: FieldRef<"RandomLengthsPricing", 'String'>
    readonly description: FieldRef<"RandomLengthsPricing", 'String'>
    readonly price: FieldRef<"RandomLengthsPricing", 'Decimal'>
    readonly unit: FieldRef<"RandomLengthsPricing", 'String'>
    readonly region: FieldRef<"RandomLengthsPricing", 'String'>
    readonly grade: FieldRef<"RandomLengthsPricing", 'String'>
    readonly effectiveDate: FieldRef<"RandomLengthsPricing", 'DateTime'>
    readonly source: FieldRef<"RandomLengthsPricing", 'String'>
    readonly createdAt: FieldRef<"RandomLengthsPricing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RandomLengthsPricing findUnique
   */
  export type RandomLengthsPricingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * Filter, which RandomLengthsPricing to fetch.
     */
    where: RandomLengthsPricingWhereUniqueInput
  }

  /**
   * RandomLengthsPricing findUniqueOrThrow
   */
  export type RandomLengthsPricingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * Filter, which RandomLengthsPricing to fetch.
     */
    where: RandomLengthsPricingWhereUniqueInput
  }

  /**
   * RandomLengthsPricing findFirst
   */
  export type RandomLengthsPricingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * Filter, which RandomLengthsPricing to fetch.
     */
    where?: RandomLengthsPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RandomLengthsPricings to fetch.
     */
    orderBy?: RandomLengthsPricingOrderByWithRelationInput | RandomLengthsPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RandomLengthsPricings.
     */
    cursor?: RandomLengthsPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RandomLengthsPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RandomLengthsPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RandomLengthsPricings.
     */
    distinct?: RandomLengthsPricingScalarFieldEnum | RandomLengthsPricingScalarFieldEnum[]
  }

  /**
   * RandomLengthsPricing findFirstOrThrow
   */
  export type RandomLengthsPricingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * Filter, which RandomLengthsPricing to fetch.
     */
    where?: RandomLengthsPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RandomLengthsPricings to fetch.
     */
    orderBy?: RandomLengthsPricingOrderByWithRelationInput | RandomLengthsPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RandomLengthsPricings.
     */
    cursor?: RandomLengthsPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RandomLengthsPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RandomLengthsPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RandomLengthsPricings.
     */
    distinct?: RandomLengthsPricingScalarFieldEnum | RandomLengthsPricingScalarFieldEnum[]
  }

  /**
   * RandomLengthsPricing findMany
   */
  export type RandomLengthsPricingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * Filter, which RandomLengthsPricings to fetch.
     */
    where?: RandomLengthsPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RandomLengthsPricings to fetch.
     */
    orderBy?: RandomLengthsPricingOrderByWithRelationInput | RandomLengthsPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RandomLengthsPricings.
     */
    cursor?: RandomLengthsPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RandomLengthsPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RandomLengthsPricings.
     */
    skip?: number
    distinct?: RandomLengthsPricingScalarFieldEnum | RandomLengthsPricingScalarFieldEnum[]
  }

  /**
   * RandomLengthsPricing create
   */
  export type RandomLengthsPricingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * The data needed to create a RandomLengthsPricing.
     */
    data: XOR<RandomLengthsPricingCreateInput, RandomLengthsPricingUncheckedCreateInput>
  }

  /**
   * RandomLengthsPricing createMany
   */
  export type RandomLengthsPricingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RandomLengthsPricings.
     */
    data: RandomLengthsPricingCreateManyInput | RandomLengthsPricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RandomLengthsPricing createManyAndReturn
   */
  export type RandomLengthsPricingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * The data used to create many RandomLengthsPricings.
     */
    data: RandomLengthsPricingCreateManyInput | RandomLengthsPricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RandomLengthsPricing update
   */
  export type RandomLengthsPricingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * The data needed to update a RandomLengthsPricing.
     */
    data: XOR<RandomLengthsPricingUpdateInput, RandomLengthsPricingUncheckedUpdateInput>
    /**
     * Choose, which RandomLengthsPricing to update.
     */
    where: RandomLengthsPricingWhereUniqueInput
  }

  /**
   * RandomLengthsPricing updateMany
   */
  export type RandomLengthsPricingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RandomLengthsPricings.
     */
    data: XOR<RandomLengthsPricingUpdateManyMutationInput, RandomLengthsPricingUncheckedUpdateManyInput>
    /**
     * Filter which RandomLengthsPricings to update
     */
    where?: RandomLengthsPricingWhereInput
    /**
     * Limit how many RandomLengthsPricings to update.
     */
    limit?: number
  }

  /**
   * RandomLengthsPricing updateManyAndReturn
   */
  export type RandomLengthsPricingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * The data used to update RandomLengthsPricings.
     */
    data: XOR<RandomLengthsPricingUpdateManyMutationInput, RandomLengthsPricingUncheckedUpdateManyInput>
    /**
     * Filter which RandomLengthsPricings to update
     */
    where?: RandomLengthsPricingWhereInput
    /**
     * Limit how many RandomLengthsPricings to update.
     */
    limit?: number
  }

  /**
   * RandomLengthsPricing upsert
   */
  export type RandomLengthsPricingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * The filter to search for the RandomLengthsPricing to update in case it exists.
     */
    where: RandomLengthsPricingWhereUniqueInput
    /**
     * In case the RandomLengthsPricing found by the `where` argument doesn't exist, create a new RandomLengthsPricing with this data.
     */
    create: XOR<RandomLengthsPricingCreateInput, RandomLengthsPricingUncheckedCreateInput>
    /**
     * In case the RandomLengthsPricing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RandomLengthsPricingUpdateInput, RandomLengthsPricingUncheckedUpdateInput>
  }

  /**
   * RandomLengthsPricing delete
   */
  export type RandomLengthsPricingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
    /**
     * Filter which RandomLengthsPricing to delete.
     */
    where: RandomLengthsPricingWhereUniqueInput
  }

  /**
   * RandomLengthsPricing deleteMany
   */
  export type RandomLengthsPricingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RandomLengthsPricings to delete
     */
    where?: RandomLengthsPricingWhereInput
    /**
     * Limit how many RandomLengthsPricings to delete.
     */
    limit?: number
  }

  /**
   * RandomLengthsPricing without action
   */
  export type RandomLengthsPricingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomLengthsPricing
     */
    select?: RandomLengthsPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RandomLengthsPricing
     */
    omit?: RandomLengthsPricingOmit<ExtArgs> | null
  }


  /**
   * Model Community
   */

  export type AggregateCommunity = {
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  export type CommunityAvgAggregateOutputType = {
    activePlans: number | null
  }

  export type CommunitySumAggregateOutputType = {
    activePlans: number | null
  }

  export type CommunityMinAggregateOutputType = {
    id: string | null
    name: string | null
    customerId: string | null
    shippingYard: string | null
    jurisdiction: string | null
    region: string | null
    activePlans: number | null
    isActive: boolean | null
    specialRequirements: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    customerId: string | null
    shippingYard: string | null
    jurisdiction: string | null
    region: string | null
    activePlans: number | null
    isActive: boolean | null
    specialRequirements: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityCountAggregateOutputType = {
    id: number
    name: number
    customerId: number
    shippingYard: number
    jurisdiction: number
    region: number
    activePlans: number
    isActive: number
    specialRequirements: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityAvgAggregateInputType = {
    activePlans?: true
  }

  export type CommunitySumAggregateInputType = {
    activePlans?: true
  }

  export type CommunityMinAggregateInputType = {
    id?: true
    name?: true
    customerId?: true
    shippingYard?: true
    jurisdiction?: true
    region?: true
    activePlans?: true
    isActive?: true
    specialRequirements?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityMaxAggregateInputType = {
    id?: true
    name?: true
    customerId?: true
    shippingYard?: true
    jurisdiction?: true
    region?: true
    activePlans?: true
    isActive?: true
    specialRequirements?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityCountAggregateInputType = {
    id?: true
    name?: true
    customerId?: true
    shippingYard?: true
    jurisdiction?: true
    region?: true
    activePlans?: true
    isActive?: true
    specialRequirements?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Community to aggregate.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communities
    **/
    _count?: true | CommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMaxAggregateInputType
  }

  export type GetCommunityAggregateType<T extends CommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity[P]>
      : GetScalarType<T[P], AggregateCommunity[P]>
  }




  export type CommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithAggregationInput | CommunityOrderByWithAggregationInput[]
    by: CommunityScalarFieldEnum[] | CommunityScalarFieldEnum
    having?: CommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCountAggregateInputType | true
    _avg?: CommunityAvgAggregateInputType
    _sum?: CommunitySumAggregateInputType
    _min?: CommunityMinAggregateInputType
    _max?: CommunityMaxAggregateInputType
  }

  export type CommunityGroupByOutputType = {
    id: string
    name: string
    customerId: string
    shippingYard: string
    jurisdiction: string | null
    region: string | null
    activePlans: number
    isActive: boolean
    specialRequirements: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  type GetCommunityGroupByPayload<T extends CommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupByOutputType[P]>
        }
      >
    >


  export type CommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    customerId?: boolean
    shippingYard?: boolean
    jurisdiction?: boolean
    region?: boolean
    activePlans?: boolean
    isActive?: boolean
    specialRequirements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    lots?: boolean | Community$lotsArgs<ExtArgs>
    jobs?: boolean | Community$jobsArgs<ExtArgs>
    variancePatterns?: boolean | Community$variancePatternsArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    customerId?: boolean
    shippingYard?: boolean
    jurisdiction?: boolean
    region?: boolean
    activePlans?: boolean
    isActive?: boolean
    specialRequirements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    customerId?: boolean
    shippingYard?: boolean
    jurisdiction?: boolean
    region?: boolean
    activePlans?: boolean
    isActive?: boolean
    specialRequirements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectScalar = {
    id?: boolean
    name?: boolean
    customerId?: boolean
    shippingYard?: boolean
    jurisdiction?: boolean
    region?: boolean
    activePlans?: boolean
    isActive?: boolean
    specialRequirements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "customerId" | "shippingYard" | "jurisdiction" | "region" | "activePlans" | "isActive" | "specialRequirements" | "createdAt" | "updatedAt", ExtArgs["result"]["community"]>
  export type CommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    lots?: boolean | Community$lotsArgs<ExtArgs>
    jobs?: boolean | Community$jobsArgs<ExtArgs>
    variancePatterns?: boolean | Community$variancePatternsArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CommunityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Community"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      lots: Prisma.$LotPayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
      variancePatterns: Prisma.$VariancePatternPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      customerId: string
      shippingYard: string
      jurisdiction: string | null
      region: string | null
      activePlans: number
      isActive: boolean
      specialRequirements: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["community"]>
    composites: {}
  }

  type CommunityGetPayload<S extends boolean | null | undefined | CommunityDefaultArgs> = $Result.GetResult<Prisma.$CommunityPayload, S>

  type CommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityCountAggregateInputType | true
    }

  export interface CommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Community'], meta: { name: 'Community' } }
    /**
     * Find zero or one Community that matches the filter.
     * @param {CommunityFindUniqueArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityFindUniqueArgs>(args: SelectSubset<T, CommunityFindUniqueArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Community that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityFindUniqueOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Community that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityFindFirstArgs>(args?: SelectSubset<T, CommunityFindFirstArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Community that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Communities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communities
     * const communities = await prisma.community.findMany()
     * 
     * // Get first 10 Communities
     * const communities = await prisma.community.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityWithIdOnly = await prisma.community.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityFindManyArgs>(args?: SelectSubset<T, CommunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Community.
     * @param {CommunityCreateArgs} args - Arguments to create a Community.
     * @example
     * // Create one Community
     * const Community = await prisma.community.create({
     *   data: {
     *     // ... data to create a Community
     *   }
     * })
     * 
     */
    create<T extends CommunityCreateArgs>(args: SelectSubset<T, CommunityCreateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Communities.
     * @param {CommunityCreateManyArgs} args - Arguments to create many Communities.
     * @example
     * // Create many Communities
     * const community = await prisma.community.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityCreateManyArgs>(args?: SelectSubset<T, CommunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Communities and returns the data saved in the database.
     * @param {CommunityCreateManyAndReturnArgs} args - Arguments to create many Communities.
     * @example
     * // Create many Communities
     * const community = await prisma.community.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Communities and only return the `id`
     * const communityWithIdOnly = await prisma.community.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Community.
     * @param {CommunityDeleteArgs} args - Arguments to delete one Community.
     * @example
     * // Delete one Community
     * const Community = await prisma.community.delete({
     *   where: {
     *     // ... filter to delete one Community
     *   }
     * })
     * 
     */
    delete<T extends CommunityDeleteArgs>(args: SelectSubset<T, CommunityDeleteArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Community.
     * @param {CommunityUpdateArgs} args - Arguments to update one Community.
     * @example
     * // Update one Community
     * const community = await prisma.community.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityUpdateArgs>(args: SelectSubset<T, CommunityUpdateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Communities.
     * @param {CommunityDeleteManyArgs} args - Arguments to filter Communities to delete.
     * @example
     * // Delete a few Communities
     * const { count } = await prisma.community.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityDeleteManyArgs>(args?: SelectSubset<T, CommunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityUpdateManyArgs>(args: SelectSubset<T, CommunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities and returns the data updated in the database.
     * @param {CommunityUpdateManyAndReturnArgs} args - Arguments to update many Communities.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Communities and only return the `id`
     * const communityWithIdOnly = await prisma.community.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunityUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Community.
     * @param {CommunityUpsertArgs} args - Arguments to update or create a Community.
     * @example
     * // Update or create a Community
     * const community = await prisma.community.upsert({
     *   create: {
     *     // ... data to create a Community
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community we want to update
     *   }
     * })
     */
    upsert<T extends CommunityUpsertArgs>(args: SelectSubset<T, CommunityUpsertArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCountArgs} args - Arguments to filter Communities to count.
     * @example
     * // Count the number of Communities
     * const count = await prisma.community.count({
     *   where: {
     *     // ... the filter for the Communities we want to count
     *   }
     * })
    **/
    count<T extends CommunityCountArgs>(
      args?: Subset<T, CommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityAggregateArgs>(args: Subset<T, CommunityAggregateArgs>): Prisma.PrismaPromise<GetCommunityAggregateType<T>>

    /**
     * Group by Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Community model
   */
  readonly fields: CommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Community.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lots<T extends Community$lotsArgs<ExtArgs> = {}>(args?: Subset<T, Community$lotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends Community$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Community$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variancePatterns<T extends Community$variancePatternsArgs<ExtArgs> = {}>(args?: Subset<T, Community$variancePatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Community model
   */
  interface CommunityFieldRefs {
    readonly id: FieldRef<"Community", 'String'>
    readonly name: FieldRef<"Community", 'String'>
    readonly customerId: FieldRef<"Community", 'String'>
    readonly shippingYard: FieldRef<"Community", 'String'>
    readonly jurisdiction: FieldRef<"Community", 'String'>
    readonly region: FieldRef<"Community", 'String'>
    readonly activePlans: FieldRef<"Community", 'Int'>
    readonly isActive: FieldRef<"Community", 'Boolean'>
    readonly specialRequirements: FieldRef<"Community", 'String'>
    readonly createdAt: FieldRef<"Community", 'DateTime'>
    readonly updatedAt: FieldRef<"Community", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Community findUnique
   */
  export type CommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findUniqueOrThrow
   */
  export type CommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findFirst
   */
  export type CommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findFirstOrThrow
   */
  export type CommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findMany
   */
  export type CommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Communities to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community create
   */
  export type CommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Community.
     */
    data: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
  }

  /**
   * Community createMany
   */
  export type CommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Community createManyAndReturn
   */
  export type CommunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Community update
   */
  export type CommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Community.
     */
    data: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    /**
     * Choose, which Community to update.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community updateMany
   */
  export type CommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to update.
     */
    limit?: number
  }

  /**
   * Community updateManyAndReturn
   */
  export type CommunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Community upsert
   */
  export type CommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Community to update in case it exists.
     */
    where: CommunityWhereUniqueInput
    /**
     * In case the Community found by the `where` argument doesn't exist, create a new Community with this data.
     */
    create: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    /**
     * In case the Community was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
  }

  /**
   * Community delete
   */
  export type CommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter which Community to delete.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community deleteMany
   */
  export type CommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communities to delete
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to delete.
     */
    limit?: number
  }

  /**
   * Community.lots
   */
  export type Community$lotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    where?: LotWhereInput
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    cursor?: LotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotScalarFieldEnum | LotScalarFieldEnum[]
  }

  /**
   * Community.jobs
   */
  export type Community$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Community.variancePatterns
   */
  export type Community$variancePatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    where?: VariancePatternWhereInput
    orderBy?: VariancePatternOrderByWithRelationInput | VariancePatternOrderByWithRelationInput[]
    cursor?: VariancePatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariancePatternScalarFieldEnum | VariancePatternScalarFieldEnum[]
  }

  /**
   * Community without action
   */
  export type CommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
  }


  /**
   * Model Lot
   */

  export type AggregateLot = {
    _count: LotCountAggregateOutputType | null
    _avg: LotAvgAggregateOutputType | null
    _sum: LotSumAggregateOutputType | null
    _min: LotMinAggregateOutputType | null
    _max: LotMaxAggregateOutputType | null
  }

  export type LotAvgAggregateOutputType = {
    sqft: number | null
    frontage: Decimal | null
    depth: Decimal | null
  }

  export type LotSumAggregateOutputType = {
    sqft: number | null
    frontage: Decimal | null
    depth: Decimal | null
  }

  export type LotMinAggregateOutputType = {
    id: string | null
    communityId: string | null
    lotNumber: string | null
    status: $Enums.LotStatus | null
    sqft: number | null
    frontage: Decimal | null
    depth: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LotMaxAggregateOutputType = {
    id: string | null
    communityId: string | null
    lotNumber: string | null
    status: $Enums.LotStatus | null
    sqft: number | null
    frontage: Decimal | null
    depth: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LotCountAggregateOutputType = {
    id: number
    communityId: number
    lotNumber: number
    status: number
    sqft: number
    frontage: number
    depth: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LotAvgAggregateInputType = {
    sqft?: true
    frontage?: true
    depth?: true
  }

  export type LotSumAggregateInputType = {
    sqft?: true
    frontage?: true
    depth?: true
  }

  export type LotMinAggregateInputType = {
    id?: true
    communityId?: true
    lotNumber?: true
    status?: true
    sqft?: true
    frontage?: true
    depth?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LotMaxAggregateInputType = {
    id?: true
    communityId?: true
    lotNumber?: true
    status?: true
    sqft?: true
    frontage?: true
    depth?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LotCountAggregateInputType = {
    id?: true
    communityId?: true
    lotNumber?: true
    status?: true
    sqft?: true
    frontage?: true
    depth?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lot to aggregate.
     */
    where?: LotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lots to fetch.
     */
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lots
    **/
    _count?: true | LotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LotMaxAggregateInputType
  }

  export type GetLotAggregateType<T extends LotAggregateArgs> = {
        [P in keyof T & keyof AggregateLot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLot[P]>
      : GetScalarType<T[P], AggregateLot[P]>
  }




  export type LotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotWhereInput
    orderBy?: LotOrderByWithAggregationInput | LotOrderByWithAggregationInput[]
    by: LotScalarFieldEnum[] | LotScalarFieldEnum
    having?: LotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LotCountAggregateInputType | true
    _avg?: LotAvgAggregateInputType
    _sum?: LotSumAggregateInputType
    _min?: LotMinAggregateInputType
    _max?: LotMaxAggregateInputType
  }

  export type LotGroupByOutputType = {
    id: string
    communityId: string
    lotNumber: string
    status: $Enums.LotStatus
    sqft: number | null
    frontage: Decimal | null
    depth: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: LotCountAggregateOutputType | null
    _avg: LotAvgAggregateOutputType | null
    _sum: LotSumAggregateOutputType | null
    _min: LotMinAggregateOutputType | null
    _max: LotMaxAggregateOutputType | null
  }

  type GetLotGroupByPayload<T extends LotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LotGroupByOutputType[P]>
            : GetScalarType<T[P], LotGroupByOutputType[P]>
        }
      >
    >


  export type LotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    lotNumber?: boolean
    status?: boolean
    sqft?: boolean
    frontage?: boolean
    depth?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    jobs?: boolean | Lot$jobsArgs<ExtArgs>
    _count?: boolean | LotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lot"]>

  export type LotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    lotNumber?: boolean
    status?: boolean
    sqft?: boolean
    frontage?: boolean
    depth?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lot"]>

  export type LotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    lotNumber?: boolean
    status?: boolean
    sqft?: boolean
    frontage?: boolean
    depth?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lot"]>

  export type LotSelectScalar = {
    id?: boolean
    communityId?: boolean
    lotNumber?: boolean
    status?: boolean
    sqft?: boolean
    frontage?: boolean
    depth?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "communityId" | "lotNumber" | "status" | "sqft" | "frontage" | "depth" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["lot"]>
  export type LotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    jobs?: boolean | Lot$jobsArgs<ExtArgs>
    _count?: boolean | LotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }
  export type LotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }

  export type $LotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lot"
    objects: {
      community: Prisma.$CommunityPayload<ExtArgs>
      jobs: Prisma.$JobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      communityId: string
      lotNumber: string
      status: $Enums.LotStatus
      sqft: number | null
      frontage: Prisma.Decimal | null
      depth: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lot"]>
    composites: {}
  }

  type LotGetPayload<S extends boolean | null | undefined | LotDefaultArgs> = $Result.GetResult<Prisma.$LotPayload, S>

  type LotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LotCountAggregateInputType | true
    }

  export interface LotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lot'], meta: { name: 'Lot' } }
    /**
     * Find zero or one Lot that matches the filter.
     * @param {LotFindUniqueArgs} args - Arguments to find a Lot
     * @example
     * // Get one Lot
     * const lot = await prisma.lot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LotFindUniqueArgs>(args: SelectSubset<T, LotFindUniqueArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LotFindUniqueOrThrowArgs} args - Arguments to find a Lot
     * @example
     * // Get one Lot
     * const lot = await prisma.lot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LotFindUniqueOrThrowArgs>(args: SelectSubset<T, LotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFindFirstArgs} args - Arguments to find a Lot
     * @example
     * // Get one Lot
     * const lot = await prisma.lot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LotFindFirstArgs>(args?: SelectSubset<T, LotFindFirstArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFindFirstOrThrowArgs} args - Arguments to find a Lot
     * @example
     * // Get one Lot
     * const lot = await prisma.lot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LotFindFirstOrThrowArgs>(args?: SelectSubset<T, LotFindFirstOrThrowArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lots
     * const lots = await prisma.lot.findMany()
     * 
     * // Get first 10 Lots
     * const lots = await prisma.lot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lotWithIdOnly = await prisma.lot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LotFindManyArgs>(args?: SelectSubset<T, LotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lot.
     * @param {LotCreateArgs} args - Arguments to create a Lot.
     * @example
     * // Create one Lot
     * const Lot = await prisma.lot.create({
     *   data: {
     *     // ... data to create a Lot
     *   }
     * })
     * 
     */
    create<T extends LotCreateArgs>(args: SelectSubset<T, LotCreateArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lots.
     * @param {LotCreateManyArgs} args - Arguments to create many Lots.
     * @example
     * // Create many Lots
     * const lot = await prisma.lot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LotCreateManyArgs>(args?: SelectSubset<T, LotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lots and returns the data saved in the database.
     * @param {LotCreateManyAndReturnArgs} args - Arguments to create many Lots.
     * @example
     * // Create many Lots
     * const lot = await prisma.lot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lots and only return the `id`
     * const lotWithIdOnly = await prisma.lot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LotCreateManyAndReturnArgs>(args?: SelectSubset<T, LotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lot.
     * @param {LotDeleteArgs} args - Arguments to delete one Lot.
     * @example
     * // Delete one Lot
     * const Lot = await prisma.lot.delete({
     *   where: {
     *     // ... filter to delete one Lot
     *   }
     * })
     * 
     */
    delete<T extends LotDeleteArgs>(args: SelectSubset<T, LotDeleteArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lot.
     * @param {LotUpdateArgs} args - Arguments to update one Lot.
     * @example
     * // Update one Lot
     * const lot = await prisma.lot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LotUpdateArgs>(args: SelectSubset<T, LotUpdateArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lots.
     * @param {LotDeleteManyArgs} args - Arguments to filter Lots to delete.
     * @example
     * // Delete a few Lots
     * const { count } = await prisma.lot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LotDeleteManyArgs>(args?: SelectSubset<T, LotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lots
     * const lot = await prisma.lot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LotUpdateManyArgs>(args: SelectSubset<T, LotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lots and returns the data updated in the database.
     * @param {LotUpdateManyAndReturnArgs} args - Arguments to update many Lots.
     * @example
     * // Update many Lots
     * const lot = await prisma.lot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lots and only return the `id`
     * const lotWithIdOnly = await prisma.lot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LotUpdateManyAndReturnArgs>(args: SelectSubset<T, LotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lot.
     * @param {LotUpsertArgs} args - Arguments to update or create a Lot.
     * @example
     * // Update or create a Lot
     * const lot = await prisma.lot.upsert({
     *   create: {
     *     // ... data to create a Lot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lot we want to update
     *   }
     * })
     */
    upsert<T extends LotUpsertArgs>(args: SelectSubset<T, LotUpsertArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotCountArgs} args - Arguments to filter Lots to count.
     * @example
     * // Count the number of Lots
     * const count = await prisma.lot.count({
     *   where: {
     *     // ... the filter for the Lots we want to count
     *   }
     * })
    **/
    count<T extends LotCountArgs>(
      args?: Subset<T, LotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LotAggregateArgs>(args: Subset<T, LotAggregateArgs>): Prisma.PrismaPromise<GetLotAggregateType<T>>

    /**
     * Group by Lot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LotGroupByArgs['orderBy'] }
        : { orderBy?: LotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lot model
   */
  readonly fields: LotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobs<T extends Lot$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Lot$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lot model
   */
  interface LotFieldRefs {
    readonly id: FieldRef<"Lot", 'String'>
    readonly communityId: FieldRef<"Lot", 'String'>
    readonly lotNumber: FieldRef<"Lot", 'String'>
    readonly status: FieldRef<"Lot", 'LotStatus'>
    readonly sqft: FieldRef<"Lot", 'Int'>
    readonly frontage: FieldRef<"Lot", 'Decimal'>
    readonly depth: FieldRef<"Lot", 'Decimal'>
    readonly notes: FieldRef<"Lot", 'String'>
    readonly createdAt: FieldRef<"Lot", 'DateTime'>
    readonly updatedAt: FieldRef<"Lot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lot findUnique
   */
  export type LotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lot to fetch.
     */
    where: LotWhereUniqueInput
  }

  /**
   * Lot findUniqueOrThrow
   */
  export type LotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lot to fetch.
     */
    where: LotWhereUniqueInput
  }

  /**
   * Lot findFirst
   */
  export type LotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lot to fetch.
     */
    where?: LotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lots to fetch.
     */
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lots.
     */
    cursor?: LotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lots.
     */
    distinct?: LotScalarFieldEnum | LotScalarFieldEnum[]
  }

  /**
   * Lot findFirstOrThrow
   */
  export type LotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lot to fetch.
     */
    where?: LotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lots to fetch.
     */
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lots.
     */
    cursor?: LotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lots.
     */
    distinct?: LotScalarFieldEnum | LotScalarFieldEnum[]
  }

  /**
   * Lot findMany
   */
  export type LotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lots to fetch.
     */
    where?: LotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lots to fetch.
     */
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lots.
     */
    cursor?: LotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lots.
     */
    skip?: number
    distinct?: LotScalarFieldEnum | LotScalarFieldEnum[]
  }

  /**
   * Lot create
   */
  export type LotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * The data needed to create a Lot.
     */
    data: XOR<LotCreateInput, LotUncheckedCreateInput>
  }

  /**
   * Lot createMany
   */
  export type LotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lots.
     */
    data: LotCreateManyInput | LotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lot createManyAndReturn
   */
  export type LotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * The data used to create many Lots.
     */
    data: LotCreateManyInput | LotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lot update
   */
  export type LotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * The data needed to update a Lot.
     */
    data: XOR<LotUpdateInput, LotUncheckedUpdateInput>
    /**
     * Choose, which Lot to update.
     */
    where: LotWhereUniqueInput
  }

  /**
   * Lot updateMany
   */
  export type LotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lots.
     */
    data: XOR<LotUpdateManyMutationInput, LotUncheckedUpdateManyInput>
    /**
     * Filter which Lots to update
     */
    where?: LotWhereInput
    /**
     * Limit how many Lots to update.
     */
    limit?: number
  }

  /**
   * Lot updateManyAndReturn
   */
  export type LotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * The data used to update Lots.
     */
    data: XOR<LotUpdateManyMutationInput, LotUncheckedUpdateManyInput>
    /**
     * Filter which Lots to update
     */
    where?: LotWhereInput
    /**
     * Limit how many Lots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lot upsert
   */
  export type LotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * The filter to search for the Lot to update in case it exists.
     */
    where: LotWhereUniqueInput
    /**
     * In case the Lot found by the `where` argument doesn't exist, create a new Lot with this data.
     */
    create: XOR<LotCreateInput, LotUncheckedCreateInput>
    /**
     * In case the Lot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LotUpdateInput, LotUncheckedUpdateInput>
  }

  /**
   * Lot delete
   */
  export type LotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter which Lot to delete.
     */
    where: LotWhereUniqueInput
  }

  /**
   * Lot deleteMany
   */
  export type LotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lots to delete
     */
    where?: LotWhereInput
    /**
     * Limit how many Lots to delete.
     */
    limit?: number
  }

  /**
   * Lot.jobs
   */
  export type Lot$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Lot without action
   */
  export type LotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    estimatedCost: Decimal | null
    actualCost: Decimal | null
    margin: Decimal | null
  }

  export type JobSumAggregateOutputType = {
    estimatedCost: Decimal | null
    actualCost: Decimal | null
    margin: Decimal | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    jobNumber: string | null
    customerId: string | null
    planId: string | null
    elevationId: string | null
    communityId: string | null
    lotId: string | null
    status: $Enums.JobStatus | null
    estimatedCost: Decimal | null
    actualCost: Decimal | null
    margin: Decimal | null
    createdById: string | null
    approvedById: string | null
    approvedAt: Date | null
    startDate: Date | null
    completionDate: Date | null
    notes: string | null
    folderPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    jobNumber: string | null
    customerId: string | null
    planId: string | null
    elevationId: string | null
    communityId: string | null
    lotId: string | null
    status: $Enums.JobStatus | null
    estimatedCost: Decimal | null
    actualCost: Decimal | null
    margin: Decimal | null
    createdById: string | null
    approvedById: string | null
    approvedAt: Date | null
    startDate: Date | null
    completionDate: Date | null
    notes: string | null
    folderPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    jobNumber: number
    customerId: number
    planId: number
    elevationId: number
    communityId: number
    lotId: number
    status: number
    estimatedCost: number
    actualCost: number
    margin: number
    createdById: number
    approvedById: number
    approvedAt: number
    startDate: number
    completionDate: number
    notes: number
    folderPath: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    estimatedCost?: true
    actualCost?: true
    margin?: true
  }

  export type JobSumAggregateInputType = {
    estimatedCost?: true
    actualCost?: true
    margin?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    jobNumber?: true
    customerId?: true
    planId?: true
    elevationId?: true
    communityId?: true
    lotId?: true
    status?: true
    estimatedCost?: true
    actualCost?: true
    margin?: true
    createdById?: true
    approvedById?: true
    approvedAt?: true
    startDate?: true
    completionDate?: true
    notes?: true
    folderPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    jobNumber?: true
    customerId?: true
    planId?: true
    elevationId?: true
    communityId?: true
    lotId?: true
    status?: true
    estimatedCost?: true
    actualCost?: true
    margin?: true
    createdById?: true
    approvedById?: true
    approvedAt?: true
    startDate?: true
    completionDate?: true
    notes?: true
    folderPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    jobNumber?: true
    customerId?: true
    planId?: true
    elevationId?: true
    communityId?: true
    lotId?: true
    status?: true
    estimatedCost?: true
    actualCost?: true
    margin?: true
    createdById?: true
    approvedById?: true
    approvedAt?: true
    startDate?: true
    completionDate?: true
    notes?: true
    folderPath?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId: string | null
    communityId: string | null
    lotId: string | null
    status: $Enums.JobStatus
    estimatedCost: Decimal | null
    actualCost: Decimal | null
    margin: Decimal | null
    createdById: string
    approvedById: string | null
    approvedAt: Date | null
    startDate: Date | null
    completionDate: Date | null
    notes: string | null
    folderPath: string | null
    createdAt: Date
    updatedAt: Date
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    customerId?: boolean
    planId?: boolean
    elevationId?: boolean
    communityId?: boolean
    lotId?: boolean
    status?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    margin?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    startDate?: boolean
    completionDate?: boolean
    notes?: boolean
    folderPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    elevation?: boolean | Job$elevationArgs<ExtArgs>
    community?: boolean | Job$communityArgs<ExtArgs>
    lot?: boolean | Job$lotArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Job$approvedByArgs<ExtArgs>
    jobOptions?: boolean | Job$jobOptionsArgs<ExtArgs>
    takeoff?: boolean | Job$takeoffArgs<ExtArgs>
    purchaseOrders?: boolean | Job$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    customerId?: boolean
    planId?: boolean
    elevationId?: boolean
    communityId?: boolean
    lotId?: boolean
    status?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    margin?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    startDate?: boolean
    completionDate?: boolean
    notes?: boolean
    folderPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    elevation?: boolean | Job$elevationArgs<ExtArgs>
    community?: boolean | Job$communityArgs<ExtArgs>
    lot?: boolean | Job$lotArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Job$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    customerId?: boolean
    planId?: boolean
    elevationId?: boolean
    communityId?: boolean
    lotId?: boolean
    status?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    margin?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    startDate?: boolean
    completionDate?: boolean
    notes?: boolean
    folderPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    elevation?: boolean | Job$elevationArgs<ExtArgs>
    community?: boolean | Job$communityArgs<ExtArgs>
    lot?: boolean | Job$lotArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Job$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    jobNumber?: boolean
    customerId?: boolean
    planId?: boolean
    elevationId?: boolean
    communityId?: boolean
    lotId?: boolean
    status?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    margin?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    startDate?: boolean
    completionDate?: boolean
    notes?: boolean
    folderPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobNumber" | "customerId" | "planId" | "elevationId" | "communityId" | "lotId" | "status" | "estimatedCost" | "actualCost" | "margin" | "createdById" | "approvedById" | "approvedAt" | "startDate" | "completionDate" | "notes" | "folderPath" | "createdAt" | "updatedAt", ExtArgs["result"]["job"]>
  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    elevation?: boolean | Job$elevationArgs<ExtArgs>
    community?: boolean | Job$communityArgs<ExtArgs>
    lot?: boolean | Job$lotArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Job$approvedByArgs<ExtArgs>
    jobOptions?: boolean | Job$jobOptionsArgs<ExtArgs>
    takeoff?: boolean | Job$takeoffArgs<ExtArgs>
    purchaseOrders?: boolean | Job$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    elevation?: boolean | Job$elevationArgs<ExtArgs>
    community?: boolean | Job$communityArgs<ExtArgs>
    lot?: boolean | Job$lotArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Job$approvedByArgs<ExtArgs>
  }
  export type JobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    elevation?: boolean | Job$elevationArgs<ExtArgs>
    community?: boolean | Job$communityArgs<ExtArgs>
    lot?: boolean | Job$lotArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Job$approvedByArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
      elevation: Prisma.$PlanElevationPayload<ExtArgs> | null
      community: Prisma.$CommunityPayload<ExtArgs> | null
      lot: Prisma.$LotPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      jobOptions: Prisma.$JobOptionPayload<ExtArgs>[]
      takeoff: Prisma.$TakeoffPayload<ExtArgs> | null
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobNumber: string
      customerId: string
      planId: string
      elevationId: string | null
      communityId: string | null
      lotId: string | null
      status: $Enums.JobStatus
      estimatedCost: Prisma.Decimal | null
      actualCost: Prisma.Decimal | null
      margin: Prisma.Decimal | null
      createdById: string
      approvedById: string | null
      approvedAt: Date | null
      startDate: Date | null
      completionDate: Date | null
      notes: string | null
      folderPath: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {JobUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobUpdateManyAndReturnArgs>(args: SelectSubset<T, JobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    elevation<T extends Job$elevationArgs<ExtArgs> = {}>(args?: Subset<T, Job$elevationArgs<ExtArgs>>): Prisma__PlanElevationClient<$Result.GetResult<Prisma.$PlanElevationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    community<T extends Job$communityArgs<ExtArgs> = {}>(args?: Subset<T, Job$communityArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lot<T extends Job$lotArgs<ExtArgs> = {}>(args?: Subset<T, Job$lotArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Job$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Job$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobOptions<T extends Job$jobOptionsArgs<ExtArgs> = {}>(args?: Subset<T, Job$jobOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    takeoff<T extends Job$takeoffArgs<ExtArgs> = {}>(args?: Subset<T, Job$takeoffArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchaseOrders<T extends Job$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Job$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'String'>
    readonly jobNumber: FieldRef<"Job", 'String'>
    readonly customerId: FieldRef<"Job", 'String'>
    readonly planId: FieldRef<"Job", 'String'>
    readonly elevationId: FieldRef<"Job", 'String'>
    readonly communityId: FieldRef<"Job", 'String'>
    readonly lotId: FieldRef<"Job", 'String'>
    readonly status: FieldRef<"Job", 'JobStatus'>
    readonly estimatedCost: FieldRef<"Job", 'Decimal'>
    readonly actualCost: FieldRef<"Job", 'Decimal'>
    readonly margin: FieldRef<"Job", 'Decimal'>
    readonly createdById: FieldRef<"Job", 'String'>
    readonly approvedById: FieldRef<"Job", 'String'>
    readonly approvedAt: FieldRef<"Job", 'DateTime'>
    readonly startDate: FieldRef<"Job", 'DateTime'>
    readonly completionDate: FieldRef<"Job", 'DateTime'>
    readonly notes: FieldRef<"Job", 'String'>
    readonly folderPath: FieldRef<"Job", 'String'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Job updateManyAndReturn
   */
  export type JobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to delete.
     */
    limit?: number
  }

  /**
   * Job.elevation
   */
  export type Job$elevationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanElevation
     */
    select?: PlanElevationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanElevation
     */
    omit?: PlanElevationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanElevationInclude<ExtArgs> | null
    where?: PlanElevationWhereInput
  }

  /**
   * Job.community
   */
  export type Job$communityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
  }

  /**
   * Job.lot
   */
  export type Job$lotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lot
     */
    omit?: LotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    where?: LotWhereInput
  }

  /**
   * Job.approvedBy
   */
  export type Job$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Job.jobOptions
   */
  export type Job$jobOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    where?: JobOptionWhereInput
    orderBy?: JobOptionOrderByWithRelationInput | JobOptionOrderByWithRelationInput[]
    cursor?: JobOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobOptionScalarFieldEnum | JobOptionScalarFieldEnum[]
  }

  /**
   * Job.takeoff
   */
  export type Job$takeoffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    where?: TakeoffWhereInput
  }

  /**
   * Job.purchaseOrders
   */
  export type Job$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model JobOption
   */

  export type AggregateJobOption = {
    _count: JobOptionCountAggregateOutputType | null
    _avg: JobOptionAvgAggregateOutputType | null
    _sum: JobOptionSumAggregateOutputType | null
    _min: JobOptionMinAggregateOutputType | null
    _max: JobOptionMaxAggregateOutputType | null
  }

  export type JobOptionAvgAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type JobOptionSumAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type JobOptionMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    optionId: string | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type JobOptionMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    optionId: string | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type JobOptionCountAggregateOutputType = {
    id: number
    jobId: number
    optionId: number
    quantity: number
    price: number
    createdAt: number
    _all: number
  }


  export type JobOptionAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type JobOptionSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type JobOptionMinAggregateInputType = {
    id?: true
    jobId?: true
    optionId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type JobOptionMaxAggregateInputType = {
    id?: true
    jobId?: true
    optionId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type JobOptionCountAggregateInputType = {
    id?: true
    jobId?: true
    optionId?: true
    quantity?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type JobOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobOption to aggregate.
     */
    where?: JobOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOptions to fetch.
     */
    orderBy?: JobOptionOrderByWithRelationInput | JobOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobOptions
    **/
    _count?: true | JobOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobOptionMaxAggregateInputType
  }

  export type GetJobOptionAggregateType<T extends JobOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateJobOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobOption[P]>
      : GetScalarType<T[P], AggregateJobOption[P]>
  }




  export type JobOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobOptionWhereInput
    orderBy?: JobOptionOrderByWithAggregationInput | JobOptionOrderByWithAggregationInput[]
    by: JobOptionScalarFieldEnum[] | JobOptionScalarFieldEnum
    having?: JobOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobOptionCountAggregateInputType | true
    _avg?: JobOptionAvgAggregateInputType
    _sum?: JobOptionSumAggregateInputType
    _min?: JobOptionMinAggregateInputType
    _max?: JobOptionMaxAggregateInputType
  }

  export type JobOptionGroupByOutputType = {
    id: string
    jobId: string
    optionId: string
    quantity: number
    price: Decimal
    createdAt: Date
    _count: JobOptionCountAggregateOutputType | null
    _avg: JobOptionAvgAggregateOutputType | null
    _sum: JobOptionSumAggregateOutputType | null
    _min: JobOptionMinAggregateOutputType | null
    _max: JobOptionMaxAggregateOutputType | null
  }

  type GetJobOptionGroupByPayload<T extends JobOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobOptionGroupByOutputType[P]>
            : GetScalarType<T[P], JobOptionGroupByOutputType[P]>
        }
      >
    >


  export type JobOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    optionId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    option?: boolean | PlanOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobOption"]>

  export type JobOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    optionId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    option?: boolean | PlanOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobOption"]>

  export type JobOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    optionId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    option?: boolean | PlanOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobOption"]>

  export type JobOptionSelectScalar = {
    id?: boolean
    jobId?: boolean
    optionId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
  }

  export type JobOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "optionId" | "quantity" | "price" | "createdAt", ExtArgs["result"]["jobOption"]>
  export type JobOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    option?: boolean | PlanOptionDefaultArgs<ExtArgs>
  }
  export type JobOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    option?: boolean | PlanOptionDefaultArgs<ExtArgs>
  }
  export type JobOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    option?: boolean | PlanOptionDefaultArgs<ExtArgs>
  }

  export type $JobOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobOption"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
      option: Prisma.$PlanOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      optionId: string
      quantity: number
      price: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["jobOption"]>
    composites: {}
  }

  type JobOptionGetPayload<S extends boolean | null | undefined | JobOptionDefaultArgs> = $Result.GetResult<Prisma.$JobOptionPayload, S>

  type JobOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobOptionCountAggregateInputType | true
    }

  export interface JobOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobOption'], meta: { name: 'JobOption' } }
    /**
     * Find zero or one JobOption that matches the filter.
     * @param {JobOptionFindUniqueArgs} args - Arguments to find a JobOption
     * @example
     * // Get one JobOption
     * const jobOption = await prisma.jobOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobOptionFindUniqueArgs>(args: SelectSubset<T, JobOptionFindUniqueArgs<ExtArgs>>): Prisma__JobOptionClient<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobOptionFindUniqueOrThrowArgs} args - Arguments to find a JobOption
     * @example
     * // Get one JobOption
     * const jobOption = await prisma.jobOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, JobOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobOptionClient<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOptionFindFirstArgs} args - Arguments to find a JobOption
     * @example
     * // Get one JobOption
     * const jobOption = await prisma.jobOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobOptionFindFirstArgs>(args?: SelectSubset<T, JobOptionFindFirstArgs<ExtArgs>>): Prisma__JobOptionClient<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOptionFindFirstOrThrowArgs} args - Arguments to find a JobOption
     * @example
     * // Get one JobOption
     * const jobOption = await prisma.jobOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, JobOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobOptionClient<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobOptions
     * const jobOptions = await prisma.jobOption.findMany()
     * 
     * // Get first 10 JobOptions
     * const jobOptions = await prisma.jobOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobOptionWithIdOnly = await prisma.jobOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobOptionFindManyArgs>(args?: SelectSubset<T, JobOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobOption.
     * @param {JobOptionCreateArgs} args - Arguments to create a JobOption.
     * @example
     * // Create one JobOption
     * const JobOption = await prisma.jobOption.create({
     *   data: {
     *     // ... data to create a JobOption
     *   }
     * })
     * 
     */
    create<T extends JobOptionCreateArgs>(args: SelectSubset<T, JobOptionCreateArgs<ExtArgs>>): Prisma__JobOptionClient<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobOptions.
     * @param {JobOptionCreateManyArgs} args - Arguments to create many JobOptions.
     * @example
     * // Create many JobOptions
     * const jobOption = await prisma.jobOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobOptionCreateManyArgs>(args?: SelectSubset<T, JobOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobOptions and returns the data saved in the database.
     * @param {JobOptionCreateManyAndReturnArgs} args - Arguments to create many JobOptions.
     * @example
     * // Create many JobOptions
     * const jobOption = await prisma.jobOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobOptions and only return the `id`
     * const jobOptionWithIdOnly = await prisma.jobOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, JobOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobOption.
     * @param {JobOptionDeleteArgs} args - Arguments to delete one JobOption.
     * @example
     * // Delete one JobOption
     * const JobOption = await prisma.jobOption.delete({
     *   where: {
     *     // ... filter to delete one JobOption
     *   }
     * })
     * 
     */
    delete<T extends JobOptionDeleteArgs>(args: SelectSubset<T, JobOptionDeleteArgs<ExtArgs>>): Prisma__JobOptionClient<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobOption.
     * @param {JobOptionUpdateArgs} args - Arguments to update one JobOption.
     * @example
     * // Update one JobOption
     * const jobOption = await prisma.jobOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobOptionUpdateArgs>(args: SelectSubset<T, JobOptionUpdateArgs<ExtArgs>>): Prisma__JobOptionClient<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobOptions.
     * @param {JobOptionDeleteManyArgs} args - Arguments to filter JobOptions to delete.
     * @example
     * // Delete a few JobOptions
     * const { count } = await prisma.jobOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobOptionDeleteManyArgs>(args?: SelectSubset<T, JobOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobOptions
     * const jobOption = await prisma.jobOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobOptionUpdateManyArgs>(args: SelectSubset<T, JobOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobOptions and returns the data updated in the database.
     * @param {JobOptionUpdateManyAndReturnArgs} args - Arguments to update many JobOptions.
     * @example
     * // Update many JobOptions
     * const jobOption = await prisma.jobOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobOptions and only return the `id`
     * const jobOptionWithIdOnly = await prisma.jobOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, JobOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobOption.
     * @param {JobOptionUpsertArgs} args - Arguments to update or create a JobOption.
     * @example
     * // Update or create a JobOption
     * const jobOption = await prisma.jobOption.upsert({
     *   create: {
     *     // ... data to create a JobOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobOption we want to update
     *   }
     * })
     */
    upsert<T extends JobOptionUpsertArgs>(args: SelectSubset<T, JobOptionUpsertArgs<ExtArgs>>): Prisma__JobOptionClient<$Result.GetResult<Prisma.$JobOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOptionCountArgs} args - Arguments to filter JobOptions to count.
     * @example
     * // Count the number of JobOptions
     * const count = await prisma.jobOption.count({
     *   where: {
     *     // ... the filter for the JobOptions we want to count
     *   }
     * })
    **/
    count<T extends JobOptionCountArgs>(
      args?: Subset<T, JobOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobOptionAggregateArgs>(args: Subset<T, JobOptionAggregateArgs>): Prisma.PrismaPromise<GetJobOptionAggregateType<T>>

    /**
     * Group by JobOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobOptionGroupByArgs['orderBy'] }
        : { orderBy?: JobOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobOption model
   */
  readonly fields: JobOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option<T extends PlanOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanOptionDefaultArgs<ExtArgs>>): Prisma__PlanOptionClient<$Result.GetResult<Prisma.$PlanOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobOption model
   */
  interface JobOptionFieldRefs {
    readonly id: FieldRef<"JobOption", 'String'>
    readonly jobId: FieldRef<"JobOption", 'String'>
    readonly optionId: FieldRef<"JobOption", 'String'>
    readonly quantity: FieldRef<"JobOption", 'Int'>
    readonly price: FieldRef<"JobOption", 'Decimal'>
    readonly createdAt: FieldRef<"JobOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobOption findUnique
   */
  export type JobOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    /**
     * Filter, which JobOption to fetch.
     */
    where: JobOptionWhereUniqueInput
  }

  /**
   * JobOption findUniqueOrThrow
   */
  export type JobOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    /**
     * Filter, which JobOption to fetch.
     */
    where: JobOptionWhereUniqueInput
  }

  /**
   * JobOption findFirst
   */
  export type JobOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    /**
     * Filter, which JobOption to fetch.
     */
    where?: JobOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOptions to fetch.
     */
    orderBy?: JobOptionOrderByWithRelationInput | JobOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobOptions.
     */
    cursor?: JobOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobOptions.
     */
    distinct?: JobOptionScalarFieldEnum | JobOptionScalarFieldEnum[]
  }

  /**
   * JobOption findFirstOrThrow
   */
  export type JobOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    /**
     * Filter, which JobOption to fetch.
     */
    where?: JobOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOptions to fetch.
     */
    orderBy?: JobOptionOrderByWithRelationInput | JobOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobOptions.
     */
    cursor?: JobOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobOptions.
     */
    distinct?: JobOptionScalarFieldEnum | JobOptionScalarFieldEnum[]
  }

  /**
   * JobOption findMany
   */
  export type JobOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    /**
     * Filter, which JobOptions to fetch.
     */
    where?: JobOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOptions to fetch.
     */
    orderBy?: JobOptionOrderByWithRelationInput | JobOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobOptions.
     */
    cursor?: JobOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOptions.
     */
    skip?: number
    distinct?: JobOptionScalarFieldEnum | JobOptionScalarFieldEnum[]
  }

  /**
   * JobOption create
   */
  export type JobOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a JobOption.
     */
    data: XOR<JobOptionCreateInput, JobOptionUncheckedCreateInput>
  }

  /**
   * JobOption createMany
   */
  export type JobOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobOptions.
     */
    data: JobOptionCreateManyInput | JobOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobOption createManyAndReturn
   */
  export type JobOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * The data used to create many JobOptions.
     */
    data: JobOptionCreateManyInput | JobOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobOption update
   */
  export type JobOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a JobOption.
     */
    data: XOR<JobOptionUpdateInput, JobOptionUncheckedUpdateInput>
    /**
     * Choose, which JobOption to update.
     */
    where: JobOptionWhereUniqueInput
  }

  /**
   * JobOption updateMany
   */
  export type JobOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobOptions.
     */
    data: XOR<JobOptionUpdateManyMutationInput, JobOptionUncheckedUpdateManyInput>
    /**
     * Filter which JobOptions to update
     */
    where?: JobOptionWhereInput
    /**
     * Limit how many JobOptions to update.
     */
    limit?: number
  }

  /**
   * JobOption updateManyAndReturn
   */
  export type JobOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * The data used to update JobOptions.
     */
    data: XOR<JobOptionUpdateManyMutationInput, JobOptionUncheckedUpdateManyInput>
    /**
     * Filter which JobOptions to update
     */
    where?: JobOptionWhereInput
    /**
     * Limit how many JobOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobOption upsert
   */
  export type JobOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the JobOption to update in case it exists.
     */
    where: JobOptionWhereUniqueInput
    /**
     * In case the JobOption found by the `where` argument doesn't exist, create a new JobOption with this data.
     */
    create: XOR<JobOptionCreateInput, JobOptionUncheckedCreateInput>
    /**
     * In case the JobOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobOptionUpdateInput, JobOptionUncheckedUpdateInput>
  }

  /**
   * JobOption delete
   */
  export type JobOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
    /**
     * Filter which JobOption to delete.
     */
    where: JobOptionWhereUniqueInput
  }

  /**
   * JobOption deleteMany
   */
  export type JobOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobOptions to delete
     */
    where?: JobOptionWhereInput
    /**
     * Limit how many JobOptions to delete.
     */
    limit?: number
  }

  /**
   * JobOption without action
   */
  export type JobOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOption
     */
    select?: JobOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobOption
     */
    omit?: JobOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobOptionInclude<ExtArgs> | null
  }


  /**
   * Model Takeoff
   */

  export type AggregateTakeoff = {
    _count: TakeoffCountAggregateOutputType | null
    _avg: TakeoffAvgAggregateOutputType | null
    _sum: TakeoffSumAggregateOutputType | null
    _min: TakeoffMinAggregateOutputType | null
    _max: TakeoffMaxAggregateOutputType | null
  }

  export type TakeoffAvgAggregateOutputType = {
    totalEstimated: Decimal | null
    totalActual: Decimal | null
  }

  export type TakeoffSumAggregateOutputType = {
    totalEstimated: Decimal | null
    totalActual: Decimal | null
  }

  export type TakeoffMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    status: $Enums.TakeoffStatus | null
    isValidated: boolean | null
    validatedAt: Date | null
    totalEstimated: Decimal | null
    totalActual: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TakeoffMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    status: $Enums.TakeoffStatus | null
    isValidated: boolean | null
    validatedAt: Date | null
    totalEstimated: Decimal | null
    totalActual: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TakeoffCountAggregateOutputType = {
    id: number
    jobId: number
    status: number
    isValidated: number
    validatedAt: number
    validationResults: number
    totalEstimated: number
    totalActual: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TakeoffAvgAggregateInputType = {
    totalEstimated?: true
    totalActual?: true
  }

  export type TakeoffSumAggregateInputType = {
    totalEstimated?: true
    totalActual?: true
  }

  export type TakeoffMinAggregateInputType = {
    id?: true
    jobId?: true
    status?: true
    isValidated?: true
    validatedAt?: true
    totalEstimated?: true
    totalActual?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TakeoffMaxAggregateInputType = {
    id?: true
    jobId?: true
    status?: true
    isValidated?: true
    validatedAt?: true
    totalEstimated?: true
    totalActual?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TakeoffCountAggregateInputType = {
    id?: true
    jobId?: true
    status?: true
    isValidated?: true
    validatedAt?: true
    validationResults?: true
    totalEstimated?: true
    totalActual?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TakeoffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Takeoff to aggregate.
     */
    where?: TakeoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Takeoffs to fetch.
     */
    orderBy?: TakeoffOrderByWithRelationInput | TakeoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TakeoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Takeoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Takeoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Takeoffs
    **/
    _count?: true | TakeoffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TakeoffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TakeoffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TakeoffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TakeoffMaxAggregateInputType
  }

  export type GetTakeoffAggregateType<T extends TakeoffAggregateArgs> = {
        [P in keyof T & keyof AggregateTakeoff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTakeoff[P]>
      : GetScalarType<T[P], AggregateTakeoff[P]>
  }




  export type TakeoffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakeoffWhereInput
    orderBy?: TakeoffOrderByWithAggregationInput | TakeoffOrderByWithAggregationInput[]
    by: TakeoffScalarFieldEnum[] | TakeoffScalarFieldEnum
    having?: TakeoffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TakeoffCountAggregateInputType | true
    _avg?: TakeoffAvgAggregateInputType
    _sum?: TakeoffSumAggregateInputType
    _min?: TakeoffMinAggregateInputType
    _max?: TakeoffMaxAggregateInputType
  }

  export type TakeoffGroupByOutputType = {
    id: string
    jobId: string
    status: $Enums.TakeoffStatus
    isValidated: boolean
    validatedAt: Date | null
    validationResults: JsonValue | null
    totalEstimated: Decimal
    totalActual: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: TakeoffCountAggregateOutputType | null
    _avg: TakeoffAvgAggregateOutputType | null
    _sum: TakeoffSumAggregateOutputType | null
    _min: TakeoffMinAggregateOutputType | null
    _max: TakeoffMaxAggregateOutputType | null
  }

  type GetTakeoffGroupByPayload<T extends TakeoffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TakeoffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TakeoffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TakeoffGroupByOutputType[P]>
            : GetScalarType<T[P], TakeoffGroupByOutputType[P]>
        }
      >
    >


  export type TakeoffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    status?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validationResults?: boolean
    totalEstimated?: boolean
    totalActual?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    lineItems?: boolean | Takeoff$lineItemsArgs<ExtArgs>
    validation?: boolean | Takeoff$validationArgs<ExtArgs>
    _count?: boolean | TakeoffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takeoff"]>

  export type TakeoffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    status?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validationResults?: boolean
    totalEstimated?: boolean
    totalActual?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takeoff"]>

  export type TakeoffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    status?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validationResults?: boolean
    totalEstimated?: boolean
    totalActual?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takeoff"]>

  export type TakeoffSelectScalar = {
    id?: boolean
    jobId?: boolean
    status?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validationResults?: boolean
    totalEstimated?: boolean
    totalActual?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TakeoffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "status" | "isValidated" | "validatedAt" | "validationResults" | "totalEstimated" | "totalActual" | "createdAt" | "updatedAt", ExtArgs["result"]["takeoff"]>
  export type TakeoffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    lineItems?: boolean | Takeoff$lineItemsArgs<ExtArgs>
    validation?: boolean | Takeoff$validationArgs<ExtArgs>
    _count?: boolean | TakeoffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TakeoffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type TakeoffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $TakeoffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Takeoff"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
      lineItems: Prisma.$TakeoffLineItemPayload<ExtArgs>[]
      validation: Prisma.$TakeoffValidationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      status: $Enums.TakeoffStatus
      isValidated: boolean
      validatedAt: Date | null
      validationResults: Prisma.JsonValue | null
      totalEstimated: Prisma.Decimal
      totalActual: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["takeoff"]>
    composites: {}
  }

  type TakeoffGetPayload<S extends boolean | null | undefined | TakeoffDefaultArgs> = $Result.GetResult<Prisma.$TakeoffPayload, S>

  type TakeoffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TakeoffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TakeoffCountAggregateInputType | true
    }

  export interface TakeoffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Takeoff'], meta: { name: 'Takeoff' } }
    /**
     * Find zero or one Takeoff that matches the filter.
     * @param {TakeoffFindUniqueArgs} args - Arguments to find a Takeoff
     * @example
     * // Get one Takeoff
     * const takeoff = await prisma.takeoff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TakeoffFindUniqueArgs>(args: SelectSubset<T, TakeoffFindUniqueArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Takeoff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TakeoffFindUniqueOrThrowArgs} args - Arguments to find a Takeoff
     * @example
     * // Get one Takeoff
     * const takeoff = await prisma.takeoff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TakeoffFindUniqueOrThrowArgs>(args: SelectSubset<T, TakeoffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Takeoff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffFindFirstArgs} args - Arguments to find a Takeoff
     * @example
     * // Get one Takeoff
     * const takeoff = await prisma.takeoff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TakeoffFindFirstArgs>(args?: SelectSubset<T, TakeoffFindFirstArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Takeoff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffFindFirstOrThrowArgs} args - Arguments to find a Takeoff
     * @example
     * // Get one Takeoff
     * const takeoff = await prisma.takeoff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TakeoffFindFirstOrThrowArgs>(args?: SelectSubset<T, TakeoffFindFirstOrThrowArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Takeoffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Takeoffs
     * const takeoffs = await prisma.takeoff.findMany()
     * 
     * // Get first 10 Takeoffs
     * const takeoffs = await prisma.takeoff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const takeoffWithIdOnly = await prisma.takeoff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TakeoffFindManyArgs>(args?: SelectSubset<T, TakeoffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Takeoff.
     * @param {TakeoffCreateArgs} args - Arguments to create a Takeoff.
     * @example
     * // Create one Takeoff
     * const Takeoff = await prisma.takeoff.create({
     *   data: {
     *     // ... data to create a Takeoff
     *   }
     * })
     * 
     */
    create<T extends TakeoffCreateArgs>(args: SelectSubset<T, TakeoffCreateArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Takeoffs.
     * @param {TakeoffCreateManyArgs} args - Arguments to create many Takeoffs.
     * @example
     * // Create many Takeoffs
     * const takeoff = await prisma.takeoff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TakeoffCreateManyArgs>(args?: SelectSubset<T, TakeoffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Takeoffs and returns the data saved in the database.
     * @param {TakeoffCreateManyAndReturnArgs} args - Arguments to create many Takeoffs.
     * @example
     * // Create many Takeoffs
     * const takeoff = await prisma.takeoff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Takeoffs and only return the `id`
     * const takeoffWithIdOnly = await prisma.takeoff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TakeoffCreateManyAndReturnArgs>(args?: SelectSubset<T, TakeoffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Takeoff.
     * @param {TakeoffDeleteArgs} args - Arguments to delete one Takeoff.
     * @example
     * // Delete one Takeoff
     * const Takeoff = await prisma.takeoff.delete({
     *   where: {
     *     // ... filter to delete one Takeoff
     *   }
     * })
     * 
     */
    delete<T extends TakeoffDeleteArgs>(args: SelectSubset<T, TakeoffDeleteArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Takeoff.
     * @param {TakeoffUpdateArgs} args - Arguments to update one Takeoff.
     * @example
     * // Update one Takeoff
     * const takeoff = await prisma.takeoff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TakeoffUpdateArgs>(args: SelectSubset<T, TakeoffUpdateArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Takeoffs.
     * @param {TakeoffDeleteManyArgs} args - Arguments to filter Takeoffs to delete.
     * @example
     * // Delete a few Takeoffs
     * const { count } = await prisma.takeoff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TakeoffDeleteManyArgs>(args?: SelectSubset<T, TakeoffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Takeoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Takeoffs
     * const takeoff = await prisma.takeoff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TakeoffUpdateManyArgs>(args: SelectSubset<T, TakeoffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Takeoffs and returns the data updated in the database.
     * @param {TakeoffUpdateManyAndReturnArgs} args - Arguments to update many Takeoffs.
     * @example
     * // Update many Takeoffs
     * const takeoff = await prisma.takeoff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Takeoffs and only return the `id`
     * const takeoffWithIdOnly = await prisma.takeoff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TakeoffUpdateManyAndReturnArgs>(args: SelectSubset<T, TakeoffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Takeoff.
     * @param {TakeoffUpsertArgs} args - Arguments to update or create a Takeoff.
     * @example
     * // Update or create a Takeoff
     * const takeoff = await prisma.takeoff.upsert({
     *   create: {
     *     // ... data to create a Takeoff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Takeoff we want to update
     *   }
     * })
     */
    upsert<T extends TakeoffUpsertArgs>(args: SelectSubset<T, TakeoffUpsertArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Takeoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffCountArgs} args - Arguments to filter Takeoffs to count.
     * @example
     * // Count the number of Takeoffs
     * const count = await prisma.takeoff.count({
     *   where: {
     *     // ... the filter for the Takeoffs we want to count
     *   }
     * })
    **/
    count<T extends TakeoffCountArgs>(
      args?: Subset<T, TakeoffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TakeoffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Takeoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TakeoffAggregateArgs>(args: Subset<T, TakeoffAggregateArgs>): Prisma.PrismaPromise<GetTakeoffAggregateType<T>>

    /**
     * Group by Takeoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TakeoffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TakeoffGroupByArgs['orderBy'] }
        : { orderBy?: TakeoffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TakeoffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTakeoffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Takeoff model
   */
  readonly fields: TakeoffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Takeoff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TakeoffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lineItems<T extends Takeoff$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, Takeoff$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validation<T extends Takeoff$validationArgs<ExtArgs> = {}>(args?: Subset<T, Takeoff$validationArgs<ExtArgs>>): Prisma__TakeoffValidationClient<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Takeoff model
   */
  interface TakeoffFieldRefs {
    readonly id: FieldRef<"Takeoff", 'String'>
    readonly jobId: FieldRef<"Takeoff", 'String'>
    readonly status: FieldRef<"Takeoff", 'TakeoffStatus'>
    readonly isValidated: FieldRef<"Takeoff", 'Boolean'>
    readonly validatedAt: FieldRef<"Takeoff", 'DateTime'>
    readonly validationResults: FieldRef<"Takeoff", 'Json'>
    readonly totalEstimated: FieldRef<"Takeoff", 'Decimal'>
    readonly totalActual: FieldRef<"Takeoff", 'Decimal'>
    readonly createdAt: FieldRef<"Takeoff", 'DateTime'>
    readonly updatedAt: FieldRef<"Takeoff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Takeoff findUnique
   */
  export type TakeoffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    /**
     * Filter, which Takeoff to fetch.
     */
    where: TakeoffWhereUniqueInput
  }

  /**
   * Takeoff findUniqueOrThrow
   */
  export type TakeoffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    /**
     * Filter, which Takeoff to fetch.
     */
    where: TakeoffWhereUniqueInput
  }

  /**
   * Takeoff findFirst
   */
  export type TakeoffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    /**
     * Filter, which Takeoff to fetch.
     */
    where?: TakeoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Takeoffs to fetch.
     */
    orderBy?: TakeoffOrderByWithRelationInput | TakeoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Takeoffs.
     */
    cursor?: TakeoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Takeoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Takeoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Takeoffs.
     */
    distinct?: TakeoffScalarFieldEnum | TakeoffScalarFieldEnum[]
  }

  /**
   * Takeoff findFirstOrThrow
   */
  export type TakeoffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    /**
     * Filter, which Takeoff to fetch.
     */
    where?: TakeoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Takeoffs to fetch.
     */
    orderBy?: TakeoffOrderByWithRelationInput | TakeoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Takeoffs.
     */
    cursor?: TakeoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Takeoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Takeoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Takeoffs.
     */
    distinct?: TakeoffScalarFieldEnum | TakeoffScalarFieldEnum[]
  }

  /**
   * Takeoff findMany
   */
  export type TakeoffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    /**
     * Filter, which Takeoffs to fetch.
     */
    where?: TakeoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Takeoffs to fetch.
     */
    orderBy?: TakeoffOrderByWithRelationInput | TakeoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Takeoffs.
     */
    cursor?: TakeoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Takeoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Takeoffs.
     */
    skip?: number
    distinct?: TakeoffScalarFieldEnum | TakeoffScalarFieldEnum[]
  }

  /**
   * Takeoff create
   */
  export type TakeoffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    /**
     * The data needed to create a Takeoff.
     */
    data: XOR<TakeoffCreateInput, TakeoffUncheckedCreateInput>
  }

  /**
   * Takeoff createMany
   */
  export type TakeoffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Takeoffs.
     */
    data: TakeoffCreateManyInput | TakeoffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Takeoff createManyAndReturn
   */
  export type TakeoffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * The data used to create many Takeoffs.
     */
    data: TakeoffCreateManyInput | TakeoffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Takeoff update
   */
  export type TakeoffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    /**
     * The data needed to update a Takeoff.
     */
    data: XOR<TakeoffUpdateInput, TakeoffUncheckedUpdateInput>
    /**
     * Choose, which Takeoff to update.
     */
    where: TakeoffWhereUniqueInput
  }

  /**
   * Takeoff updateMany
   */
  export type TakeoffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Takeoffs.
     */
    data: XOR<TakeoffUpdateManyMutationInput, TakeoffUncheckedUpdateManyInput>
    /**
     * Filter which Takeoffs to update
     */
    where?: TakeoffWhereInput
    /**
     * Limit how many Takeoffs to update.
     */
    limit?: number
  }

  /**
   * Takeoff updateManyAndReturn
   */
  export type TakeoffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * The data used to update Takeoffs.
     */
    data: XOR<TakeoffUpdateManyMutationInput, TakeoffUncheckedUpdateManyInput>
    /**
     * Filter which Takeoffs to update
     */
    where?: TakeoffWhereInput
    /**
     * Limit how many Takeoffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Takeoff upsert
   */
  export type TakeoffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    /**
     * The filter to search for the Takeoff to update in case it exists.
     */
    where: TakeoffWhereUniqueInput
    /**
     * In case the Takeoff found by the `where` argument doesn't exist, create a new Takeoff with this data.
     */
    create: XOR<TakeoffCreateInput, TakeoffUncheckedCreateInput>
    /**
     * In case the Takeoff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TakeoffUpdateInput, TakeoffUncheckedUpdateInput>
  }

  /**
   * Takeoff delete
   */
  export type TakeoffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
    /**
     * Filter which Takeoff to delete.
     */
    where: TakeoffWhereUniqueInput
  }

  /**
   * Takeoff deleteMany
   */
  export type TakeoffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Takeoffs to delete
     */
    where?: TakeoffWhereInput
    /**
     * Limit how many Takeoffs to delete.
     */
    limit?: number
  }

  /**
   * Takeoff.lineItems
   */
  export type Takeoff$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    where?: TakeoffLineItemWhereInput
    orderBy?: TakeoffLineItemOrderByWithRelationInput | TakeoffLineItemOrderByWithRelationInput[]
    cursor?: TakeoffLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TakeoffLineItemScalarFieldEnum | TakeoffLineItemScalarFieldEnum[]
  }

  /**
   * Takeoff.validation
   */
  export type Takeoff$validationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    where?: TakeoffValidationWhereInput
  }

  /**
   * Takeoff without action
   */
  export type TakeoffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Takeoff
     */
    select?: TakeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Takeoff
     */
    omit?: TakeoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffInclude<ExtArgs> | null
  }


  /**
   * Model TakeoffLineItem
   */

  export type AggregateTakeoffLineItem = {
    _count: TakeoffLineItemCountAggregateOutputType | null
    _avg: TakeoffLineItemAvgAggregateOutputType | null
    _sum: TakeoffLineItemSumAggregateOutputType | null
    _min: TakeoffLineItemMinAggregateOutputType | null
    _max: TakeoffLineItemMaxAggregateOutputType | null
  }

  export type TakeoffLineItemAvgAggregateOutputType = {
    quantityEstimated: Decimal | null
    quantityActual: Decimal | null
    unitPrice: Decimal | null
    totalEstimated: Decimal | null
    totalActual: Decimal | null
    variance: Decimal | null
    variancePercent: Decimal | null
  }

  export type TakeoffLineItemSumAggregateOutputType = {
    quantityEstimated: Decimal | null
    quantityActual: Decimal | null
    unitPrice: Decimal | null
    totalEstimated: Decimal | null
    totalActual: Decimal | null
    variance: Decimal | null
    variancePercent: Decimal | null
  }

  export type TakeoffLineItemMinAggregateOutputType = {
    id: string | null
    takeoffId: string | null
    materialId: string | null
    quantityEstimated: Decimal | null
    quantityActual: Decimal | null
    unit: string | null
    unitPrice: Decimal | null
    totalEstimated: Decimal | null
    totalActual: Decimal | null
    variance: Decimal | null
    variancePercent: Decimal | null
    varianceReason: string | null
    category: string | null
    subcategory: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TakeoffLineItemMaxAggregateOutputType = {
    id: string | null
    takeoffId: string | null
    materialId: string | null
    quantityEstimated: Decimal | null
    quantityActual: Decimal | null
    unit: string | null
    unitPrice: Decimal | null
    totalEstimated: Decimal | null
    totalActual: Decimal | null
    variance: Decimal | null
    variancePercent: Decimal | null
    varianceReason: string | null
    category: string | null
    subcategory: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TakeoffLineItemCountAggregateOutputType = {
    id: number
    takeoffId: number
    materialId: number
    quantityEstimated: number
    quantityActual: number
    unit: number
    unitPrice: number
    totalEstimated: number
    totalActual: number
    variance: number
    variancePercent: number
    varianceReason: number
    category: number
    subcategory: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TakeoffLineItemAvgAggregateInputType = {
    quantityEstimated?: true
    quantityActual?: true
    unitPrice?: true
    totalEstimated?: true
    totalActual?: true
    variance?: true
    variancePercent?: true
  }

  export type TakeoffLineItemSumAggregateInputType = {
    quantityEstimated?: true
    quantityActual?: true
    unitPrice?: true
    totalEstimated?: true
    totalActual?: true
    variance?: true
    variancePercent?: true
  }

  export type TakeoffLineItemMinAggregateInputType = {
    id?: true
    takeoffId?: true
    materialId?: true
    quantityEstimated?: true
    quantityActual?: true
    unit?: true
    unitPrice?: true
    totalEstimated?: true
    totalActual?: true
    variance?: true
    variancePercent?: true
    varianceReason?: true
    category?: true
    subcategory?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TakeoffLineItemMaxAggregateInputType = {
    id?: true
    takeoffId?: true
    materialId?: true
    quantityEstimated?: true
    quantityActual?: true
    unit?: true
    unitPrice?: true
    totalEstimated?: true
    totalActual?: true
    variance?: true
    variancePercent?: true
    varianceReason?: true
    category?: true
    subcategory?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TakeoffLineItemCountAggregateInputType = {
    id?: true
    takeoffId?: true
    materialId?: true
    quantityEstimated?: true
    quantityActual?: true
    unit?: true
    unitPrice?: true
    totalEstimated?: true
    totalActual?: true
    variance?: true
    variancePercent?: true
    varianceReason?: true
    category?: true
    subcategory?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TakeoffLineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakeoffLineItem to aggregate.
     */
    where?: TakeoffLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakeoffLineItems to fetch.
     */
    orderBy?: TakeoffLineItemOrderByWithRelationInput | TakeoffLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TakeoffLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakeoffLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakeoffLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TakeoffLineItems
    **/
    _count?: true | TakeoffLineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TakeoffLineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TakeoffLineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TakeoffLineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TakeoffLineItemMaxAggregateInputType
  }

  export type GetTakeoffLineItemAggregateType<T extends TakeoffLineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTakeoffLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTakeoffLineItem[P]>
      : GetScalarType<T[P], AggregateTakeoffLineItem[P]>
  }




  export type TakeoffLineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakeoffLineItemWhereInput
    orderBy?: TakeoffLineItemOrderByWithAggregationInput | TakeoffLineItemOrderByWithAggregationInput[]
    by: TakeoffLineItemScalarFieldEnum[] | TakeoffLineItemScalarFieldEnum
    having?: TakeoffLineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TakeoffLineItemCountAggregateInputType | true
    _avg?: TakeoffLineItemAvgAggregateInputType
    _sum?: TakeoffLineItemSumAggregateInputType
    _min?: TakeoffLineItemMinAggregateInputType
    _max?: TakeoffLineItemMaxAggregateInputType
  }

  export type TakeoffLineItemGroupByOutputType = {
    id: string
    takeoffId: string
    materialId: string
    quantityEstimated: Decimal
    quantityActual: Decimal | null
    unit: string
    unitPrice: Decimal
    totalEstimated: Decimal
    totalActual: Decimal | null
    variance: Decimal | null
    variancePercent: Decimal | null
    varianceReason: string | null
    category: string
    subcategory: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TakeoffLineItemCountAggregateOutputType | null
    _avg: TakeoffLineItemAvgAggregateOutputType | null
    _sum: TakeoffLineItemSumAggregateOutputType | null
    _min: TakeoffLineItemMinAggregateOutputType | null
    _max: TakeoffLineItemMaxAggregateOutputType | null
  }

  type GetTakeoffLineItemGroupByPayload<T extends TakeoffLineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TakeoffLineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TakeoffLineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TakeoffLineItemGroupByOutputType[P]>
            : GetScalarType<T[P], TakeoffLineItemGroupByOutputType[P]>
        }
      >
    >


  export type TakeoffLineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    takeoffId?: boolean
    materialId?: boolean
    quantityEstimated?: boolean
    quantityActual?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalEstimated?: boolean
    totalActual?: boolean
    variance?: boolean
    variancePercent?: boolean
    varianceReason?: boolean
    category?: boolean
    subcategory?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takeoffLineItem"]>

  export type TakeoffLineItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    takeoffId?: boolean
    materialId?: boolean
    quantityEstimated?: boolean
    quantityActual?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalEstimated?: boolean
    totalActual?: boolean
    variance?: boolean
    variancePercent?: boolean
    varianceReason?: boolean
    category?: boolean
    subcategory?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takeoffLineItem"]>

  export type TakeoffLineItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    takeoffId?: boolean
    materialId?: boolean
    quantityEstimated?: boolean
    quantityActual?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalEstimated?: boolean
    totalActual?: boolean
    variance?: boolean
    variancePercent?: boolean
    varianceReason?: boolean
    category?: boolean
    subcategory?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takeoffLineItem"]>

  export type TakeoffLineItemSelectScalar = {
    id?: boolean
    takeoffId?: boolean
    materialId?: boolean
    quantityEstimated?: boolean
    quantityActual?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalEstimated?: boolean
    totalActual?: boolean
    variance?: boolean
    variancePercent?: boolean
    varianceReason?: boolean
    category?: boolean
    subcategory?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TakeoffLineItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "takeoffId" | "materialId" | "quantityEstimated" | "quantityActual" | "unit" | "unitPrice" | "totalEstimated" | "totalActual" | "variance" | "variancePercent" | "varianceReason" | "category" | "subcategory" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["takeoffLineItem"]>
  export type TakeoffLineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type TakeoffLineItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type TakeoffLineItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $TakeoffLineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TakeoffLineItem"
    objects: {
      takeoff: Prisma.$TakeoffPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      takeoffId: string
      materialId: string
      quantityEstimated: Prisma.Decimal
      quantityActual: Prisma.Decimal | null
      unit: string
      unitPrice: Prisma.Decimal
      totalEstimated: Prisma.Decimal
      totalActual: Prisma.Decimal | null
      variance: Prisma.Decimal | null
      variancePercent: Prisma.Decimal | null
      varianceReason: string | null
      category: string
      subcategory: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["takeoffLineItem"]>
    composites: {}
  }

  type TakeoffLineItemGetPayload<S extends boolean | null | undefined | TakeoffLineItemDefaultArgs> = $Result.GetResult<Prisma.$TakeoffLineItemPayload, S>

  type TakeoffLineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TakeoffLineItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TakeoffLineItemCountAggregateInputType | true
    }

  export interface TakeoffLineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TakeoffLineItem'], meta: { name: 'TakeoffLineItem' } }
    /**
     * Find zero or one TakeoffLineItem that matches the filter.
     * @param {TakeoffLineItemFindUniqueArgs} args - Arguments to find a TakeoffLineItem
     * @example
     * // Get one TakeoffLineItem
     * const takeoffLineItem = await prisma.takeoffLineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TakeoffLineItemFindUniqueArgs>(args: SelectSubset<T, TakeoffLineItemFindUniqueArgs<ExtArgs>>): Prisma__TakeoffLineItemClient<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TakeoffLineItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TakeoffLineItemFindUniqueOrThrowArgs} args - Arguments to find a TakeoffLineItem
     * @example
     * // Get one TakeoffLineItem
     * const takeoffLineItem = await prisma.takeoffLineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TakeoffLineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TakeoffLineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TakeoffLineItemClient<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TakeoffLineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffLineItemFindFirstArgs} args - Arguments to find a TakeoffLineItem
     * @example
     * // Get one TakeoffLineItem
     * const takeoffLineItem = await prisma.takeoffLineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TakeoffLineItemFindFirstArgs>(args?: SelectSubset<T, TakeoffLineItemFindFirstArgs<ExtArgs>>): Prisma__TakeoffLineItemClient<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TakeoffLineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffLineItemFindFirstOrThrowArgs} args - Arguments to find a TakeoffLineItem
     * @example
     * // Get one TakeoffLineItem
     * const takeoffLineItem = await prisma.takeoffLineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TakeoffLineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TakeoffLineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TakeoffLineItemClient<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TakeoffLineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffLineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TakeoffLineItems
     * const takeoffLineItems = await prisma.takeoffLineItem.findMany()
     * 
     * // Get first 10 TakeoffLineItems
     * const takeoffLineItems = await prisma.takeoffLineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const takeoffLineItemWithIdOnly = await prisma.takeoffLineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TakeoffLineItemFindManyArgs>(args?: SelectSubset<T, TakeoffLineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TakeoffLineItem.
     * @param {TakeoffLineItemCreateArgs} args - Arguments to create a TakeoffLineItem.
     * @example
     * // Create one TakeoffLineItem
     * const TakeoffLineItem = await prisma.takeoffLineItem.create({
     *   data: {
     *     // ... data to create a TakeoffLineItem
     *   }
     * })
     * 
     */
    create<T extends TakeoffLineItemCreateArgs>(args: SelectSubset<T, TakeoffLineItemCreateArgs<ExtArgs>>): Prisma__TakeoffLineItemClient<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TakeoffLineItems.
     * @param {TakeoffLineItemCreateManyArgs} args - Arguments to create many TakeoffLineItems.
     * @example
     * // Create many TakeoffLineItems
     * const takeoffLineItem = await prisma.takeoffLineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TakeoffLineItemCreateManyArgs>(args?: SelectSubset<T, TakeoffLineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TakeoffLineItems and returns the data saved in the database.
     * @param {TakeoffLineItemCreateManyAndReturnArgs} args - Arguments to create many TakeoffLineItems.
     * @example
     * // Create many TakeoffLineItems
     * const takeoffLineItem = await prisma.takeoffLineItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TakeoffLineItems and only return the `id`
     * const takeoffLineItemWithIdOnly = await prisma.takeoffLineItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TakeoffLineItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TakeoffLineItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TakeoffLineItem.
     * @param {TakeoffLineItemDeleteArgs} args - Arguments to delete one TakeoffLineItem.
     * @example
     * // Delete one TakeoffLineItem
     * const TakeoffLineItem = await prisma.takeoffLineItem.delete({
     *   where: {
     *     // ... filter to delete one TakeoffLineItem
     *   }
     * })
     * 
     */
    delete<T extends TakeoffLineItemDeleteArgs>(args: SelectSubset<T, TakeoffLineItemDeleteArgs<ExtArgs>>): Prisma__TakeoffLineItemClient<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TakeoffLineItem.
     * @param {TakeoffLineItemUpdateArgs} args - Arguments to update one TakeoffLineItem.
     * @example
     * // Update one TakeoffLineItem
     * const takeoffLineItem = await prisma.takeoffLineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TakeoffLineItemUpdateArgs>(args: SelectSubset<T, TakeoffLineItemUpdateArgs<ExtArgs>>): Prisma__TakeoffLineItemClient<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TakeoffLineItems.
     * @param {TakeoffLineItemDeleteManyArgs} args - Arguments to filter TakeoffLineItems to delete.
     * @example
     * // Delete a few TakeoffLineItems
     * const { count } = await prisma.takeoffLineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TakeoffLineItemDeleteManyArgs>(args?: SelectSubset<T, TakeoffLineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TakeoffLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffLineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TakeoffLineItems
     * const takeoffLineItem = await prisma.takeoffLineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TakeoffLineItemUpdateManyArgs>(args: SelectSubset<T, TakeoffLineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TakeoffLineItems and returns the data updated in the database.
     * @param {TakeoffLineItemUpdateManyAndReturnArgs} args - Arguments to update many TakeoffLineItems.
     * @example
     * // Update many TakeoffLineItems
     * const takeoffLineItem = await prisma.takeoffLineItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TakeoffLineItems and only return the `id`
     * const takeoffLineItemWithIdOnly = await prisma.takeoffLineItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TakeoffLineItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TakeoffLineItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TakeoffLineItem.
     * @param {TakeoffLineItemUpsertArgs} args - Arguments to update or create a TakeoffLineItem.
     * @example
     * // Update or create a TakeoffLineItem
     * const takeoffLineItem = await prisma.takeoffLineItem.upsert({
     *   create: {
     *     // ... data to create a TakeoffLineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TakeoffLineItem we want to update
     *   }
     * })
     */
    upsert<T extends TakeoffLineItemUpsertArgs>(args: SelectSubset<T, TakeoffLineItemUpsertArgs<ExtArgs>>): Prisma__TakeoffLineItemClient<$Result.GetResult<Prisma.$TakeoffLineItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TakeoffLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffLineItemCountArgs} args - Arguments to filter TakeoffLineItems to count.
     * @example
     * // Count the number of TakeoffLineItems
     * const count = await prisma.takeoffLineItem.count({
     *   where: {
     *     // ... the filter for the TakeoffLineItems we want to count
     *   }
     * })
    **/
    count<T extends TakeoffLineItemCountArgs>(
      args?: Subset<T, TakeoffLineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TakeoffLineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TakeoffLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffLineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TakeoffLineItemAggregateArgs>(args: Subset<T, TakeoffLineItemAggregateArgs>): Prisma.PrismaPromise<GetTakeoffLineItemAggregateType<T>>

    /**
     * Group by TakeoffLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffLineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TakeoffLineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TakeoffLineItemGroupByArgs['orderBy'] }
        : { orderBy?: TakeoffLineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TakeoffLineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTakeoffLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TakeoffLineItem model
   */
  readonly fields: TakeoffLineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TakeoffLineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TakeoffLineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    takeoff<T extends TakeoffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TakeoffDefaultArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TakeoffLineItem model
   */
  interface TakeoffLineItemFieldRefs {
    readonly id: FieldRef<"TakeoffLineItem", 'String'>
    readonly takeoffId: FieldRef<"TakeoffLineItem", 'String'>
    readonly materialId: FieldRef<"TakeoffLineItem", 'String'>
    readonly quantityEstimated: FieldRef<"TakeoffLineItem", 'Decimal'>
    readonly quantityActual: FieldRef<"TakeoffLineItem", 'Decimal'>
    readonly unit: FieldRef<"TakeoffLineItem", 'String'>
    readonly unitPrice: FieldRef<"TakeoffLineItem", 'Decimal'>
    readonly totalEstimated: FieldRef<"TakeoffLineItem", 'Decimal'>
    readonly totalActual: FieldRef<"TakeoffLineItem", 'Decimal'>
    readonly variance: FieldRef<"TakeoffLineItem", 'Decimal'>
    readonly variancePercent: FieldRef<"TakeoffLineItem", 'Decimal'>
    readonly varianceReason: FieldRef<"TakeoffLineItem", 'String'>
    readonly category: FieldRef<"TakeoffLineItem", 'String'>
    readonly subcategory: FieldRef<"TakeoffLineItem", 'String'>
    readonly notes: FieldRef<"TakeoffLineItem", 'String'>
    readonly createdAt: FieldRef<"TakeoffLineItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TakeoffLineItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TakeoffLineItem findUnique
   */
  export type TakeoffLineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffLineItem to fetch.
     */
    where: TakeoffLineItemWhereUniqueInput
  }

  /**
   * TakeoffLineItem findUniqueOrThrow
   */
  export type TakeoffLineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffLineItem to fetch.
     */
    where: TakeoffLineItemWhereUniqueInput
  }

  /**
   * TakeoffLineItem findFirst
   */
  export type TakeoffLineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffLineItem to fetch.
     */
    where?: TakeoffLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakeoffLineItems to fetch.
     */
    orderBy?: TakeoffLineItemOrderByWithRelationInput | TakeoffLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakeoffLineItems.
     */
    cursor?: TakeoffLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakeoffLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakeoffLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakeoffLineItems.
     */
    distinct?: TakeoffLineItemScalarFieldEnum | TakeoffLineItemScalarFieldEnum[]
  }

  /**
   * TakeoffLineItem findFirstOrThrow
   */
  export type TakeoffLineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffLineItem to fetch.
     */
    where?: TakeoffLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakeoffLineItems to fetch.
     */
    orderBy?: TakeoffLineItemOrderByWithRelationInput | TakeoffLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakeoffLineItems.
     */
    cursor?: TakeoffLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakeoffLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakeoffLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakeoffLineItems.
     */
    distinct?: TakeoffLineItemScalarFieldEnum | TakeoffLineItemScalarFieldEnum[]
  }

  /**
   * TakeoffLineItem findMany
   */
  export type TakeoffLineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffLineItems to fetch.
     */
    where?: TakeoffLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakeoffLineItems to fetch.
     */
    orderBy?: TakeoffLineItemOrderByWithRelationInput | TakeoffLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TakeoffLineItems.
     */
    cursor?: TakeoffLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakeoffLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakeoffLineItems.
     */
    skip?: number
    distinct?: TakeoffLineItemScalarFieldEnum | TakeoffLineItemScalarFieldEnum[]
  }

  /**
   * TakeoffLineItem create
   */
  export type TakeoffLineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TakeoffLineItem.
     */
    data: XOR<TakeoffLineItemCreateInput, TakeoffLineItemUncheckedCreateInput>
  }

  /**
   * TakeoffLineItem createMany
   */
  export type TakeoffLineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TakeoffLineItems.
     */
    data: TakeoffLineItemCreateManyInput | TakeoffLineItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TakeoffLineItem createManyAndReturn
   */
  export type TakeoffLineItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * The data used to create many TakeoffLineItems.
     */
    data: TakeoffLineItemCreateManyInput | TakeoffLineItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TakeoffLineItem update
   */
  export type TakeoffLineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TakeoffLineItem.
     */
    data: XOR<TakeoffLineItemUpdateInput, TakeoffLineItemUncheckedUpdateInput>
    /**
     * Choose, which TakeoffLineItem to update.
     */
    where: TakeoffLineItemWhereUniqueInput
  }

  /**
   * TakeoffLineItem updateMany
   */
  export type TakeoffLineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TakeoffLineItems.
     */
    data: XOR<TakeoffLineItemUpdateManyMutationInput, TakeoffLineItemUncheckedUpdateManyInput>
    /**
     * Filter which TakeoffLineItems to update
     */
    where?: TakeoffLineItemWhereInput
    /**
     * Limit how many TakeoffLineItems to update.
     */
    limit?: number
  }

  /**
   * TakeoffLineItem updateManyAndReturn
   */
  export type TakeoffLineItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * The data used to update TakeoffLineItems.
     */
    data: XOR<TakeoffLineItemUpdateManyMutationInput, TakeoffLineItemUncheckedUpdateManyInput>
    /**
     * Filter which TakeoffLineItems to update
     */
    where?: TakeoffLineItemWhereInput
    /**
     * Limit how many TakeoffLineItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TakeoffLineItem upsert
   */
  export type TakeoffLineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TakeoffLineItem to update in case it exists.
     */
    where: TakeoffLineItemWhereUniqueInput
    /**
     * In case the TakeoffLineItem found by the `where` argument doesn't exist, create a new TakeoffLineItem with this data.
     */
    create: XOR<TakeoffLineItemCreateInput, TakeoffLineItemUncheckedCreateInput>
    /**
     * In case the TakeoffLineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TakeoffLineItemUpdateInput, TakeoffLineItemUncheckedUpdateInput>
  }

  /**
   * TakeoffLineItem delete
   */
  export type TakeoffLineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
    /**
     * Filter which TakeoffLineItem to delete.
     */
    where: TakeoffLineItemWhereUniqueInput
  }

  /**
   * TakeoffLineItem deleteMany
   */
  export type TakeoffLineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakeoffLineItems to delete
     */
    where?: TakeoffLineItemWhereInput
    /**
     * Limit how many TakeoffLineItems to delete.
     */
    limit?: number
  }

  /**
   * TakeoffLineItem without action
   */
  export type TakeoffLineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffLineItem
     */
    select?: TakeoffLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffLineItem
     */
    omit?: TakeoffLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffLineItemInclude<ExtArgs> | null
  }


  /**
   * Model TakeoffValidation
   */

  export type AggregateTakeoffValidation = {
    _count: TakeoffValidationCountAggregateOutputType | null
    _avg: TakeoffValidationAvgAggregateOutputType | null
    _sum: TakeoffValidationSumAggregateOutputType | null
    _min: TakeoffValidationMinAggregateOutputType | null
    _max: TakeoffValidationMaxAggregateOutputType | null
  }

  export type TakeoffValidationAvgAggregateOutputType = {
    avgVariance: Decimal | null
  }

  export type TakeoffValidationSumAggregateOutputType = {
    avgVariance: Decimal | null
  }

  export type TakeoffValidationMinAggregateOutputType = {
    id: string | null
    takeoffId: string | null
    specCompliant: boolean | null
    pricingCurrent: boolean | null
    varianceAcceptable: boolean | null
    avgVariance: Decimal | null
    validatedAt: Date | null
  }

  export type TakeoffValidationMaxAggregateOutputType = {
    id: string | null
    takeoffId: string | null
    specCompliant: boolean | null
    pricingCurrent: boolean | null
    varianceAcceptable: boolean | null
    avgVariance: Decimal | null
    validatedAt: Date | null
  }

  export type TakeoffValidationCountAggregateOutputType = {
    id: number
    takeoffId: number
    specCompliant: number
    pricingCurrent: number
    varianceAcceptable: number
    issues: number
    warnings: number
    comparedToJobs: number
    avgVariance: number
    validatedAt: number
    _all: number
  }


  export type TakeoffValidationAvgAggregateInputType = {
    avgVariance?: true
  }

  export type TakeoffValidationSumAggregateInputType = {
    avgVariance?: true
  }

  export type TakeoffValidationMinAggregateInputType = {
    id?: true
    takeoffId?: true
    specCompliant?: true
    pricingCurrent?: true
    varianceAcceptable?: true
    avgVariance?: true
    validatedAt?: true
  }

  export type TakeoffValidationMaxAggregateInputType = {
    id?: true
    takeoffId?: true
    specCompliant?: true
    pricingCurrent?: true
    varianceAcceptable?: true
    avgVariance?: true
    validatedAt?: true
  }

  export type TakeoffValidationCountAggregateInputType = {
    id?: true
    takeoffId?: true
    specCompliant?: true
    pricingCurrent?: true
    varianceAcceptable?: true
    issues?: true
    warnings?: true
    comparedToJobs?: true
    avgVariance?: true
    validatedAt?: true
    _all?: true
  }

  export type TakeoffValidationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakeoffValidation to aggregate.
     */
    where?: TakeoffValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakeoffValidations to fetch.
     */
    orderBy?: TakeoffValidationOrderByWithRelationInput | TakeoffValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TakeoffValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakeoffValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakeoffValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TakeoffValidations
    **/
    _count?: true | TakeoffValidationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TakeoffValidationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TakeoffValidationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TakeoffValidationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TakeoffValidationMaxAggregateInputType
  }

  export type GetTakeoffValidationAggregateType<T extends TakeoffValidationAggregateArgs> = {
        [P in keyof T & keyof AggregateTakeoffValidation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTakeoffValidation[P]>
      : GetScalarType<T[P], AggregateTakeoffValidation[P]>
  }




  export type TakeoffValidationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakeoffValidationWhereInput
    orderBy?: TakeoffValidationOrderByWithAggregationInput | TakeoffValidationOrderByWithAggregationInput[]
    by: TakeoffValidationScalarFieldEnum[] | TakeoffValidationScalarFieldEnum
    having?: TakeoffValidationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TakeoffValidationCountAggregateInputType | true
    _avg?: TakeoffValidationAvgAggregateInputType
    _sum?: TakeoffValidationSumAggregateInputType
    _min?: TakeoffValidationMinAggregateInputType
    _max?: TakeoffValidationMaxAggregateInputType
  }

  export type TakeoffValidationGroupByOutputType = {
    id: string
    takeoffId: string
    specCompliant: boolean
    pricingCurrent: boolean
    varianceAcceptable: boolean
    issues: JsonValue
    warnings: JsonValue
    comparedToJobs: string[]
    avgVariance: Decimal | null
    validatedAt: Date
    _count: TakeoffValidationCountAggregateOutputType | null
    _avg: TakeoffValidationAvgAggregateOutputType | null
    _sum: TakeoffValidationSumAggregateOutputType | null
    _min: TakeoffValidationMinAggregateOutputType | null
    _max: TakeoffValidationMaxAggregateOutputType | null
  }

  type GetTakeoffValidationGroupByPayload<T extends TakeoffValidationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TakeoffValidationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TakeoffValidationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TakeoffValidationGroupByOutputType[P]>
            : GetScalarType<T[P], TakeoffValidationGroupByOutputType[P]>
        }
      >
    >


  export type TakeoffValidationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    takeoffId?: boolean
    specCompliant?: boolean
    pricingCurrent?: boolean
    varianceAcceptable?: boolean
    issues?: boolean
    warnings?: boolean
    comparedToJobs?: boolean
    avgVariance?: boolean
    validatedAt?: boolean
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takeoffValidation"]>

  export type TakeoffValidationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    takeoffId?: boolean
    specCompliant?: boolean
    pricingCurrent?: boolean
    varianceAcceptable?: boolean
    issues?: boolean
    warnings?: boolean
    comparedToJobs?: boolean
    avgVariance?: boolean
    validatedAt?: boolean
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takeoffValidation"]>

  export type TakeoffValidationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    takeoffId?: boolean
    specCompliant?: boolean
    pricingCurrent?: boolean
    varianceAcceptable?: boolean
    issues?: boolean
    warnings?: boolean
    comparedToJobs?: boolean
    avgVariance?: boolean
    validatedAt?: boolean
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takeoffValidation"]>

  export type TakeoffValidationSelectScalar = {
    id?: boolean
    takeoffId?: boolean
    specCompliant?: boolean
    pricingCurrent?: boolean
    varianceAcceptable?: boolean
    issues?: boolean
    warnings?: boolean
    comparedToJobs?: boolean
    avgVariance?: boolean
    validatedAt?: boolean
  }

  export type TakeoffValidationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "takeoffId" | "specCompliant" | "pricingCurrent" | "varianceAcceptable" | "issues" | "warnings" | "comparedToJobs" | "avgVariance" | "validatedAt", ExtArgs["result"]["takeoffValidation"]>
  export type TakeoffValidationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
  }
  export type TakeoffValidationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
  }
  export type TakeoffValidationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    takeoff?: boolean | TakeoffDefaultArgs<ExtArgs>
  }

  export type $TakeoffValidationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TakeoffValidation"
    objects: {
      takeoff: Prisma.$TakeoffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      takeoffId: string
      specCompliant: boolean
      pricingCurrent: boolean
      varianceAcceptable: boolean
      issues: Prisma.JsonValue
      warnings: Prisma.JsonValue
      comparedToJobs: string[]
      avgVariance: Prisma.Decimal | null
      validatedAt: Date
    }, ExtArgs["result"]["takeoffValidation"]>
    composites: {}
  }

  type TakeoffValidationGetPayload<S extends boolean | null | undefined | TakeoffValidationDefaultArgs> = $Result.GetResult<Prisma.$TakeoffValidationPayload, S>

  type TakeoffValidationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TakeoffValidationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TakeoffValidationCountAggregateInputType | true
    }

  export interface TakeoffValidationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TakeoffValidation'], meta: { name: 'TakeoffValidation' } }
    /**
     * Find zero or one TakeoffValidation that matches the filter.
     * @param {TakeoffValidationFindUniqueArgs} args - Arguments to find a TakeoffValidation
     * @example
     * // Get one TakeoffValidation
     * const takeoffValidation = await prisma.takeoffValidation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TakeoffValidationFindUniqueArgs>(args: SelectSubset<T, TakeoffValidationFindUniqueArgs<ExtArgs>>): Prisma__TakeoffValidationClient<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TakeoffValidation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TakeoffValidationFindUniqueOrThrowArgs} args - Arguments to find a TakeoffValidation
     * @example
     * // Get one TakeoffValidation
     * const takeoffValidation = await prisma.takeoffValidation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TakeoffValidationFindUniqueOrThrowArgs>(args: SelectSubset<T, TakeoffValidationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TakeoffValidationClient<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TakeoffValidation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffValidationFindFirstArgs} args - Arguments to find a TakeoffValidation
     * @example
     * // Get one TakeoffValidation
     * const takeoffValidation = await prisma.takeoffValidation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TakeoffValidationFindFirstArgs>(args?: SelectSubset<T, TakeoffValidationFindFirstArgs<ExtArgs>>): Prisma__TakeoffValidationClient<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TakeoffValidation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffValidationFindFirstOrThrowArgs} args - Arguments to find a TakeoffValidation
     * @example
     * // Get one TakeoffValidation
     * const takeoffValidation = await prisma.takeoffValidation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TakeoffValidationFindFirstOrThrowArgs>(args?: SelectSubset<T, TakeoffValidationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TakeoffValidationClient<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TakeoffValidations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffValidationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TakeoffValidations
     * const takeoffValidations = await prisma.takeoffValidation.findMany()
     * 
     * // Get first 10 TakeoffValidations
     * const takeoffValidations = await prisma.takeoffValidation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const takeoffValidationWithIdOnly = await prisma.takeoffValidation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TakeoffValidationFindManyArgs>(args?: SelectSubset<T, TakeoffValidationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TakeoffValidation.
     * @param {TakeoffValidationCreateArgs} args - Arguments to create a TakeoffValidation.
     * @example
     * // Create one TakeoffValidation
     * const TakeoffValidation = await prisma.takeoffValidation.create({
     *   data: {
     *     // ... data to create a TakeoffValidation
     *   }
     * })
     * 
     */
    create<T extends TakeoffValidationCreateArgs>(args: SelectSubset<T, TakeoffValidationCreateArgs<ExtArgs>>): Prisma__TakeoffValidationClient<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TakeoffValidations.
     * @param {TakeoffValidationCreateManyArgs} args - Arguments to create many TakeoffValidations.
     * @example
     * // Create many TakeoffValidations
     * const takeoffValidation = await prisma.takeoffValidation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TakeoffValidationCreateManyArgs>(args?: SelectSubset<T, TakeoffValidationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TakeoffValidations and returns the data saved in the database.
     * @param {TakeoffValidationCreateManyAndReturnArgs} args - Arguments to create many TakeoffValidations.
     * @example
     * // Create many TakeoffValidations
     * const takeoffValidation = await prisma.takeoffValidation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TakeoffValidations and only return the `id`
     * const takeoffValidationWithIdOnly = await prisma.takeoffValidation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TakeoffValidationCreateManyAndReturnArgs>(args?: SelectSubset<T, TakeoffValidationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TakeoffValidation.
     * @param {TakeoffValidationDeleteArgs} args - Arguments to delete one TakeoffValidation.
     * @example
     * // Delete one TakeoffValidation
     * const TakeoffValidation = await prisma.takeoffValidation.delete({
     *   where: {
     *     // ... filter to delete one TakeoffValidation
     *   }
     * })
     * 
     */
    delete<T extends TakeoffValidationDeleteArgs>(args: SelectSubset<T, TakeoffValidationDeleteArgs<ExtArgs>>): Prisma__TakeoffValidationClient<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TakeoffValidation.
     * @param {TakeoffValidationUpdateArgs} args - Arguments to update one TakeoffValidation.
     * @example
     * // Update one TakeoffValidation
     * const takeoffValidation = await prisma.takeoffValidation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TakeoffValidationUpdateArgs>(args: SelectSubset<T, TakeoffValidationUpdateArgs<ExtArgs>>): Prisma__TakeoffValidationClient<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TakeoffValidations.
     * @param {TakeoffValidationDeleteManyArgs} args - Arguments to filter TakeoffValidations to delete.
     * @example
     * // Delete a few TakeoffValidations
     * const { count } = await prisma.takeoffValidation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TakeoffValidationDeleteManyArgs>(args?: SelectSubset<T, TakeoffValidationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TakeoffValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffValidationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TakeoffValidations
     * const takeoffValidation = await prisma.takeoffValidation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TakeoffValidationUpdateManyArgs>(args: SelectSubset<T, TakeoffValidationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TakeoffValidations and returns the data updated in the database.
     * @param {TakeoffValidationUpdateManyAndReturnArgs} args - Arguments to update many TakeoffValidations.
     * @example
     * // Update many TakeoffValidations
     * const takeoffValidation = await prisma.takeoffValidation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TakeoffValidations and only return the `id`
     * const takeoffValidationWithIdOnly = await prisma.takeoffValidation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TakeoffValidationUpdateManyAndReturnArgs>(args: SelectSubset<T, TakeoffValidationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TakeoffValidation.
     * @param {TakeoffValidationUpsertArgs} args - Arguments to update or create a TakeoffValidation.
     * @example
     * // Update or create a TakeoffValidation
     * const takeoffValidation = await prisma.takeoffValidation.upsert({
     *   create: {
     *     // ... data to create a TakeoffValidation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TakeoffValidation we want to update
     *   }
     * })
     */
    upsert<T extends TakeoffValidationUpsertArgs>(args: SelectSubset<T, TakeoffValidationUpsertArgs<ExtArgs>>): Prisma__TakeoffValidationClient<$Result.GetResult<Prisma.$TakeoffValidationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TakeoffValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffValidationCountArgs} args - Arguments to filter TakeoffValidations to count.
     * @example
     * // Count the number of TakeoffValidations
     * const count = await prisma.takeoffValidation.count({
     *   where: {
     *     // ... the filter for the TakeoffValidations we want to count
     *   }
     * })
    **/
    count<T extends TakeoffValidationCountArgs>(
      args?: Subset<T, TakeoffValidationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TakeoffValidationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TakeoffValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffValidationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TakeoffValidationAggregateArgs>(args: Subset<T, TakeoffValidationAggregateArgs>): Prisma.PrismaPromise<GetTakeoffValidationAggregateType<T>>

    /**
     * Group by TakeoffValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakeoffValidationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TakeoffValidationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TakeoffValidationGroupByArgs['orderBy'] }
        : { orderBy?: TakeoffValidationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TakeoffValidationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTakeoffValidationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TakeoffValidation model
   */
  readonly fields: TakeoffValidationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TakeoffValidation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TakeoffValidationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    takeoff<T extends TakeoffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TakeoffDefaultArgs<ExtArgs>>): Prisma__TakeoffClient<$Result.GetResult<Prisma.$TakeoffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TakeoffValidation model
   */
  interface TakeoffValidationFieldRefs {
    readonly id: FieldRef<"TakeoffValidation", 'String'>
    readonly takeoffId: FieldRef<"TakeoffValidation", 'String'>
    readonly specCompliant: FieldRef<"TakeoffValidation", 'Boolean'>
    readonly pricingCurrent: FieldRef<"TakeoffValidation", 'Boolean'>
    readonly varianceAcceptable: FieldRef<"TakeoffValidation", 'Boolean'>
    readonly issues: FieldRef<"TakeoffValidation", 'Json'>
    readonly warnings: FieldRef<"TakeoffValidation", 'Json'>
    readonly comparedToJobs: FieldRef<"TakeoffValidation", 'String[]'>
    readonly avgVariance: FieldRef<"TakeoffValidation", 'Decimal'>
    readonly validatedAt: FieldRef<"TakeoffValidation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TakeoffValidation findUnique
   */
  export type TakeoffValidationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffValidation to fetch.
     */
    where: TakeoffValidationWhereUniqueInput
  }

  /**
   * TakeoffValidation findUniqueOrThrow
   */
  export type TakeoffValidationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffValidation to fetch.
     */
    where: TakeoffValidationWhereUniqueInput
  }

  /**
   * TakeoffValidation findFirst
   */
  export type TakeoffValidationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffValidation to fetch.
     */
    where?: TakeoffValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakeoffValidations to fetch.
     */
    orderBy?: TakeoffValidationOrderByWithRelationInput | TakeoffValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakeoffValidations.
     */
    cursor?: TakeoffValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakeoffValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakeoffValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakeoffValidations.
     */
    distinct?: TakeoffValidationScalarFieldEnum | TakeoffValidationScalarFieldEnum[]
  }

  /**
   * TakeoffValidation findFirstOrThrow
   */
  export type TakeoffValidationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffValidation to fetch.
     */
    where?: TakeoffValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakeoffValidations to fetch.
     */
    orderBy?: TakeoffValidationOrderByWithRelationInput | TakeoffValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakeoffValidations.
     */
    cursor?: TakeoffValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakeoffValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakeoffValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakeoffValidations.
     */
    distinct?: TakeoffValidationScalarFieldEnum | TakeoffValidationScalarFieldEnum[]
  }

  /**
   * TakeoffValidation findMany
   */
  export type TakeoffValidationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    /**
     * Filter, which TakeoffValidations to fetch.
     */
    where?: TakeoffValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakeoffValidations to fetch.
     */
    orderBy?: TakeoffValidationOrderByWithRelationInput | TakeoffValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TakeoffValidations.
     */
    cursor?: TakeoffValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakeoffValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakeoffValidations.
     */
    skip?: number
    distinct?: TakeoffValidationScalarFieldEnum | TakeoffValidationScalarFieldEnum[]
  }

  /**
   * TakeoffValidation create
   */
  export type TakeoffValidationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    /**
     * The data needed to create a TakeoffValidation.
     */
    data: XOR<TakeoffValidationCreateInput, TakeoffValidationUncheckedCreateInput>
  }

  /**
   * TakeoffValidation createMany
   */
  export type TakeoffValidationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TakeoffValidations.
     */
    data: TakeoffValidationCreateManyInput | TakeoffValidationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TakeoffValidation createManyAndReturn
   */
  export type TakeoffValidationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * The data used to create many TakeoffValidations.
     */
    data: TakeoffValidationCreateManyInput | TakeoffValidationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TakeoffValidation update
   */
  export type TakeoffValidationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    /**
     * The data needed to update a TakeoffValidation.
     */
    data: XOR<TakeoffValidationUpdateInput, TakeoffValidationUncheckedUpdateInput>
    /**
     * Choose, which TakeoffValidation to update.
     */
    where: TakeoffValidationWhereUniqueInput
  }

  /**
   * TakeoffValidation updateMany
   */
  export type TakeoffValidationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TakeoffValidations.
     */
    data: XOR<TakeoffValidationUpdateManyMutationInput, TakeoffValidationUncheckedUpdateManyInput>
    /**
     * Filter which TakeoffValidations to update
     */
    where?: TakeoffValidationWhereInput
    /**
     * Limit how many TakeoffValidations to update.
     */
    limit?: number
  }

  /**
   * TakeoffValidation updateManyAndReturn
   */
  export type TakeoffValidationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * The data used to update TakeoffValidations.
     */
    data: XOR<TakeoffValidationUpdateManyMutationInput, TakeoffValidationUncheckedUpdateManyInput>
    /**
     * Filter which TakeoffValidations to update
     */
    where?: TakeoffValidationWhereInput
    /**
     * Limit how many TakeoffValidations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TakeoffValidation upsert
   */
  export type TakeoffValidationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    /**
     * The filter to search for the TakeoffValidation to update in case it exists.
     */
    where: TakeoffValidationWhereUniqueInput
    /**
     * In case the TakeoffValidation found by the `where` argument doesn't exist, create a new TakeoffValidation with this data.
     */
    create: XOR<TakeoffValidationCreateInput, TakeoffValidationUncheckedCreateInput>
    /**
     * In case the TakeoffValidation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TakeoffValidationUpdateInput, TakeoffValidationUncheckedUpdateInput>
  }

  /**
   * TakeoffValidation delete
   */
  export type TakeoffValidationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
    /**
     * Filter which TakeoffValidation to delete.
     */
    where: TakeoffValidationWhereUniqueInput
  }

  /**
   * TakeoffValidation deleteMany
   */
  export type TakeoffValidationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakeoffValidations to delete
     */
    where?: TakeoffValidationWhereInput
    /**
     * Limit how many TakeoffValidations to delete.
     */
    limit?: number
  }

  /**
   * TakeoffValidation without action
   */
  export type TakeoffValidationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakeoffValidation
     */
    select?: TakeoffValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakeoffValidation
     */
    omit?: TakeoffValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakeoffValidationInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    poNumber: string | null
    jobId: string | null
    vendorId: string | null
    status: $Enums.POStatus | null
    totalAmount: Decimal | null
    approvedAt: Date | null
    sentAt: Date | null
    confirmedAt: Date | null
    deliveredAt: Date | null
    scheduledDelivery: Date | null
    actualDelivery: Date | null
    deliveryNotes: string | null
    hyphenBuildProId: string | null
    holtPortalId: string | null
    signatureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    poNumber: string | null
    jobId: string | null
    vendorId: string | null
    status: $Enums.POStatus | null
    totalAmount: Decimal | null
    approvedAt: Date | null
    sentAt: Date | null
    confirmedAt: Date | null
    deliveredAt: Date | null
    scheduledDelivery: Date | null
    actualDelivery: Date | null
    deliveryNotes: string | null
    hyphenBuildProId: string | null
    holtPortalId: string | null
    signatureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    poNumber: number
    jobId: number
    vendorId: number
    status: number
    totalAmount: number
    approvedAt: number
    sentAt: number
    confirmedAt: number
    deliveredAt: number
    scheduledDelivery: number
    actualDelivery: number
    deliveryNotes: number
    hyphenBuildProId: number
    holtPortalId: number
    signatureUrl: number
    photoUrls: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    totalAmount?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    totalAmount?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    poNumber?: true
    jobId?: true
    vendorId?: true
    status?: true
    totalAmount?: true
    approvedAt?: true
    sentAt?: true
    confirmedAt?: true
    deliveredAt?: true
    scheduledDelivery?: true
    actualDelivery?: true
    deliveryNotes?: true
    hyphenBuildProId?: true
    holtPortalId?: true
    signatureUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    poNumber?: true
    jobId?: true
    vendorId?: true
    status?: true
    totalAmount?: true
    approvedAt?: true
    sentAt?: true
    confirmedAt?: true
    deliveredAt?: true
    scheduledDelivery?: true
    actualDelivery?: true
    deliveryNotes?: true
    hyphenBuildProId?: true
    holtPortalId?: true
    signatureUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    poNumber?: true
    jobId?: true
    vendorId?: true
    status?: true
    totalAmount?: true
    approvedAt?: true
    sentAt?: true
    confirmedAt?: true
    deliveredAt?: true
    scheduledDelivery?: true
    actualDelivery?: true
    deliveryNotes?: true
    hyphenBuildProId?: true
    holtPortalId?: true
    signatureUrl?: true
    photoUrls?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    poNumber: string
    jobId: string
    vendorId: string | null
    status: $Enums.POStatus
    totalAmount: Decimal
    approvedAt: Date | null
    sentAt: Date | null
    confirmedAt: Date | null
    deliveredAt: Date | null
    scheduledDelivery: Date | null
    actualDelivery: Date | null
    deliveryNotes: string | null
    hyphenBuildProId: string | null
    holtPortalId: string | null
    signatureUrl: string | null
    photoUrls: string[]
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poNumber?: boolean
    jobId?: boolean
    vendorId?: boolean
    status?: boolean
    totalAmount?: boolean
    approvedAt?: boolean
    sentAt?: boolean
    confirmedAt?: boolean
    deliveredAt?: boolean
    scheduledDelivery?: boolean
    actualDelivery?: boolean
    deliveryNotes?: boolean
    hyphenBuildProId?: boolean
    holtPortalId?: boolean
    signatureUrl?: boolean
    photoUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | PurchaseOrder$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poNumber?: boolean
    jobId?: boolean
    vendorId?: boolean
    status?: boolean
    totalAmount?: boolean
    approvedAt?: boolean
    sentAt?: boolean
    confirmedAt?: boolean
    deliveredAt?: boolean
    scheduledDelivery?: boolean
    actualDelivery?: boolean
    deliveryNotes?: boolean
    hyphenBuildProId?: boolean
    holtPortalId?: boolean
    signatureUrl?: boolean
    photoUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | PurchaseOrder$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poNumber?: boolean
    jobId?: boolean
    vendorId?: boolean
    status?: boolean
    totalAmount?: boolean
    approvedAt?: boolean
    sentAt?: boolean
    confirmedAt?: boolean
    deliveredAt?: boolean
    scheduledDelivery?: boolean
    actualDelivery?: boolean
    deliveryNotes?: boolean
    hyphenBuildProId?: boolean
    holtPortalId?: boolean
    signatureUrl?: boolean
    photoUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | PurchaseOrder$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    poNumber?: boolean
    jobId?: boolean
    vendorId?: boolean
    status?: boolean
    totalAmount?: boolean
    approvedAt?: boolean
    sentAt?: boolean
    confirmedAt?: boolean
    deliveredAt?: boolean
    scheduledDelivery?: boolean
    actualDelivery?: boolean
    deliveryNotes?: boolean
    hyphenBuildProId?: boolean
    holtPortalId?: boolean
    signatureUrl?: boolean
    photoUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poNumber" | "jobId" | "vendorId" | "status" | "totalAmount" | "approvedAt" | "sentAt" | "confirmedAt" | "deliveredAt" | "scheduledDelivery" | "actualDelivery" | "deliveryNotes" | "hyphenBuildProId" | "holtPortalId" | "signatureUrl" | "photoUrls" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | PurchaseOrder$vendorArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | PurchaseOrder$vendorArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | PurchaseOrder$vendorArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      poNumber: string
      jobId: string
      vendorId: string | null
      status: $Enums.POStatus
      totalAmount: Prisma.Decimal
      approvedAt: Date | null
      sentAt: Date | null
      confirmedAt: Date | null
      deliveredAt: Date | null
      scheduledDelivery: Date | null
      actualDelivery: Date | null
      deliveryNotes: string | null
      hyphenBuildProId: string | null
      holtPortalId: string | null
      signatureUrl: string | null
      photoUrls: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends PurchaseOrder$vendorArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly poNumber: FieldRef<"PurchaseOrder", 'String'>
    readonly jobId: FieldRef<"PurchaseOrder", 'String'>
    readonly vendorId: FieldRef<"PurchaseOrder", 'String'>
    readonly status: FieldRef<"PurchaseOrder", 'POStatus'>
    readonly totalAmount: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly approvedAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly sentAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly confirmedAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly deliveredAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly scheduledDelivery: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly actualDelivery: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly deliveryNotes: FieldRef<"PurchaseOrder", 'String'>
    readonly hyphenBuildProId: FieldRef<"PurchaseOrder", 'String'>
    readonly holtPortalId: FieldRef<"PurchaseOrder", 'String'>
    readonly signatureUrl: FieldRef<"PurchaseOrder", 'String'>
    readonly photoUrls: FieldRef<"PurchaseOrder", 'String[]'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.vendor
   */
  export type PurchaseOrder$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model VariancePattern
   */

  export type AggregateVariancePattern = {
    _count: VariancePatternCountAggregateOutputType | null
    _avg: VariancePatternAvgAggregateOutputType | null
    _sum: VariancePatternSumAggregateOutputType | null
    _min: VariancePatternMinAggregateOutputType | null
    _max: VariancePatternMaxAggregateOutputType | null
  }

  export type VariancePatternAvgAggregateOutputType = {
    sampleSize: number | null
    avgVariance: Decimal | null
    stdDeviation: Decimal | null
    confidenceScore: Decimal | null
    recommendedAdjustment: Decimal | null
  }

  export type VariancePatternSumAggregateOutputType = {
    sampleSize: number | null
    avgVariance: Decimal | null
    stdDeviation: Decimal | null
    confidenceScore: Decimal | null
    recommendedAdjustment: Decimal | null
  }

  export type VariancePatternMinAggregateOutputType = {
    id: string | null
    scope: $Enums.VarianceScope | null
    planId: string | null
    communityId: string | null
    customerId: string | null
    region: string | null
    materialCategory: string | null
    subcategory: string | null
    sampleSize: number | null
    avgVariance: Decimal | null
    stdDeviation: Decimal | null
    confidenceScore: Decimal | null
    recommendedAdjustment: Decimal | null
    reasoning: string | null
    status: $Enums.PatternStatus | null
    reviewedAt: Date | null
    appliedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariancePatternMaxAggregateOutputType = {
    id: string | null
    scope: $Enums.VarianceScope | null
    planId: string | null
    communityId: string | null
    customerId: string | null
    region: string | null
    materialCategory: string | null
    subcategory: string | null
    sampleSize: number | null
    avgVariance: Decimal | null
    stdDeviation: Decimal | null
    confidenceScore: Decimal | null
    recommendedAdjustment: Decimal | null
    reasoning: string | null
    status: $Enums.PatternStatus | null
    reviewedAt: Date | null
    appliedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariancePatternCountAggregateOutputType = {
    id: number
    scope: number
    planId: number
    communityId: number
    customerId: number
    region: number
    materialCategory: number
    subcategory: number
    sampleSize: number
    avgVariance: number
    stdDeviation: number
    confidenceScore: number
    recommendedAdjustment: number
    reasoning: number
    status: number
    reviewedAt: number
    appliedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VariancePatternAvgAggregateInputType = {
    sampleSize?: true
    avgVariance?: true
    stdDeviation?: true
    confidenceScore?: true
    recommendedAdjustment?: true
  }

  export type VariancePatternSumAggregateInputType = {
    sampleSize?: true
    avgVariance?: true
    stdDeviation?: true
    confidenceScore?: true
    recommendedAdjustment?: true
  }

  export type VariancePatternMinAggregateInputType = {
    id?: true
    scope?: true
    planId?: true
    communityId?: true
    customerId?: true
    region?: true
    materialCategory?: true
    subcategory?: true
    sampleSize?: true
    avgVariance?: true
    stdDeviation?: true
    confidenceScore?: true
    recommendedAdjustment?: true
    reasoning?: true
    status?: true
    reviewedAt?: true
    appliedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariancePatternMaxAggregateInputType = {
    id?: true
    scope?: true
    planId?: true
    communityId?: true
    customerId?: true
    region?: true
    materialCategory?: true
    subcategory?: true
    sampleSize?: true
    avgVariance?: true
    stdDeviation?: true
    confidenceScore?: true
    recommendedAdjustment?: true
    reasoning?: true
    status?: true
    reviewedAt?: true
    appliedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariancePatternCountAggregateInputType = {
    id?: true
    scope?: true
    planId?: true
    communityId?: true
    customerId?: true
    region?: true
    materialCategory?: true
    subcategory?: true
    sampleSize?: true
    avgVariance?: true
    stdDeviation?: true
    confidenceScore?: true
    recommendedAdjustment?: true
    reasoning?: true
    status?: true
    reviewedAt?: true
    appliedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VariancePatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariancePattern to aggregate.
     */
    where?: VariancePatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariancePatterns to fetch.
     */
    orderBy?: VariancePatternOrderByWithRelationInput | VariancePatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariancePatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariancePatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariancePatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VariancePatterns
    **/
    _count?: true | VariancePatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariancePatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariancePatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariancePatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariancePatternMaxAggregateInputType
  }

  export type GetVariancePatternAggregateType<T extends VariancePatternAggregateArgs> = {
        [P in keyof T & keyof AggregateVariancePattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariancePattern[P]>
      : GetScalarType<T[P], AggregateVariancePattern[P]>
  }




  export type VariancePatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariancePatternWhereInput
    orderBy?: VariancePatternOrderByWithAggregationInput | VariancePatternOrderByWithAggregationInput[]
    by: VariancePatternScalarFieldEnum[] | VariancePatternScalarFieldEnum
    having?: VariancePatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariancePatternCountAggregateInputType | true
    _avg?: VariancePatternAvgAggregateInputType
    _sum?: VariancePatternSumAggregateInputType
    _min?: VariancePatternMinAggregateInputType
    _max?: VariancePatternMaxAggregateInputType
  }

  export type VariancePatternGroupByOutputType = {
    id: string
    scope: $Enums.VarianceScope
    planId: string | null
    communityId: string | null
    customerId: string | null
    region: string | null
    materialCategory: string
    subcategory: string | null
    sampleSize: number
    avgVariance: Decimal
    stdDeviation: Decimal
    confidenceScore: Decimal
    recommendedAdjustment: Decimal | null
    reasoning: string | null
    status: $Enums.PatternStatus
    reviewedAt: Date | null
    appliedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VariancePatternCountAggregateOutputType | null
    _avg: VariancePatternAvgAggregateOutputType | null
    _sum: VariancePatternSumAggregateOutputType | null
    _min: VariancePatternMinAggregateOutputType | null
    _max: VariancePatternMaxAggregateOutputType | null
  }

  type GetVariancePatternGroupByPayload<T extends VariancePatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariancePatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariancePatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariancePatternGroupByOutputType[P]>
            : GetScalarType<T[P], VariancePatternGroupByOutputType[P]>
        }
      >
    >


  export type VariancePatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scope?: boolean
    planId?: boolean
    communityId?: boolean
    customerId?: boolean
    region?: boolean
    materialCategory?: boolean
    subcategory?: boolean
    sampleSize?: boolean
    avgVariance?: boolean
    stdDeviation?: boolean
    confidenceScore?: boolean
    recommendedAdjustment?: boolean
    reasoning?: boolean
    status?: boolean
    reviewedAt?: boolean
    appliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | VariancePattern$planArgs<ExtArgs>
    community?: boolean | VariancePattern$communityArgs<ExtArgs>
    customer?: boolean | VariancePattern$customerArgs<ExtArgs>
    reviews?: boolean | VariancePattern$reviewsArgs<ExtArgs>
    _count?: boolean | VariancePatternCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variancePattern"]>

  export type VariancePatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scope?: boolean
    planId?: boolean
    communityId?: boolean
    customerId?: boolean
    region?: boolean
    materialCategory?: boolean
    subcategory?: boolean
    sampleSize?: boolean
    avgVariance?: boolean
    stdDeviation?: boolean
    confidenceScore?: boolean
    recommendedAdjustment?: boolean
    reasoning?: boolean
    status?: boolean
    reviewedAt?: boolean
    appliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | VariancePattern$planArgs<ExtArgs>
    community?: boolean | VariancePattern$communityArgs<ExtArgs>
    customer?: boolean | VariancePattern$customerArgs<ExtArgs>
  }, ExtArgs["result"]["variancePattern"]>

  export type VariancePatternSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scope?: boolean
    planId?: boolean
    communityId?: boolean
    customerId?: boolean
    region?: boolean
    materialCategory?: boolean
    subcategory?: boolean
    sampleSize?: boolean
    avgVariance?: boolean
    stdDeviation?: boolean
    confidenceScore?: boolean
    recommendedAdjustment?: boolean
    reasoning?: boolean
    status?: boolean
    reviewedAt?: boolean
    appliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | VariancePattern$planArgs<ExtArgs>
    community?: boolean | VariancePattern$communityArgs<ExtArgs>
    customer?: boolean | VariancePattern$customerArgs<ExtArgs>
  }, ExtArgs["result"]["variancePattern"]>

  export type VariancePatternSelectScalar = {
    id?: boolean
    scope?: boolean
    planId?: boolean
    communityId?: boolean
    customerId?: boolean
    region?: boolean
    materialCategory?: boolean
    subcategory?: boolean
    sampleSize?: boolean
    avgVariance?: boolean
    stdDeviation?: boolean
    confidenceScore?: boolean
    recommendedAdjustment?: boolean
    reasoning?: boolean
    status?: boolean
    reviewedAt?: boolean
    appliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VariancePatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scope" | "planId" | "communityId" | "customerId" | "region" | "materialCategory" | "subcategory" | "sampleSize" | "avgVariance" | "stdDeviation" | "confidenceScore" | "recommendedAdjustment" | "reasoning" | "status" | "reviewedAt" | "appliedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["variancePattern"]>
  export type VariancePatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | VariancePattern$planArgs<ExtArgs>
    community?: boolean | VariancePattern$communityArgs<ExtArgs>
    customer?: boolean | VariancePattern$customerArgs<ExtArgs>
    reviews?: boolean | VariancePattern$reviewsArgs<ExtArgs>
    _count?: boolean | VariancePatternCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VariancePatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | VariancePattern$planArgs<ExtArgs>
    community?: boolean | VariancePattern$communityArgs<ExtArgs>
    customer?: boolean | VariancePattern$customerArgs<ExtArgs>
  }
  export type VariancePatternIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | VariancePattern$planArgs<ExtArgs>
    community?: boolean | VariancePattern$communityArgs<ExtArgs>
    customer?: boolean | VariancePattern$customerArgs<ExtArgs>
  }

  export type $VariancePatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VariancePattern"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs> | null
      community: Prisma.$CommunityPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      reviews: Prisma.$VarianceReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scope: $Enums.VarianceScope
      planId: string | null
      communityId: string | null
      customerId: string | null
      region: string | null
      materialCategory: string
      subcategory: string | null
      sampleSize: number
      avgVariance: Prisma.Decimal
      stdDeviation: Prisma.Decimal
      confidenceScore: Prisma.Decimal
      recommendedAdjustment: Prisma.Decimal | null
      reasoning: string | null
      status: $Enums.PatternStatus
      reviewedAt: Date | null
      appliedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["variancePattern"]>
    composites: {}
  }

  type VariancePatternGetPayload<S extends boolean | null | undefined | VariancePatternDefaultArgs> = $Result.GetResult<Prisma.$VariancePatternPayload, S>

  type VariancePatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariancePatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariancePatternCountAggregateInputType | true
    }

  export interface VariancePatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VariancePattern'], meta: { name: 'VariancePattern' } }
    /**
     * Find zero or one VariancePattern that matches the filter.
     * @param {VariancePatternFindUniqueArgs} args - Arguments to find a VariancePattern
     * @example
     * // Get one VariancePattern
     * const variancePattern = await prisma.variancePattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariancePatternFindUniqueArgs>(args: SelectSubset<T, VariancePatternFindUniqueArgs<ExtArgs>>): Prisma__VariancePatternClient<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VariancePattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariancePatternFindUniqueOrThrowArgs} args - Arguments to find a VariancePattern
     * @example
     * // Get one VariancePattern
     * const variancePattern = await prisma.variancePattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariancePatternFindUniqueOrThrowArgs>(args: SelectSubset<T, VariancePatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariancePatternClient<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariancePattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariancePatternFindFirstArgs} args - Arguments to find a VariancePattern
     * @example
     * // Get one VariancePattern
     * const variancePattern = await prisma.variancePattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariancePatternFindFirstArgs>(args?: SelectSubset<T, VariancePatternFindFirstArgs<ExtArgs>>): Prisma__VariancePatternClient<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariancePattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariancePatternFindFirstOrThrowArgs} args - Arguments to find a VariancePattern
     * @example
     * // Get one VariancePattern
     * const variancePattern = await prisma.variancePattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariancePatternFindFirstOrThrowArgs>(args?: SelectSubset<T, VariancePatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariancePatternClient<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VariancePatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariancePatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VariancePatterns
     * const variancePatterns = await prisma.variancePattern.findMany()
     * 
     * // Get first 10 VariancePatterns
     * const variancePatterns = await prisma.variancePattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variancePatternWithIdOnly = await prisma.variancePattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariancePatternFindManyArgs>(args?: SelectSubset<T, VariancePatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VariancePattern.
     * @param {VariancePatternCreateArgs} args - Arguments to create a VariancePattern.
     * @example
     * // Create one VariancePattern
     * const VariancePattern = await prisma.variancePattern.create({
     *   data: {
     *     // ... data to create a VariancePattern
     *   }
     * })
     * 
     */
    create<T extends VariancePatternCreateArgs>(args: SelectSubset<T, VariancePatternCreateArgs<ExtArgs>>): Prisma__VariancePatternClient<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VariancePatterns.
     * @param {VariancePatternCreateManyArgs} args - Arguments to create many VariancePatterns.
     * @example
     * // Create many VariancePatterns
     * const variancePattern = await prisma.variancePattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariancePatternCreateManyArgs>(args?: SelectSubset<T, VariancePatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VariancePatterns and returns the data saved in the database.
     * @param {VariancePatternCreateManyAndReturnArgs} args - Arguments to create many VariancePatterns.
     * @example
     * // Create many VariancePatterns
     * const variancePattern = await prisma.variancePattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VariancePatterns and only return the `id`
     * const variancePatternWithIdOnly = await prisma.variancePattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariancePatternCreateManyAndReturnArgs>(args?: SelectSubset<T, VariancePatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VariancePattern.
     * @param {VariancePatternDeleteArgs} args - Arguments to delete one VariancePattern.
     * @example
     * // Delete one VariancePattern
     * const VariancePattern = await prisma.variancePattern.delete({
     *   where: {
     *     // ... filter to delete one VariancePattern
     *   }
     * })
     * 
     */
    delete<T extends VariancePatternDeleteArgs>(args: SelectSubset<T, VariancePatternDeleteArgs<ExtArgs>>): Prisma__VariancePatternClient<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VariancePattern.
     * @param {VariancePatternUpdateArgs} args - Arguments to update one VariancePattern.
     * @example
     * // Update one VariancePattern
     * const variancePattern = await prisma.variancePattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariancePatternUpdateArgs>(args: SelectSubset<T, VariancePatternUpdateArgs<ExtArgs>>): Prisma__VariancePatternClient<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VariancePatterns.
     * @param {VariancePatternDeleteManyArgs} args - Arguments to filter VariancePatterns to delete.
     * @example
     * // Delete a few VariancePatterns
     * const { count } = await prisma.variancePattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariancePatternDeleteManyArgs>(args?: SelectSubset<T, VariancePatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariancePatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariancePatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VariancePatterns
     * const variancePattern = await prisma.variancePattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariancePatternUpdateManyArgs>(args: SelectSubset<T, VariancePatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariancePatterns and returns the data updated in the database.
     * @param {VariancePatternUpdateManyAndReturnArgs} args - Arguments to update many VariancePatterns.
     * @example
     * // Update many VariancePatterns
     * const variancePattern = await prisma.variancePattern.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VariancePatterns and only return the `id`
     * const variancePatternWithIdOnly = await prisma.variancePattern.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariancePatternUpdateManyAndReturnArgs>(args: SelectSubset<T, VariancePatternUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VariancePattern.
     * @param {VariancePatternUpsertArgs} args - Arguments to update or create a VariancePattern.
     * @example
     * // Update or create a VariancePattern
     * const variancePattern = await prisma.variancePattern.upsert({
     *   create: {
     *     // ... data to create a VariancePattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VariancePattern we want to update
     *   }
     * })
     */
    upsert<T extends VariancePatternUpsertArgs>(args: SelectSubset<T, VariancePatternUpsertArgs<ExtArgs>>): Prisma__VariancePatternClient<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VariancePatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariancePatternCountArgs} args - Arguments to filter VariancePatterns to count.
     * @example
     * // Count the number of VariancePatterns
     * const count = await prisma.variancePattern.count({
     *   where: {
     *     // ... the filter for the VariancePatterns we want to count
     *   }
     * })
    **/
    count<T extends VariancePatternCountArgs>(
      args?: Subset<T, VariancePatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariancePatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VariancePattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariancePatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariancePatternAggregateArgs>(args: Subset<T, VariancePatternAggregateArgs>): Prisma.PrismaPromise<GetVariancePatternAggregateType<T>>

    /**
     * Group by VariancePattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariancePatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariancePatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariancePatternGroupByArgs['orderBy'] }
        : { orderBy?: VariancePatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariancePatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariancePatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VariancePattern model
   */
  readonly fields: VariancePatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VariancePattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariancePatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends VariancePattern$planArgs<ExtArgs> = {}>(args?: Subset<T, VariancePattern$planArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    community<T extends VariancePattern$communityArgs<ExtArgs> = {}>(args?: Subset<T, VariancePattern$communityArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends VariancePattern$customerArgs<ExtArgs> = {}>(args?: Subset<T, VariancePattern$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviews<T extends VariancePattern$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, VariancePattern$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VariancePattern model
   */
  interface VariancePatternFieldRefs {
    readonly id: FieldRef<"VariancePattern", 'String'>
    readonly scope: FieldRef<"VariancePattern", 'VarianceScope'>
    readonly planId: FieldRef<"VariancePattern", 'String'>
    readonly communityId: FieldRef<"VariancePattern", 'String'>
    readonly customerId: FieldRef<"VariancePattern", 'String'>
    readonly region: FieldRef<"VariancePattern", 'String'>
    readonly materialCategory: FieldRef<"VariancePattern", 'String'>
    readonly subcategory: FieldRef<"VariancePattern", 'String'>
    readonly sampleSize: FieldRef<"VariancePattern", 'Int'>
    readonly avgVariance: FieldRef<"VariancePattern", 'Decimal'>
    readonly stdDeviation: FieldRef<"VariancePattern", 'Decimal'>
    readonly confidenceScore: FieldRef<"VariancePattern", 'Decimal'>
    readonly recommendedAdjustment: FieldRef<"VariancePattern", 'Decimal'>
    readonly reasoning: FieldRef<"VariancePattern", 'String'>
    readonly status: FieldRef<"VariancePattern", 'PatternStatus'>
    readonly reviewedAt: FieldRef<"VariancePattern", 'DateTime'>
    readonly appliedAt: FieldRef<"VariancePattern", 'DateTime'>
    readonly createdAt: FieldRef<"VariancePattern", 'DateTime'>
    readonly updatedAt: FieldRef<"VariancePattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VariancePattern findUnique
   */
  export type VariancePatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    /**
     * Filter, which VariancePattern to fetch.
     */
    where: VariancePatternWhereUniqueInput
  }

  /**
   * VariancePattern findUniqueOrThrow
   */
  export type VariancePatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    /**
     * Filter, which VariancePattern to fetch.
     */
    where: VariancePatternWhereUniqueInput
  }

  /**
   * VariancePattern findFirst
   */
  export type VariancePatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    /**
     * Filter, which VariancePattern to fetch.
     */
    where?: VariancePatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariancePatterns to fetch.
     */
    orderBy?: VariancePatternOrderByWithRelationInput | VariancePatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariancePatterns.
     */
    cursor?: VariancePatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariancePatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariancePatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariancePatterns.
     */
    distinct?: VariancePatternScalarFieldEnum | VariancePatternScalarFieldEnum[]
  }

  /**
   * VariancePattern findFirstOrThrow
   */
  export type VariancePatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    /**
     * Filter, which VariancePattern to fetch.
     */
    where?: VariancePatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariancePatterns to fetch.
     */
    orderBy?: VariancePatternOrderByWithRelationInput | VariancePatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariancePatterns.
     */
    cursor?: VariancePatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariancePatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariancePatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariancePatterns.
     */
    distinct?: VariancePatternScalarFieldEnum | VariancePatternScalarFieldEnum[]
  }

  /**
   * VariancePattern findMany
   */
  export type VariancePatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    /**
     * Filter, which VariancePatterns to fetch.
     */
    where?: VariancePatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariancePatterns to fetch.
     */
    orderBy?: VariancePatternOrderByWithRelationInput | VariancePatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VariancePatterns.
     */
    cursor?: VariancePatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariancePatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariancePatterns.
     */
    skip?: number
    distinct?: VariancePatternScalarFieldEnum | VariancePatternScalarFieldEnum[]
  }

  /**
   * VariancePattern create
   */
  export type VariancePatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    /**
     * The data needed to create a VariancePattern.
     */
    data: XOR<VariancePatternCreateInput, VariancePatternUncheckedCreateInput>
  }

  /**
   * VariancePattern createMany
   */
  export type VariancePatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VariancePatterns.
     */
    data: VariancePatternCreateManyInput | VariancePatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VariancePattern createManyAndReturn
   */
  export type VariancePatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * The data used to create many VariancePatterns.
     */
    data: VariancePatternCreateManyInput | VariancePatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariancePattern update
   */
  export type VariancePatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    /**
     * The data needed to update a VariancePattern.
     */
    data: XOR<VariancePatternUpdateInput, VariancePatternUncheckedUpdateInput>
    /**
     * Choose, which VariancePattern to update.
     */
    where: VariancePatternWhereUniqueInput
  }

  /**
   * VariancePattern updateMany
   */
  export type VariancePatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VariancePatterns.
     */
    data: XOR<VariancePatternUpdateManyMutationInput, VariancePatternUncheckedUpdateManyInput>
    /**
     * Filter which VariancePatterns to update
     */
    where?: VariancePatternWhereInput
    /**
     * Limit how many VariancePatterns to update.
     */
    limit?: number
  }

  /**
   * VariancePattern updateManyAndReturn
   */
  export type VariancePatternUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * The data used to update VariancePatterns.
     */
    data: XOR<VariancePatternUpdateManyMutationInput, VariancePatternUncheckedUpdateManyInput>
    /**
     * Filter which VariancePatterns to update
     */
    where?: VariancePatternWhereInput
    /**
     * Limit how many VariancePatterns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariancePattern upsert
   */
  export type VariancePatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    /**
     * The filter to search for the VariancePattern to update in case it exists.
     */
    where: VariancePatternWhereUniqueInput
    /**
     * In case the VariancePattern found by the `where` argument doesn't exist, create a new VariancePattern with this data.
     */
    create: XOR<VariancePatternCreateInput, VariancePatternUncheckedCreateInput>
    /**
     * In case the VariancePattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariancePatternUpdateInput, VariancePatternUncheckedUpdateInput>
  }

  /**
   * VariancePattern delete
   */
  export type VariancePatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
    /**
     * Filter which VariancePattern to delete.
     */
    where: VariancePatternWhereUniqueInput
  }

  /**
   * VariancePattern deleteMany
   */
  export type VariancePatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariancePatterns to delete
     */
    where?: VariancePatternWhereInput
    /**
     * Limit how many VariancePatterns to delete.
     */
    limit?: number
  }

  /**
   * VariancePattern.plan
   */
  export type VariancePattern$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * VariancePattern.community
   */
  export type VariancePattern$communityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
  }

  /**
   * VariancePattern.customer
   */
  export type VariancePattern$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * VariancePattern.reviews
   */
  export type VariancePattern$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    where?: VarianceReviewWhereInput
    orderBy?: VarianceReviewOrderByWithRelationInput | VarianceReviewOrderByWithRelationInput[]
    cursor?: VarianceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VarianceReviewScalarFieldEnum | VarianceReviewScalarFieldEnum[]
  }

  /**
   * VariancePattern without action
   */
  export type VariancePatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariancePattern
     */
    select?: VariancePatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariancePattern
     */
    omit?: VariancePatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariancePatternInclude<ExtArgs> | null
  }


  /**
   * Model VarianceReview
   */

  export type AggregateVarianceReview = {
    _count: VarianceReviewCountAggregateOutputType | null
    _min: VarianceReviewMinAggregateOutputType | null
    _max: VarianceReviewMaxAggregateOutputType | null
  }

  export type VarianceReviewMinAggregateOutputType = {
    id: string | null
    patternId: string | null
    reviewerId: string | null
    decision: $Enums.ReviewDecision | null
    notes: string | null
    reviewedAt: Date | null
  }

  export type VarianceReviewMaxAggregateOutputType = {
    id: string | null
    patternId: string | null
    reviewerId: string | null
    decision: $Enums.ReviewDecision | null
    notes: string | null
    reviewedAt: Date | null
  }

  export type VarianceReviewCountAggregateOutputType = {
    id: number
    patternId: number
    reviewerId: number
    decision: number
    notes: number
    reviewedAt: number
    _all: number
  }


  export type VarianceReviewMinAggregateInputType = {
    id?: true
    patternId?: true
    reviewerId?: true
    decision?: true
    notes?: true
    reviewedAt?: true
  }

  export type VarianceReviewMaxAggregateInputType = {
    id?: true
    patternId?: true
    reviewerId?: true
    decision?: true
    notes?: true
    reviewedAt?: true
  }

  export type VarianceReviewCountAggregateInputType = {
    id?: true
    patternId?: true
    reviewerId?: true
    decision?: true
    notes?: true
    reviewedAt?: true
    _all?: true
  }

  export type VarianceReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VarianceReview to aggregate.
     */
    where?: VarianceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianceReviews to fetch.
     */
    orderBy?: VarianceReviewOrderByWithRelationInput | VarianceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VarianceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VarianceReviews
    **/
    _count?: true | VarianceReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VarianceReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VarianceReviewMaxAggregateInputType
  }

  export type GetVarianceReviewAggregateType<T extends VarianceReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateVarianceReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVarianceReview[P]>
      : GetScalarType<T[P], AggregateVarianceReview[P]>
  }




  export type VarianceReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VarianceReviewWhereInput
    orderBy?: VarianceReviewOrderByWithAggregationInput | VarianceReviewOrderByWithAggregationInput[]
    by: VarianceReviewScalarFieldEnum[] | VarianceReviewScalarFieldEnum
    having?: VarianceReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VarianceReviewCountAggregateInputType | true
    _min?: VarianceReviewMinAggregateInputType
    _max?: VarianceReviewMaxAggregateInputType
  }

  export type VarianceReviewGroupByOutputType = {
    id: string
    patternId: string
    reviewerId: string
    decision: $Enums.ReviewDecision
    notes: string | null
    reviewedAt: Date
    _count: VarianceReviewCountAggregateOutputType | null
    _min: VarianceReviewMinAggregateOutputType | null
    _max: VarianceReviewMaxAggregateOutputType | null
  }

  type GetVarianceReviewGroupByPayload<T extends VarianceReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VarianceReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VarianceReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VarianceReviewGroupByOutputType[P]>
            : GetScalarType<T[P], VarianceReviewGroupByOutputType[P]>
        }
      >
    >


  export type VarianceReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    reviewerId?: boolean
    decision?: boolean
    notes?: boolean
    reviewedAt?: boolean
    pattern?: boolean | VariancePatternDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["varianceReview"]>

  export type VarianceReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    reviewerId?: boolean
    decision?: boolean
    notes?: boolean
    reviewedAt?: boolean
    pattern?: boolean | VariancePatternDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["varianceReview"]>

  export type VarianceReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    reviewerId?: boolean
    decision?: boolean
    notes?: boolean
    reviewedAt?: boolean
    pattern?: boolean | VariancePatternDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["varianceReview"]>

  export type VarianceReviewSelectScalar = {
    id?: boolean
    patternId?: boolean
    reviewerId?: boolean
    decision?: boolean
    notes?: boolean
    reviewedAt?: boolean
  }

  export type VarianceReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patternId" | "reviewerId" | "decision" | "notes" | "reviewedAt", ExtArgs["result"]["varianceReview"]>
  export type VarianceReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | VariancePatternDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VarianceReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | VariancePatternDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VarianceReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | VariancePatternDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VarianceReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VarianceReview"
    objects: {
      pattern: Prisma.$VariancePatternPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patternId: string
      reviewerId: string
      decision: $Enums.ReviewDecision
      notes: string | null
      reviewedAt: Date
    }, ExtArgs["result"]["varianceReview"]>
    composites: {}
  }

  type VarianceReviewGetPayload<S extends boolean | null | undefined | VarianceReviewDefaultArgs> = $Result.GetResult<Prisma.$VarianceReviewPayload, S>

  type VarianceReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VarianceReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VarianceReviewCountAggregateInputType | true
    }

  export interface VarianceReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VarianceReview'], meta: { name: 'VarianceReview' } }
    /**
     * Find zero or one VarianceReview that matches the filter.
     * @param {VarianceReviewFindUniqueArgs} args - Arguments to find a VarianceReview
     * @example
     * // Get one VarianceReview
     * const varianceReview = await prisma.varianceReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VarianceReviewFindUniqueArgs>(args: SelectSubset<T, VarianceReviewFindUniqueArgs<ExtArgs>>): Prisma__VarianceReviewClient<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VarianceReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VarianceReviewFindUniqueOrThrowArgs} args - Arguments to find a VarianceReview
     * @example
     * // Get one VarianceReview
     * const varianceReview = await prisma.varianceReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VarianceReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, VarianceReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VarianceReviewClient<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VarianceReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceReviewFindFirstArgs} args - Arguments to find a VarianceReview
     * @example
     * // Get one VarianceReview
     * const varianceReview = await prisma.varianceReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VarianceReviewFindFirstArgs>(args?: SelectSubset<T, VarianceReviewFindFirstArgs<ExtArgs>>): Prisma__VarianceReviewClient<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VarianceReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceReviewFindFirstOrThrowArgs} args - Arguments to find a VarianceReview
     * @example
     * // Get one VarianceReview
     * const varianceReview = await prisma.varianceReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VarianceReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, VarianceReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__VarianceReviewClient<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VarianceReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VarianceReviews
     * const varianceReviews = await prisma.varianceReview.findMany()
     * 
     * // Get first 10 VarianceReviews
     * const varianceReviews = await prisma.varianceReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const varianceReviewWithIdOnly = await prisma.varianceReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VarianceReviewFindManyArgs>(args?: SelectSubset<T, VarianceReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VarianceReview.
     * @param {VarianceReviewCreateArgs} args - Arguments to create a VarianceReview.
     * @example
     * // Create one VarianceReview
     * const VarianceReview = await prisma.varianceReview.create({
     *   data: {
     *     // ... data to create a VarianceReview
     *   }
     * })
     * 
     */
    create<T extends VarianceReviewCreateArgs>(args: SelectSubset<T, VarianceReviewCreateArgs<ExtArgs>>): Prisma__VarianceReviewClient<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VarianceReviews.
     * @param {VarianceReviewCreateManyArgs} args - Arguments to create many VarianceReviews.
     * @example
     * // Create many VarianceReviews
     * const varianceReview = await prisma.varianceReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VarianceReviewCreateManyArgs>(args?: SelectSubset<T, VarianceReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VarianceReviews and returns the data saved in the database.
     * @param {VarianceReviewCreateManyAndReturnArgs} args - Arguments to create many VarianceReviews.
     * @example
     * // Create many VarianceReviews
     * const varianceReview = await prisma.varianceReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VarianceReviews and only return the `id`
     * const varianceReviewWithIdOnly = await prisma.varianceReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VarianceReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, VarianceReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VarianceReview.
     * @param {VarianceReviewDeleteArgs} args - Arguments to delete one VarianceReview.
     * @example
     * // Delete one VarianceReview
     * const VarianceReview = await prisma.varianceReview.delete({
     *   where: {
     *     // ... filter to delete one VarianceReview
     *   }
     * })
     * 
     */
    delete<T extends VarianceReviewDeleteArgs>(args: SelectSubset<T, VarianceReviewDeleteArgs<ExtArgs>>): Prisma__VarianceReviewClient<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VarianceReview.
     * @param {VarianceReviewUpdateArgs} args - Arguments to update one VarianceReview.
     * @example
     * // Update one VarianceReview
     * const varianceReview = await prisma.varianceReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VarianceReviewUpdateArgs>(args: SelectSubset<T, VarianceReviewUpdateArgs<ExtArgs>>): Prisma__VarianceReviewClient<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VarianceReviews.
     * @param {VarianceReviewDeleteManyArgs} args - Arguments to filter VarianceReviews to delete.
     * @example
     * // Delete a few VarianceReviews
     * const { count } = await prisma.varianceReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VarianceReviewDeleteManyArgs>(args?: SelectSubset<T, VarianceReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VarianceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VarianceReviews
     * const varianceReview = await prisma.varianceReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VarianceReviewUpdateManyArgs>(args: SelectSubset<T, VarianceReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VarianceReviews and returns the data updated in the database.
     * @param {VarianceReviewUpdateManyAndReturnArgs} args - Arguments to update many VarianceReviews.
     * @example
     * // Update many VarianceReviews
     * const varianceReview = await prisma.varianceReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VarianceReviews and only return the `id`
     * const varianceReviewWithIdOnly = await prisma.varianceReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VarianceReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, VarianceReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VarianceReview.
     * @param {VarianceReviewUpsertArgs} args - Arguments to update or create a VarianceReview.
     * @example
     * // Update or create a VarianceReview
     * const varianceReview = await prisma.varianceReview.upsert({
     *   create: {
     *     // ... data to create a VarianceReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VarianceReview we want to update
     *   }
     * })
     */
    upsert<T extends VarianceReviewUpsertArgs>(args: SelectSubset<T, VarianceReviewUpsertArgs<ExtArgs>>): Prisma__VarianceReviewClient<$Result.GetResult<Prisma.$VarianceReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VarianceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceReviewCountArgs} args - Arguments to filter VarianceReviews to count.
     * @example
     * // Count the number of VarianceReviews
     * const count = await prisma.varianceReview.count({
     *   where: {
     *     // ... the filter for the VarianceReviews we want to count
     *   }
     * })
    **/
    count<T extends VarianceReviewCountArgs>(
      args?: Subset<T, VarianceReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VarianceReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VarianceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VarianceReviewAggregateArgs>(args: Subset<T, VarianceReviewAggregateArgs>): Prisma.PrismaPromise<GetVarianceReviewAggregateType<T>>

    /**
     * Group by VarianceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VarianceReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VarianceReviewGroupByArgs['orderBy'] }
        : { orderBy?: VarianceReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VarianceReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVarianceReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VarianceReview model
   */
  readonly fields: VarianceReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VarianceReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VarianceReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pattern<T extends VariancePatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariancePatternDefaultArgs<ExtArgs>>): Prisma__VariancePatternClient<$Result.GetResult<Prisma.$VariancePatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VarianceReview model
   */
  interface VarianceReviewFieldRefs {
    readonly id: FieldRef<"VarianceReview", 'String'>
    readonly patternId: FieldRef<"VarianceReview", 'String'>
    readonly reviewerId: FieldRef<"VarianceReview", 'String'>
    readonly decision: FieldRef<"VarianceReview", 'ReviewDecision'>
    readonly notes: FieldRef<"VarianceReview", 'String'>
    readonly reviewedAt: FieldRef<"VarianceReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VarianceReview findUnique
   */
  export type VarianceReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    /**
     * Filter, which VarianceReview to fetch.
     */
    where: VarianceReviewWhereUniqueInput
  }

  /**
   * VarianceReview findUniqueOrThrow
   */
  export type VarianceReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    /**
     * Filter, which VarianceReview to fetch.
     */
    where: VarianceReviewWhereUniqueInput
  }

  /**
   * VarianceReview findFirst
   */
  export type VarianceReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    /**
     * Filter, which VarianceReview to fetch.
     */
    where?: VarianceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianceReviews to fetch.
     */
    orderBy?: VarianceReviewOrderByWithRelationInput | VarianceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VarianceReviews.
     */
    cursor?: VarianceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VarianceReviews.
     */
    distinct?: VarianceReviewScalarFieldEnum | VarianceReviewScalarFieldEnum[]
  }

  /**
   * VarianceReview findFirstOrThrow
   */
  export type VarianceReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    /**
     * Filter, which VarianceReview to fetch.
     */
    where?: VarianceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianceReviews to fetch.
     */
    orderBy?: VarianceReviewOrderByWithRelationInput | VarianceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VarianceReviews.
     */
    cursor?: VarianceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VarianceReviews.
     */
    distinct?: VarianceReviewScalarFieldEnum | VarianceReviewScalarFieldEnum[]
  }

  /**
   * VarianceReview findMany
   */
  export type VarianceReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    /**
     * Filter, which VarianceReviews to fetch.
     */
    where?: VarianceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianceReviews to fetch.
     */
    orderBy?: VarianceReviewOrderByWithRelationInput | VarianceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VarianceReviews.
     */
    cursor?: VarianceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianceReviews.
     */
    skip?: number
    distinct?: VarianceReviewScalarFieldEnum | VarianceReviewScalarFieldEnum[]
  }

  /**
   * VarianceReview create
   */
  export type VarianceReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a VarianceReview.
     */
    data: XOR<VarianceReviewCreateInput, VarianceReviewUncheckedCreateInput>
  }

  /**
   * VarianceReview createMany
   */
  export type VarianceReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VarianceReviews.
     */
    data: VarianceReviewCreateManyInput | VarianceReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VarianceReview createManyAndReturn
   */
  export type VarianceReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * The data used to create many VarianceReviews.
     */
    data: VarianceReviewCreateManyInput | VarianceReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VarianceReview update
   */
  export type VarianceReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a VarianceReview.
     */
    data: XOR<VarianceReviewUpdateInput, VarianceReviewUncheckedUpdateInput>
    /**
     * Choose, which VarianceReview to update.
     */
    where: VarianceReviewWhereUniqueInput
  }

  /**
   * VarianceReview updateMany
   */
  export type VarianceReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VarianceReviews.
     */
    data: XOR<VarianceReviewUpdateManyMutationInput, VarianceReviewUncheckedUpdateManyInput>
    /**
     * Filter which VarianceReviews to update
     */
    where?: VarianceReviewWhereInput
    /**
     * Limit how many VarianceReviews to update.
     */
    limit?: number
  }

  /**
   * VarianceReview updateManyAndReturn
   */
  export type VarianceReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * The data used to update VarianceReviews.
     */
    data: XOR<VarianceReviewUpdateManyMutationInput, VarianceReviewUncheckedUpdateManyInput>
    /**
     * Filter which VarianceReviews to update
     */
    where?: VarianceReviewWhereInput
    /**
     * Limit how many VarianceReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VarianceReview upsert
   */
  export type VarianceReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the VarianceReview to update in case it exists.
     */
    where: VarianceReviewWhereUniqueInput
    /**
     * In case the VarianceReview found by the `where` argument doesn't exist, create a new VarianceReview with this data.
     */
    create: XOR<VarianceReviewCreateInput, VarianceReviewUncheckedCreateInput>
    /**
     * In case the VarianceReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VarianceReviewUpdateInput, VarianceReviewUncheckedUpdateInput>
  }

  /**
   * VarianceReview delete
   */
  export type VarianceReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
    /**
     * Filter which VarianceReview to delete.
     */
    where: VarianceReviewWhereUniqueInput
  }

  /**
   * VarianceReview deleteMany
   */
  export type VarianceReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VarianceReviews to delete
     */
    where?: VarianceReviewWhereInput
    /**
     * Limit how many VarianceReviews to delete.
     */
    limit?: number
  }

  /**
   * VarianceReview without action
   */
  export type VarianceReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceReview
     */
    select?: VarianceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceReview
     */
    omit?: VarianceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceReviewInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    actionUrl: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    actionUrl: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    actionUrl: number
    isRead: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl: string | null
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "actionUrl" | "isRead" | "readAt" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      actionUrl: string | null
      isRead: boolean
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changes: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entityType: string
    entityId: string
    changes: JsonValue
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "changes" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    customerName: 'customerName',
    customerType: 'customerType',
    pricingTier: 'pricingTier',
    primaryContactId: 'primaryContactId',
    isActive: 'isActive',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerContactScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    contactName: 'contactName',
    role: 'role',
    email: 'email',
    phone: 'phone',
    receivesNotifications: 'receivesNotifications',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt'
  };

  export type CustomerContactScalarFieldEnum = (typeof CustomerContactScalarFieldEnum)[keyof typeof CustomerContactScalarFieldEnum]


  export const CustomerPricingTierScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    tierName: 'tierName',
    discountPercentage: 'discountPercentage',
    effectiveDate: 'effectiveDate',
    expirationDate: 'expirationDate',
    createdAt: 'createdAt'
  };

  export type CustomerPricingTierScalarFieldEnum = (typeof CustomerPricingTierScalarFieldEnum)[keyof typeof CustomerPricingTierScalarFieldEnum]


  export const CustomerExternalIdScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    externalSystem: 'externalSystem',
    externalCustomerId: 'externalCustomerId',
    externalCustomerName: 'externalCustomerName',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt'
  };

  export type CustomerExternalIdScalarFieldEnum = (typeof CustomerExternalIdScalarFieldEnum)[keyof typeof CustomerExternalIdScalarFieldEnum]


  export const CustomerPricingScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    materialId: 'materialId',
    overridePrice: 'overridePrice',
    overrideMargin: 'overrideMargin',
    discountPercentage: 'discountPercentage',
    effectiveDate: 'effectiveDate',
    expiresAt: 'expiresAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerPricingScalarFieldEnum = (typeof CustomerPricingScalarFieldEnum)[keyof typeof CustomerPricingScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    type: 'type',
    sqft: 'sqft',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    garage: 'garage',
    style: 'style',
    version: 'version',
    isActive: 'isActive',
    pdssUrl: 'pdssUrl',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PlanElevationScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    code: 'code',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanElevationScalarFieldEnum = (typeof PlanElevationScalarFieldEnum)[keyof typeof PlanElevationScalarFieldEnum]


  export const PlanOptionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    category: 'category',
    basePrice: 'basePrice',
    triggersPacks: 'triggersPacks',
    appliesTo: 'appliesTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanOptionScalarFieldEnum = (typeof PlanOptionScalarFieldEnum)[keyof typeof PlanOptionScalarFieldEnum]


  export const PlanTemplateItemScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    materialId: 'materialId',
    quantity: 'quantity',
    unit: 'unit',
    wasteFactor: 'wasteFactor',
    category: 'category',
    subcategory: 'subcategory',
    averageVariance: 'averageVariance',
    varianceCount: 'varianceCount',
    lastVarianceDate: 'lastVarianceDate',
    confidenceScore: 'confidenceScore',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanTemplateItemScalarFieldEnum = (typeof PlanTemplateItemScalarFieldEnum)[keyof typeof PlanTemplateItemScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    description: 'description',
    category: 'category',
    subcategory: 'subcategory',
    unitOfMeasure: 'unitOfMeasure',
    vendorCost: 'vendorCost',
    freight: 'freight',
    isRLLinked: 'isRLLinked',
    rlTag: 'rlTag',
    rlBasePrice: 'rlBasePrice',
    rlLastUpdated: 'rlLastUpdated',
    lengthAdders: 'lengthAdders',
    gradeMultipliers: 'gradeMultipliers',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vendorId: 'vendorId'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    primaryContact: 'primaryContact',
    email: 'email',
    phone: 'phone',
    paymentTerms: 'paymentTerms',
    leadTimeDays: 'leadTimeDays',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const PricingHistoryScalarFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    baseVendorCost: 'baseVendorCost',
    commodityAdjustment: 'commodityAdjustment',
    freight: 'freight',
    totalCost: 'totalCost',
    marginPercentage: 'marginPercentage',
    marginAmount: 'marginAmount',
    unitPrice: 'unitPrice',
    calculationSteps: 'calculationSteps',
    effectiveDate: 'effectiveDate',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type PricingHistoryScalarFieldEnum = (typeof PricingHistoryScalarFieldEnum)[keyof typeof PricingHistoryScalarFieldEnum]


  export const RandomLengthsPricingScalarFieldEnum: {
    id: 'id',
    tag: 'tag',
    description: 'description',
    price: 'price',
    unit: 'unit',
    region: 'region',
    grade: 'grade',
    effectiveDate: 'effectiveDate',
    source: 'source',
    createdAt: 'createdAt'
  };

  export type RandomLengthsPricingScalarFieldEnum = (typeof RandomLengthsPricingScalarFieldEnum)[keyof typeof RandomLengthsPricingScalarFieldEnum]


  export const CommunityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    customerId: 'customerId',
    shippingYard: 'shippingYard',
    jurisdiction: 'jurisdiction',
    region: 'region',
    activePlans: 'activePlans',
    isActive: 'isActive',
    specialRequirements: 'specialRequirements',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityScalarFieldEnum = (typeof CommunityScalarFieldEnum)[keyof typeof CommunityScalarFieldEnum]


  export const LotScalarFieldEnum: {
    id: 'id',
    communityId: 'communityId',
    lotNumber: 'lotNumber',
    status: 'status',
    sqft: 'sqft',
    frontage: 'frontage',
    depth: 'depth',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LotScalarFieldEnum = (typeof LotScalarFieldEnum)[keyof typeof LotScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    jobNumber: 'jobNumber',
    customerId: 'customerId',
    planId: 'planId',
    elevationId: 'elevationId',
    communityId: 'communityId',
    lotId: 'lotId',
    status: 'status',
    estimatedCost: 'estimatedCost',
    actualCost: 'actualCost',
    margin: 'margin',
    createdById: 'createdById',
    approvedById: 'approvedById',
    approvedAt: 'approvedAt',
    startDate: 'startDate',
    completionDate: 'completionDate',
    notes: 'notes',
    folderPath: 'folderPath',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const JobOptionScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    optionId: 'optionId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type JobOptionScalarFieldEnum = (typeof JobOptionScalarFieldEnum)[keyof typeof JobOptionScalarFieldEnum]


  export const TakeoffScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    status: 'status',
    isValidated: 'isValidated',
    validatedAt: 'validatedAt',
    validationResults: 'validationResults',
    totalEstimated: 'totalEstimated',
    totalActual: 'totalActual',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TakeoffScalarFieldEnum = (typeof TakeoffScalarFieldEnum)[keyof typeof TakeoffScalarFieldEnum]


  export const TakeoffLineItemScalarFieldEnum: {
    id: 'id',
    takeoffId: 'takeoffId',
    materialId: 'materialId',
    quantityEstimated: 'quantityEstimated',
    quantityActual: 'quantityActual',
    unit: 'unit',
    unitPrice: 'unitPrice',
    totalEstimated: 'totalEstimated',
    totalActual: 'totalActual',
    variance: 'variance',
    variancePercent: 'variancePercent',
    varianceReason: 'varianceReason',
    category: 'category',
    subcategory: 'subcategory',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TakeoffLineItemScalarFieldEnum = (typeof TakeoffLineItemScalarFieldEnum)[keyof typeof TakeoffLineItemScalarFieldEnum]


  export const TakeoffValidationScalarFieldEnum: {
    id: 'id',
    takeoffId: 'takeoffId',
    specCompliant: 'specCompliant',
    pricingCurrent: 'pricingCurrent',
    varianceAcceptable: 'varianceAcceptable',
    issues: 'issues',
    warnings: 'warnings',
    comparedToJobs: 'comparedToJobs',
    avgVariance: 'avgVariance',
    validatedAt: 'validatedAt'
  };

  export type TakeoffValidationScalarFieldEnum = (typeof TakeoffValidationScalarFieldEnum)[keyof typeof TakeoffValidationScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    poNumber: 'poNumber',
    jobId: 'jobId',
    vendorId: 'vendorId',
    status: 'status',
    totalAmount: 'totalAmount',
    approvedAt: 'approvedAt',
    sentAt: 'sentAt',
    confirmedAt: 'confirmedAt',
    deliveredAt: 'deliveredAt',
    scheduledDelivery: 'scheduledDelivery',
    actualDelivery: 'actualDelivery',
    deliveryNotes: 'deliveryNotes',
    hyphenBuildProId: 'hyphenBuildProId',
    holtPortalId: 'holtPortalId',
    signatureUrl: 'signatureUrl',
    photoUrls: 'photoUrls',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const VariancePatternScalarFieldEnum: {
    id: 'id',
    scope: 'scope',
    planId: 'planId',
    communityId: 'communityId',
    customerId: 'customerId',
    region: 'region',
    materialCategory: 'materialCategory',
    subcategory: 'subcategory',
    sampleSize: 'sampleSize',
    avgVariance: 'avgVariance',
    stdDeviation: 'stdDeviation',
    confidenceScore: 'confidenceScore',
    recommendedAdjustment: 'recommendedAdjustment',
    reasoning: 'reasoning',
    status: 'status',
    reviewedAt: 'reviewedAt',
    appliedAt: 'appliedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VariancePatternScalarFieldEnum = (typeof VariancePatternScalarFieldEnum)[keyof typeof VariancePatternScalarFieldEnum]


  export const VarianceReviewScalarFieldEnum: {
    id: 'id',
    patternId: 'patternId',
    reviewerId: 'reviewerId',
    decision: 'decision',
    notes: 'notes',
    reviewedAt: 'reviewedAt'
  };

  export type VarianceReviewScalarFieldEnum = (typeof VarianceReviewScalarFieldEnum)[keyof typeof VarianceReviewScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    actionUrl: 'actionUrl',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CustomerType'
   */
  export type EnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType'>
    


  /**
   * Reference to a field of type 'CustomerType[]'
   */
  export type ListEnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'OptionCategory'
   */
  export type EnumOptionCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OptionCategory'>
    


  /**
   * Reference to a field of type 'OptionCategory[]'
   */
  export type ListEnumOptionCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OptionCategory[]'>
    


  /**
   * Reference to a field of type 'MaterialCategory'
   */
  export type EnumMaterialCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialCategory'>
    


  /**
   * Reference to a field of type 'MaterialCategory[]'
   */
  export type ListEnumMaterialCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialCategory[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'LotStatus'
   */
  export type EnumLotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LotStatus'>
    


  /**
   * Reference to a field of type 'LotStatus[]'
   */
  export type ListEnumLotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LotStatus[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'TakeoffStatus'
   */
  export type EnumTakeoffStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TakeoffStatus'>
    


  /**
   * Reference to a field of type 'TakeoffStatus[]'
   */
  export type ListEnumTakeoffStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TakeoffStatus[]'>
    


  /**
   * Reference to a field of type 'POStatus'
   */
  export type EnumPOStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POStatus'>
    


  /**
   * Reference to a field of type 'POStatus[]'
   */
  export type ListEnumPOStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POStatus[]'>
    


  /**
   * Reference to a field of type 'VarianceScope'
   */
  export type EnumVarianceScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VarianceScope'>
    


  /**
   * Reference to a field of type 'VarianceScope[]'
   */
  export type ListEnumVarianceScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VarianceScope[]'>
    


  /**
   * Reference to a field of type 'PatternStatus'
   */
  export type EnumPatternStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PatternStatus'>
    


  /**
   * Reference to a field of type 'PatternStatus[]'
   */
  export type ListEnumPatternStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PatternStatus[]'>
    


  /**
   * Reference to a field of type 'ReviewDecision'
   */
  export type EnumReviewDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewDecision'>
    


  /**
   * Reference to a field of type 'ReviewDecision[]'
   */
  export type ListEnumReviewDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewDecision[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdJobs?: JobListRelationFilter
    approvedJobs?: JobListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    varianceReviews?: VarianceReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdJobs?: JobOrderByRelationAggregateInput
    approvedJobs?: JobOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    varianceReviews?: VarianceReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdJobs?: JobListRelationFilter
    approvedJobs?: JobListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    varianceReviews?: VarianceReviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    customerName?: StringFilter<"Customer"> | string
    customerType?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    pricingTier?: StringNullableFilter<"Customer"> | string | null
    primaryContactId?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    contacts?: CustomerContactListRelationFilter
    pricingTiers?: CustomerPricingTierListRelationFilter
    externalIds?: CustomerExternalIdListRelationFilter
    jobs?: JobListRelationFilter
    communities?: CommunityListRelationFilter
    customerPricing?: CustomerPricingListRelationFilter
    variancePatterns?: VariancePatternListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerType?: SortOrder
    pricingTier?: SortOrderInput | SortOrder
    primaryContactId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contacts?: CustomerContactOrderByRelationAggregateInput
    pricingTiers?: CustomerPricingTierOrderByRelationAggregateInput
    externalIds?: CustomerExternalIdOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
    communities?: CommunityOrderByRelationAggregateInput
    customerPricing?: CustomerPricingOrderByRelationAggregateInput
    variancePatterns?: VariancePatternOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    customerName?: StringFilter<"Customer"> | string
    customerType?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    pricingTier?: StringNullableFilter<"Customer"> | string | null
    primaryContactId?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    contacts?: CustomerContactListRelationFilter
    pricingTiers?: CustomerPricingTierListRelationFilter
    externalIds?: CustomerExternalIdListRelationFilter
    jobs?: JobListRelationFilter
    communities?: CommunityListRelationFilter
    customerPricing?: CustomerPricingListRelationFilter
    variancePatterns?: VariancePatternListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerType?: SortOrder
    pricingTier?: SortOrderInput | SortOrder
    primaryContactId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    customerName?: StringWithAggregatesFilter<"Customer"> | string
    customerType?: EnumCustomerTypeWithAggregatesFilter<"Customer"> | $Enums.CustomerType
    pricingTier?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    primaryContactId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type CustomerContactWhereInput = {
    AND?: CustomerContactWhereInput | CustomerContactWhereInput[]
    OR?: CustomerContactWhereInput[]
    NOT?: CustomerContactWhereInput | CustomerContactWhereInput[]
    id?: StringFilter<"CustomerContact"> | string
    customerId?: StringFilter<"CustomerContact"> | string
    contactName?: StringFilter<"CustomerContact"> | string
    role?: StringNullableFilter<"CustomerContact"> | string | null
    email?: StringNullableFilter<"CustomerContact"> | string | null
    phone?: StringNullableFilter<"CustomerContact"> | string | null
    receivesNotifications?: BoolFilter<"CustomerContact"> | boolean
    isPrimary?: BoolFilter<"CustomerContact"> | boolean
    createdAt?: DateTimeFilter<"CustomerContact"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerContactOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    contactName?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    receivesNotifications?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerContactWhereInput | CustomerContactWhereInput[]
    OR?: CustomerContactWhereInput[]
    NOT?: CustomerContactWhereInput | CustomerContactWhereInput[]
    customerId?: StringFilter<"CustomerContact"> | string
    contactName?: StringFilter<"CustomerContact"> | string
    role?: StringNullableFilter<"CustomerContact"> | string | null
    email?: StringNullableFilter<"CustomerContact"> | string | null
    phone?: StringNullableFilter<"CustomerContact"> | string | null
    receivesNotifications?: BoolFilter<"CustomerContact"> | boolean
    isPrimary?: BoolFilter<"CustomerContact"> | boolean
    createdAt?: DateTimeFilter<"CustomerContact"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerContactOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    contactName?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    receivesNotifications?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerContactCountOrderByAggregateInput
    _max?: CustomerContactMaxOrderByAggregateInput
    _min?: CustomerContactMinOrderByAggregateInput
  }

  export type CustomerContactScalarWhereWithAggregatesInput = {
    AND?: CustomerContactScalarWhereWithAggregatesInput | CustomerContactScalarWhereWithAggregatesInput[]
    OR?: CustomerContactScalarWhereWithAggregatesInput[]
    NOT?: CustomerContactScalarWhereWithAggregatesInput | CustomerContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerContact"> | string
    customerId?: StringWithAggregatesFilter<"CustomerContact"> | string
    contactName?: StringWithAggregatesFilter<"CustomerContact"> | string
    role?: StringNullableWithAggregatesFilter<"CustomerContact"> | string | null
    email?: StringNullableWithAggregatesFilter<"CustomerContact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"CustomerContact"> | string | null
    receivesNotifications?: BoolWithAggregatesFilter<"CustomerContact"> | boolean
    isPrimary?: BoolWithAggregatesFilter<"CustomerContact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerContact"> | Date | string
  }

  export type CustomerPricingTierWhereInput = {
    AND?: CustomerPricingTierWhereInput | CustomerPricingTierWhereInput[]
    OR?: CustomerPricingTierWhereInput[]
    NOT?: CustomerPricingTierWhereInput | CustomerPricingTierWhereInput[]
    id?: StringFilter<"CustomerPricingTier"> | string
    customerId?: StringFilter<"CustomerPricingTier"> | string
    tierName?: StringFilter<"CustomerPricingTier"> | string
    discountPercentage?: DecimalFilter<"CustomerPricingTier"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFilter<"CustomerPricingTier"> | Date | string
    expirationDate?: DateTimeNullableFilter<"CustomerPricingTier"> | Date | string | null
    createdAt?: DateTimeFilter<"CustomerPricingTier"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerPricingTierOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    tierName?: SortOrder
    discountPercentage?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerPricingTierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerPricingTierWhereInput | CustomerPricingTierWhereInput[]
    OR?: CustomerPricingTierWhereInput[]
    NOT?: CustomerPricingTierWhereInput | CustomerPricingTierWhereInput[]
    customerId?: StringFilter<"CustomerPricingTier"> | string
    tierName?: StringFilter<"CustomerPricingTier"> | string
    discountPercentage?: DecimalFilter<"CustomerPricingTier"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFilter<"CustomerPricingTier"> | Date | string
    expirationDate?: DateTimeNullableFilter<"CustomerPricingTier"> | Date | string | null
    createdAt?: DateTimeFilter<"CustomerPricingTier"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerPricingTierOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    tierName?: SortOrder
    discountPercentage?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CustomerPricingTierCountOrderByAggregateInput
    _avg?: CustomerPricingTierAvgOrderByAggregateInput
    _max?: CustomerPricingTierMaxOrderByAggregateInput
    _min?: CustomerPricingTierMinOrderByAggregateInput
    _sum?: CustomerPricingTierSumOrderByAggregateInput
  }

  export type CustomerPricingTierScalarWhereWithAggregatesInput = {
    AND?: CustomerPricingTierScalarWhereWithAggregatesInput | CustomerPricingTierScalarWhereWithAggregatesInput[]
    OR?: CustomerPricingTierScalarWhereWithAggregatesInput[]
    NOT?: CustomerPricingTierScalarWhereWithAggregatesInput | CustomerPricingTierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerPricingTier"> | string
    customerId?: StringWithAggregatesFilter<"CustomerPricingTier"> | string
    tierName?: StringWithAggregatesFilter<"CustomerPricingTier"> | string
    discountPercentage?: DecimalWithAggregatesFilter<"CustomerPricingTier"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeWithAggregatesFilter<"CustomerPricingTier"> | Date | string
    expirationDate?: DateTimeNullableWithAggregatesFilter<"CustomerPricingTier"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomerPricingTier"> | Date | string
  }

  export type CustomerExternalIdWhereInput = {
    AND?: CustomerExternalIdWhereInput | CustomerExternalIdWhereInput[]
    OR?: CustomerExternalIdWhereInput[]
    NOT?: CustomerExternalIdWhereInput | CustomerExternalIdWhereInput[]
    id?: StringFilter<"CustomerExternalId"> | string
    customerId?: StringFilter<"CustomerExternalId"> | string
    externalSystem?: StringFilter<"CustomerExternalId"> | string
    externalCustomerId?: StringFilter<"CustomerExternalId"> | string
    externalCustomerName?: StringNullableFilter<"CustomerExternalId"> | string | null
    isPrimary?: BoolFilter<"CustomerExternalId"> | boolean
    createdAt?: DateTimeFilter<"CustomerExternalId"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerExternalIdOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    externalSystem?: SortOrder
    externalCustomerId?: SortOrder
    externalCustomerName?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerExternalIdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId_externalSystem?: CustomerExternalIdCustomerIdExternalSystemCompoundUniqueInput
    AND?: CustomerExternalIdWhereInput | CustomerExternalIdWhereInput[]
    OR?: CustomerExternalIdWhereInput[]
    NOT?: CustomerExternalIdWhereInput | CustomerExternalIdWhereInput[]
    customerId?: StringFilter<"CustomerExternalId"> | string
    externalSystem?: StringFilter<"CustomerExternalId"> | string
    externalCustomerId?: StringFilter<"CustomerExternalId"> | string
    externalCustomerName?: StringNullableFilter<"CustomerExternalId"> | string | null
    isPrimary?: BoolFilter<"CustomerExternalId"> | boolean
    createdAt?: DateTimeFilter<"CustomerExternalId"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "customerId_externalSystem">

  export type CustomerExternalIdOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    externalSystem?: SortOrder
    externalCustomerId?: SortOrder
    externalCustomerName?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerExternalIdCountOrderByAggregateInput
    _max?: CustomerExternalIdMaxOrderByAggregateInput
    _min?: CustomerExternalIdMinOrderByAggregateInput
  }

  export type CustomerExternalIdScalarWhereWithAggregatesInput = {
    AND?: CustomerExternalIdScalarWhereWithAggregatesInput | CustomerExternalIdScalarWhereWithAggregatesInput[]
    OR?: CustomerExternalIdScalarWhereWithAggregatesInput[]
    NOT?: CustomerExternalIdScalarWhereWithAggregatesInput | CustomerExternalIdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerExternalId"> | string
    customerId?: StringWithAggregatesFilter<"CustomerExternalId"> | string
    externalSystem?: StringWithAggregatesFilter<"CustomerExternalId"> | string
    externalCustomerId?: StringWithAggregatesFilter<"CustomerExternalId"> | string
    externalCustomerName?: StringNullableWithAggregatesFilter<"CustomerExternalId"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"CustomerExternalId"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerExternalId"> | Date | string
  }

  export type CustomerPricingWhereInput = {
    AND?: CustomerPricingWhereInput | CustomerPricingWhereInput[]
    OR?: CustomerPricingWhereInput[]
    NOT?: CustomerPricingWhereInput | CustomerPricingWhereInput[]
    id?: StringFilter<"CustomerPricing"> | string
    customerId?: StringFilter<"CustomerPricing"> | string
    materialId?: StringFilter<"CustomerPricing"> | string
    overridePrice?: DecimalNullableFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: DecimalNullableFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: DecimalNullableFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFilter<"CustomerPricing"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CustomerPricing"> | Date | string | null
    notes?: StringNullableFilter<"CustomerPricing"> | string | null
    createdAt?: DateTimeFilter<"CustomerPricing"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPricing"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }

  export type CustomerPricingOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    materialId?: SortOrder
    overridePrice?: SortOrderInput | SortOrder
    overrideMargin?: SortOrderInput | SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
  }

  export type CustomerPricingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId_materialId?: CustomerPricingCustomerIdMaterialIdCompoundUniqueInput
    AND?: CustomerPricingWhereInput | CustomerPricingWhereInput[]
    OR?: CustomerPricingWhereInput[]
    NOT?: CustomerPricingWhereInput | CustomerPricingWhereInput[]
    customerId?: StringFilter<"CustomerPricing"> | string
    materialId?: StringFilter<"CustomerPricing"> | string
    overridePrice?: DecimalNullableFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: DecimalNullableFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: DecimalNullableFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFilter<"CustomerPricing"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CustomerPricing"> | Date | string | null
    notes?: StringNullableFilter<"CustomerPricing"> | string | null
    createdAt?: DateTimeFilter<"CustomerPricing"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPricing"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }, "id" | "customerId_materialId">

  export type CustomerPricingOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    materialId?: SortOrder
    overridePrice?: SortOrderInput | SortOrder
    overrideMargin?: SortOrderInput | SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerPricingCountOrderByAggregateInput
    _avg?: CustomerPricingAvgOrderByAggregateInput
    _max?: CustomerPricingMaxOrderByAggregateInput
    _min?: CustomerPricingMinOrderByAggregateInput
    _sum?: CustomerPricingSumOrderByAggregateInput
  }

  export type CustomerPricingScalarWhereWithAggregatesInput = {
    AND?: CustomerPricingScalarWhereWithAggregatesInput | CustomerPricingScalarWhereWithAggregatesInput[]
    OR?: CustomerPricingScalarWhereWithAggregatesInput[]
    NOT?: CustomerPricingScalarWhereWithAggregatesInput | CustomerPricingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerPricing"> | string
    customerId?: StringWithAggregatesFilter<"CustomerPricing"> | string
    materialId?: StringWithAggregatesFilter<"CustomerPricing"> | string
    overridePrice?: DecimalNullableWithAggregatesFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: DecimalNullableWithAggregatesFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: DecimalNullableWithAggregatesFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeWithAggregatesFilter<"CustomerPricing"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"CustomerPricing"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"CustomerPricing"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomerPricing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerPricing"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    code?: StringFilter<"Plan"> | string
    name?: StringNullableFilter<"Plan"> | string | null
    type?: EnumPlanTypeFilter<"Plan"> | $Enums.PlanType
    sqft?: IntNullableFilter<"Plan"> | number | null
    bedrooms?: IntNullableFilter<"Plan"> | number | null
    bathrooms?: DecimalNullableFilter<"Plan"> | Decimal | DecimalJsLike | number | string | null
    garage?: StringNullableFilter<"Plan"> | string | null
    style?: StringNullableFilter<"Plan"> | string | null
    version?: IntFilter<"Plan"> | number
    isActive?: BoolFilter<"Plan"> | boolean
    pdssUrl?: StringNullableFilter<"Plan"> | string | null
    notes?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    elevations?: PlanElevationListRelationFilter
    options?: PlanOptionListRelationFilter
    templateItems?: PlanTemplateItemListRelationFilter
    jobs?: JobListRelationFilter
    variancePatterns?: VariancePatternListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    sqft?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    garage?: SortOrderInput | SortOrder
    style?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    pdssUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    elevations?: PlanElevationOrderByRelationAggregateInput
    options?: PlanOptionOrderByRelationAggregateInput
    templateItems?: PlanTemplateItemOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
    variancePatterns?: VariancePatternOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringNullableFilter<"Plan"> | string | null
    type?: EnumPlanTypeFilter<"Plan"> | $Enums.PlanType
    sqft?: IntNullableFilter<"Plan"> | number | null
    bedrooms?: IntNullableFilter<"Plan"> | number | null
    bathrooms?: DecimalNullableFilter<"Plan"> | Decimal | DecimalJsLike | number | string | null
    garage?: StringNullableFilter<"Plan"> | string | null
    style?: StringNullableFilter<"Plan"> | string | null
    version?: IntFilter<"Plan"> | number
    isActive?: BoolFilter<"Plan"> | boolean
    pdssUrl?: StringNullableFilter<"Plan"> | string | null
    notes?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    elevations?: PlanElevationListRelationFilter
    options?: PlanOptionListRelationFilter
    templateItems?: PlanTemplateItemListRelationFilter
    jobs?: JobListRelationFilter
    variancePatterns?: VariancePatternListRelationFilter
  }, "id" | "code">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    sqft?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    garage?: SortOrderInput | SortOrder
    style?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    pdssUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    code?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    type?: EnumPlanTypeWithAggregatesFilter<"Plan"> | $Enums.PlanType
    sqft?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    bedrooms?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    bathrooms?: DecimalNullableWithAggregatesFilter<"Plan"> | Decimal | DecimalJsLike | number | string | null
    garage?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    style?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    version?: IntWithAggregatesFilter<"Plan"> | number
    isActive?: BoolWithAggregatesFilter<"Plan"> | boolean
    pdssUrl?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type PlanElevationWhereInput = {
    AND?: PlanElevationWhereInput | PlanElevationWhereInput[]
    OR?: PlanElevationWhereInput[]
    NOT?: PlanElevationWhereInput | PlanElevationWhereInput[]
    id?: StringFilter<"PlanElevation"> | string
    planId?: StringFilter<"PlanElevation"> | string
    code?: StringFilter<"PlanElevation"> | string
    name?: StringNullableFilter<"PlanElevation"> | string | null
    description?: StringNullableFilter<"PlanElevation"> | string | null
    imageUrl?: StringNullableFilter<"PlanElevation"> | string | null
    createdAt?: DateTimeFilter<"PlanElevation"> | Date | string
    updatedAt?: DateTimeFilter<"PlanElevation"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    jobs?: JobListRelationFilter
  }

  export type PlanElevationOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
    jobs?: JobOrderByRelationAggregateInput
  }

  export type PlanElevationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId_code?: PlanElevationPlanIdCodeCompoundUniqueInput
    AND?: PlanElevationWhereInput | PlanElevationWhereInput[]
    OR?: PlanElevationWhereInput[]
    NOT?: PlanElevationWhereInput | PlanElevationWhereInput[]
    planId?: StringFilter<"PlanElevation"> | string
    code?: StringFilter<"PlanElevation"> | string
    name?: StringNullableFilter<"PlanElevation"> | string | null
    description?: StringNullableFilter<"PlanElevation"> | string | null
    imageUrl?: StringNullableFilter<"PlanElevation"> | string | null
    createdAt?: DateTimeFilter<"PlanElevation"> | Date | string
    updatedAt?: DateTimeFilter<"PlanElevation"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    jobs?: JobListRelationFilter
  }, "id" | "planId_code">

  export type PlanElevationOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanElevationCountOrderByAggregateInput
    _max?: PlanElevationMaxOrderByAggregateInput
    _min?: PlanElevationMinOrderByAggregateInput
  }

  export type PlanElevationScalarWhereWithAggregatesInput = {
    AND?: PlanElevationScalarWhereWithAggregatesInput | PlanElevationScalarWhereWithAggregatesInput[]
    OR?: PlanElevationScalarWhereWithAggregatesInput[]
    NOT?: PlanElevationScalarWhereWithAggregatesInput | PlanElevationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanElevation"> | string
    planId?: StringWithAggregatesFilter<"PlanElevation"> | string
    code?: StringWithAggregatesFilter<"PlanElevation"> | string
    name?: StringNullableWithAggregatesFilter<"PlanElevation"> | string | null
    description?: StringNullableWithAggregatesFilter<"PlanElevation"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"PlanElevation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlanElevation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanElevation"> | Date | string
  }

  export type PlanOptionWhereInput = {
    AND?: PlanOptionWhereInput | PlanOptionWhereInput[]
    OR?: PlanOptionWhereInput[]
    NOT?: PlanOptionWhereInput | PlanOptionWhereInput[]
    id?: StringFilter<"PlanOption"> | string
    code?: StringFilter<"PlanOption"> | string
    name?: StringFilter<"PlanOption"> | string
    description?: StringNullableFilter<"PlanOption"> | string | null
    category?: EnumOptionCategoryFilter<"PlanOption"> | $Enums.OptionCategory
    basePrice?: DecimalFilter<"PlanOption"> | Decimal | DecimalJsLike | number | string
    triggersPacks?: StringNullableListFilter<"PlanOption">
    appliesTo?: StringNullableListFilter<"PlanOption">
    createdAt?: DateTimeFilter<"PlanOption"> | Date | string
    updatedAt?: DateTimeFilter<"PlanOption"> | Date | string
    plans?: PlanListRelationFilter
    jobOptions?: JobOptionListRelationFilter
  }

  export type PlanOptionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    triggersPacks?: SortOrder
    appliesTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plans?: PlanOrderByRelationAggregateInput
    jobOptions?: JobOptionOrderByRelationAggregateInput
  }

  export type PlanOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PlanOptionWhereInput | PlanOptionWhereInput[]
    OR?: PlanOptionWhereInput[]
    NOT?: PlanOptionWhereInput | PlanOptionWhereInput[]
    name?: StringFilter<"PlanOption"> | string
    description?: StringNullableFilter<"PlanOption"> | string | null
    category?: EnumOptionCategoryFilter<"PlanOption"> | $Enums.OptionCategory
    basePrice?: DecimalFilter<"PlanOption"> | Decimal | DecimalJsLike | number | string
    triggersPacks?: StringNullableListFilter<"PlanOption">
    appliesTo?: StringNullableListFilter<"PlanOption">
    createdAt?: DateTimeFilter<"PlanOption"> | Date | string
    updatedAt?: DateTimeFilter<"PlanOption"> | Date | string
    plans?: PlanListRelationFilter
    jobOptions?: JobOptionListRelationFilter
  }, "id" | "code">

  export type PlanOptionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    triggersPacks?: SortOrder
    appliesTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanOptionCountOrderByAggregateInput
    _avg?: PlanOptionAvgOrderByAggregateInput
    _max?: PlanOptionMaxOrderByAggregateInput
    _min?: PlanOptionMinOrderByAggregateInput
    _sum?: PlanOptionSumOrderByAggregateInput
  }

  export type PlanOptionScalarWhereWithAggregatesInput = {
    AND?: PlanOptionScalarWhereWithAggregatesInput | PlanOptionScalarWhereWithAggregatesInput[]
    OR?: PlanOptionScalarWhereWithAggregatesInput[]
    NOT?: PlanOptionScalarWhereWithAggregatesInput | PlanOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanOption"> | string
    code?: StringWithAggregatesFilter<"PlanOption"> | string
    name?: StringWithAggregatesFilter<"PlanOption"> | string
    description?: StringNullableWithAggregatesFilter<"PlanOption"> | string | null
    category?: EnumOptionCategoryWithAggregatesFilter<"PlanOption"> | $Enums.OptionCategory
    basePrice?: DecimalWithAggregatesFilter<"PlanOption"> | Decimal | DecimalJsLike | number | string
    triggersPacks?: StringNullableListFilter<"PlanOption">
    appliesTo?: StringNullableListFilter<"PlanOption">
    createdAt?: DateTimeWithAggregatesFilter<"PlanOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanOption"> | Date | string
  }

  export type PlanTemplateItemWhereInput = {
    AND?: PlanTemplateItemWhereInput | PlanTemplateItemWhereInput[]
    OR?: PlanTemplateItemWhereInput[]
    NOT?: PlanTemplateItemWhereInput | PlanTemplateItemWhereInput[]
    id?: StringFilter<"PlanTemplateItem"> | string
    planId?: StringFilter<"PlanTemplateItem"> | string
    materialId?: StringFilter<"PlanTemplateItem"> | string
    quantity?: DecimalFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"PlanTemplateItem"> | string
    wasteFactor?: DecimalFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"PlanTemplateItem"> | string
    subcategory?: StringNullableFilter<"PlanTemplateItem"> | string | null
    averageVariance?: DecimalNullableFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFilter<"PlanTemplateItem"> | number
    lastVarianceDate?: DateTimeNullableFilter<"PlanTemplateItem"> | Date | string | null
    confidenceScore?: DecimalNullableFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"PlanTemplateItem"> | string | null
    createdAt?: DateTimeFilter<"PlanTemplateItem"> | Date | string
    updatedAt?: DateTimeFilter<"PlanTemplateItem"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }

  export type PlanTemplateItemOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    wasteFactor?: SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    averageVariance?: SortOrderInput | SortOrder
    varianceCount?: SortOrder
    lastVarianceDate?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
  }

  export type PlanTemplateItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId_materialId?: PlanTemplateItemPlanIdMaterialIdCompoundUniqueInput
    AND?: PlanTemplateItemWhereInput | PlanTemplateItemWhereInput[]
    OR?: PlanTemplateItemWhereInput[]
    NOT?: PlanTemplateItemWhereInput | PlanTemplateItemWhereInput[]
    planId?: StringFilter<"PlanTemplateItem"> | string
    materialId?: StringFilter<"PlanTemplateItem"> | string
    quantity?: DecimalFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"PlanTemplateItem"> | string
    wasteFactor?: DecimalFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"PlanTemplateItem"> | string
    subcategory?: StringNullableFilter<"PlanTemplateItem"> | string | null
    averageVariance?: DecimalNullableFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFilter<"PlanTemplateItem"> | number
    lastVarianceDate?: DateTimeNullableFilter<"PlanTemplateItem"> | Date | string | null
    confidenceScore?: DecimalNullableFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"PlanTemplateItem"> | string | null
    createdAt?: DateTimeFilter<"PlanTemplateItem"> | Date | string
    updatedAt?: DateTimeFilter<"PlanTemplateItem"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }, "id" | "planId_materialId">

  export type PlanTemplateItemOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    wasteFactor?: SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    averageVariance?: SortOrderInput | SortOrder
    varianceCount?: SortOrder
    lastVarianceDate?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanTemplateItemCountOrderByAggregateInput
    _avg?: PlanTemplateItemAvgOrderByAggregateInput
    _max?: PlanTemplateItemMaxOrderByAggregateInput
    _min?: PlanTemplateItemMinOrderByAggregateInput
    _sum?: PlanTemplateItemSumOrderByAggregateInput
  }

  export type PlanTemplateItemScalarWhereWithAggregatesInput = {
    AND?: PlanTemplateItemScalarWhereWithAggregatesInput | PlanTemplateItemScalarWhereWithAggregatesInput[]
    OR?: PlanTemplateItemScalarWhereWithAggregatesInput[]
    NOT?: PlanTemplateItemScalarWhereWithAggregatesInput | PlanTemplateItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanTemplateItem"> | string
    planId?: StringWithAggregatesFilter<"PlanTemplateItem"> | string
    materialId?: StringWithAggregatesFilter<"PlanTemplateItem"> | string
    quantity?: DecimalWithAggregatesFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"PlanTemplateItem"> | string
    wasteFactor?: DecimalWithAggregatesFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string
    category?: StringWithAggregatesFilter<"PlanTemplateItem"> | string
    subcategory?: StringNullableWithAggregatesFilter<"PlanTemplateItem"> | string | null
    averageVariance?: DecimalNullableWithAggregatesFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntWithAggregatesFilter<"PlanTemplateItem"> | number
    lastVarianceDate?: DateTimeNullableWithAggregatesFilter<"PlanTemplateItem"> | Date | string | null
    confidenceScore?: DecimalNullableWithAggregatesFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"PlanTemplateItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlanTemplateItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanTemplateItem"> | Date | string
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: StringFilter<"Material"> | string
    sku?: StringFilter<"Material"> | string
    description?: StringFilter<"Material"> | string
    category?: EnumMaterialCategoryFilter<"Material"> | $Enums.MaterialCategory
    subcategory?: StringNullableFilter<"Material"> | string | null
    unitOfMeasure?: StringFilter<"Material"> | string
    vendorCost?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    freight?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFilter<"Material"> | boolean
    rlTag?: StringNullableFilter<"Material"> | string | null
    rlBasePrice?: DecimalNullableFilter<"Material"> | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: DateTimeNullableFilter<"Material"> | Date | string | null
    lengthAdders?: JsonNullableFilter<"Material">
    gradeMultipliers?: JsonNullableFilter<"Material">
    isActive?: BoolFilter<"Material"> | boolean
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    vendorId?: StringNullableFilter<"Material"> | string | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    pricingHistory?: PricingHistoryListRelationFilter
    templateItems?: PlanTemplateItemListRelationFilter
    customerPricing?: CustomerPricingListRelationFilter
    takeoffLineItems?: TakeoffLineItemListRelationFilter
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    unitOfMeasure?: SortOrder
    vendorCost?: SortOrder
    freight?: SortOrder
    isRLLinked?: SortOrder
    rlTag?: SortOrderInput | SortOrder
    rlBasePrice?: SortOrderInput | SortOrder
    rlLastUpdated?: SortOrderInput | SortOrder
    lengthAdders?: SortOrderInput | SortOrder
    gradeMultipliers?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    vendor?: VendorOrderByWithRelationInput
    pricingHistory?: PricingHistoryOrderByRelationAggregateInput
    templateItems?: PlanTemplateItemOrderByRelationAggregateInput
    customerPricing?: CustomerPricingOrderByRelationAggregateInput
    takeoffLineItems?: TakeoffLineItemOrderByRelationAggregateInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    description?: StringFilter<"Material"> | string
    category?: EnumMaterialCategoryFilter<"Material"> | $Enums.MaterialCategory
    subcategory?: StringNullableFilter<"Material"> | string | null
    unitOfMeasure?: StringFilter<"Material"> | string
    vendorCost?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    freight?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFilter<"Material"> | boolean
    rlTag?: StringNullableFilter<"Material"> | string | null
    rlBasePrice?: DecimalNullableFilter<"Material"> | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: DateTimeNullableFilter<"Material"> | Date | string | null
    lengthAdders?: JsonNullableFilter<"Material">
    gradeMultipliers?: JsonNullableFilter<"Material">
    isActive?: BoolFilter<"Material"> | boolean
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    vendorId?: StringNullableFilter<"Material"> | string | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    pricingHistory?: PricingHistoryListRelationFilter
    templateItems?: PlanTemplateItemListRelationFilter
    customerPricing?: CustomerPricingListRelationFilter
    takeoffLineItems?: TakeoffLineItemListRelationFilter
  }, "id" | "sku">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    unitOfMeasure?: SortOrder
    vendorCost?: SortOrder
    freight?: SortOrder
    isRLLinked?: SortOrder
    rlTag?: SortOrderInput | SortOrder
    rlBasePrice?: SortOrderInput | SortOrder
    rlLastUpdated?: SortOrderInput | SortOrder
    lengthAdders?: SortOrderInput | SortOrder
    gradeMultipliers?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Material"> | string
    sku?: StringWithAggregatesFilter<"Material"> | string
    description?: StringWithAggregatesFilter<"Material"> | string
    category?: EnumMaterialCategoryWithAggregatesFilter<"Material"> | $Enums.MaterialCategory
    subcategory?: StringNullableWithAggregatesFilter<"Material"> | string | null
    unitOfMeasure?: StringWithAggregatesFilter<"Material"> | string
    vendorCost?: DecimalWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string
    freight?: DecimalWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolWithAggregatesFilter<"Material"> | boolean
    rlTag?: StringNullableWithAggregatesFilter<"Material"> | string | null
    rlBasePrice?: DecimalNullableWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: DateTimeNullableWithAggregatesFilter<"Material"> | Date | string | null
    lengthAdders?: JsonNullableWithAggregatesFilter<"Material">
    gradeMultipliers?: JsonNullableWithAggregatesFilter<"Material">
    isActive?: BoolWithAggregatesFilter<"Material"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    vendorId?: StringNullableWithAggregatesFilter<"Material"> | string | null
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    code?: StringFilter<"Vendor"> | string
    primaryContact?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    paymentTerms?: StringNullableFilter<"Vendor"> | string | null
    leadTimeDays?: IntFilter<"Vendor"> | number
    isActive?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    materials?: MaterialListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    primaryContact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    leadTimeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    materials?: MaterialOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    primaryContact?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    paymentTerms?: StringNullableFilter<"Vendor"> | string | null
    leadTimeDays?: IntFilter<"Vendor"> | number
    isActive?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    materials?: MaterialListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
  }, "id" | "code">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    primaryContact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    leadTimeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    name?: StringWithAggregatesFilter<"Vendor"> | string
    code?: StringWithAggregatesFilter<"Vendor"> | string
    primaryContact?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    leadTimeDays?: IntWithAggregatesFilter<"Vendor"> | number
    isActive?: BoolWithAggregatesFilter<"Vendor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type PricingHistoryWhereInput = {
    AND?: PricingHistoryWhereInput | PricingHistoryWhereInput[]
    OR?: PricingHistoryWhereInput[]
    NOT?: PricingHistoryWhereInput | PricingHistoryWhereInput[]
    id?: StringFilter<"PricingHistory"> | string
    materialId?: StringFilter<"PricingHistory"> | string
    baseVendorCost?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    freight?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonFilter<"PricingHistory">
    effectiveDate?: DateTimeFilter<"PricingHistory"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PricingHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"PricingHistory"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }

  export type PricingHistoryOrderByWithRelationInput = {
    id?: SortOrder
    materialId?: SortOrder
    baseVendorCost?: SortOrder
    commodityAdjustment?: SortOrder
    freight?: SortOrder
    totalCost?: SortOrder
    marginPercentage?: SortOrder
    marginAmount?: SortOrder
    unitPrice?: SortOrder
    calculationSteps?: SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    material?: MaterialOrderByWithRelationInput
  }

  export type PricingHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PricingHistoryWhereInput | PricingHistoryWhereInput[]
    OR?: PricingHistoryWhereInput[]
    NOT?: PricingHistoryWhereInput | PricingHistoryWhereInput[]
    materialId?: StringFilter<"PricingHistory"> | string
    baseVendorCost?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    freight?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonFilter<"PricingHistory">
    effectiveDate?: DateTimeFilter<"PricingHistory"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PricingHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"PricingHistory"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }, "id">

  export type PricingHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    materialId?: SortOrder
    baseVendorCost?: SortOrder
    commodityAdjustment?: SortOrder
    freight?: SortOrder
    totalCost?: SortOrder
    marginPercentage?: SortOrder
    marginAmount?: SortOrder
    unitPrice?: SortOrder
    calculationSteps?: SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PricingHistoryCountOrderByAggregateInput
    _avg?: PricingHistoryAvgOrderByAggregateInput
    _max?: PricingHistoryMaxOrderByAggregateInput
    _min?: PricingHistoryMinOrderByAggregateInput
    _sum?: PricingHistorySumOrderByAggregateInput
  }

  export type PricingHistoryScalarWhereWithAggregatesInput = {
    AND?: PricingHistoryScalarWhereWithAggregatesInput | PricingHistoryScalarWhereWithAggregatesInput[]
    OR?: PricingHistoryScalarWhereWithAggregatesInput[]
    NOT?: PricingHistoryScalarWhereWithAggregatesInput | PricingHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PricingHistory"> | string
    materialId?: StringWithAggregatesFilter<"PricingHistory"> | string
    baseVendorCost?: DecimalWithAggregatesFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalWithAggregatesFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    freight?: DecimalWithAggregatesFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalWithAggregatesFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalWithAggregatesFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalWithAggregatesFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonWithAggregatesFilter<"PricingHistory">
    effectiveDate?: DateTimeWithAggregatesFilter<"PricingHistory"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PricingHistory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PricingHistory"> | Date | string
  }

  export type RandomLengthsPricingWhereInput = {
    AND?: RandomLengthsPricingWhereInput | RandomLengthsPricingWhereInput[]
    OR?: RandomLengthsPricingWhereInput[]
    NOT?: RandomLengthsPricingWhereInput | RandomLengthsPricingWhereInput[]
    id?: StringFilter<"RandomLengthsPricing"> | string
    tag?: StringFilter<"RandomLengthsPricing"> | string
    description?: StringFilter<"RandomLengthsPricing"> | string
    price?: DecimalFilter<"RandomLengthsPricing"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RandomLengthsPricing"> | string
    region?: StringNullableFilter<"RandomLengthsPricing"> | string | null
    grade?: StringNullableFilter<"RandomLengthsPricing"> | string | null
    effectiveDate?: DateTimeFilter<"RandomLengthsPricing"> | Date | string
    source?: StringFilter<"RandomLengthsPricing"> | string
    createdAt?: DateTimeFilter<"RandomLengthsPricing"> | Date | string
  }

  export type RandomLengthsPricingOrderByWithRelationInput = {
    id?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    region?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type RandomLengthsPricingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag_effectiveDate?: RandomLengthsPricingTagEffectiveDateCompoundUniqueInput
    AND?: RandomLengthsPricingWhereInput | RandomLengthsPricingWhereInput[]
    OR?: RandomLengthsPricingWhereInput[]
    NOT?: RandomLengthsPricingWhereInput | RandomLengthsPricingWhereInput[]
    tag?: StringFilter<"RandomLengthsPricing"> | string
    description?: StringFilter<"RandomLengthsPricing"> | string
    price?: DecimalFilter<"RandomLengthsPricing"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RandomLengthsPricing"> | string
    region?: StringNullableFilter<"RandomLengthsPricing"> | string | null
    grade?: StringNullableFilter<"RandomLengthsPricing"> | string | null
    effectiveDate?: DateTimeFilter<"RandomLengthsPricing"> | Date | string
    source?: StringFilter<"RandomLengthsPricing"> | string
    createdAt?: DateTimeFilter<"RandomLengthsPricing"> | Date | string
  }, "id" | "tag_effectiveDate">

  export type RandomLengthsPricingOrderByWithAggregationInput = {
    id?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    region?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    _count?: RandomLengthsPricingCountOrderByAggregateInput
    _avg?: RandomLengthsPricingAvgOrderByAggregateInput
    _max?: RandomLengthsPricingMaxOrderByAggregateInput
    _min?: RandomLengthsPricingMinOrderByAggregateInput
    _sum?: RandomLengthsPricingSumOrderByAggregateInput
  }

  export type RandomLengthsPricingScalarWhereWithAggregatesInput = {
    AND?: RandomLengthsPricingScalarWhereWithAggregatesInput | RandomLengthsPricingScalarWhereWithAggregatesInput[]
    OR?: RandomLengthsPricingScalarWhereWithAggregatesInput[]
    NOT?: RandomLengthsPricingScalarWhereWithAggregatesInput | RandomLengthsPricingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RandomLengthsPricing"> | string
    tag?: StringWithAggregatesFilter<"RandomLengthsPricing"> | string
    description?: StringWithAggregatesFilter<"RandomLengthsPricing"> | string
    price?: DecimalWithAggregatesFilter<"RandomLengthsPricing"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"RandomLengthsPricing"> | string
    region?: StringNullableWithAggregatesFilter<"RandomLengthsPricing"> | string | null
    grade?: StringNullableWithAggregatesFilter<"RandomLengthsPricing"> | string | null
    effectiveDate?: DateTimeWithAggregatesFilter<"RandomLengthsPricing"> | Date | string
    source?: StringWithAggregatesFilter<"RandomLengthsPricing"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RandomLengthsPricing"> | Date | string
  }

  export type CommunityWhereInput = {
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    id?: StringFilter<"Community"> | string
    name?: StringFilter<"Community"> | string
    customerId?: StringFilter<"Community"> | string
    shippingYard?: StringFilter<"Community"> | string
    jurisdiction?: StringNullableFilter<"Community"> | string | null
    region?: StringNullableFilter<"Community"> | string | null
    activePlans?: IntFilter<"Community"> | number
    isActive?: BoolFilter<"Community"> | boolean
    specialRequirements?: StringNullableFilter<"Community"> | string | null
    createdAt?: DateTimeFilter<"Community"> | Date | string
    updatedAt?: DateTimeFilter<"Community"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    lots?: LotListRelationFilter
    jobs?: JobListRelationFilter
    variancePatterns?: VariancePatternListRelationFilter
  }

  export type CommunityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
    shippingYard?: SortOrder
    jurisdiction?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    activePlans?: SortOrder
    isActive?: SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    lots?: LotOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
    variancePatterns?: VariancePatternOrderByRelationAggregateInput
  }

  export type CommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    name?: StringFilter<"Community"> | string
    customerId?: StringFilter<"Community"> | string
    shippingYard?: StringFilter<"Community"> | string
    jurisdiction?: StringNullableFilter<"Community"> | string | null
    region?: StringNullableFilter<"Community"> | string | null
    activePlans?: IntFilter<"Community"> | number
    isActive?: BoolFilter<"Community"> | boolean
    specialRequirements?: StringNullableFilter<"Community"> | string | null
    createdAt?: DateTimeFilter<"Community"> | Date | string
    updatedAt?: DateTimeFilter<"Community"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    lots?: LotListRelationFilter
    jobs?: JobListRelationFilter
    variancePatterns?: VariancePatternListRelationFilter
  }, "id">

  export type CommunityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
    shippingYard?: SortOrder
    jurisdiction?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    activePlans?: SortOrder
    isActive?: SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityCountOrderByAggregateInput
    _avg?: CommunityAvgOrderByAggregateInput
    _max?: CommunityMaxOrderByAggregateInput
    _min?: CommunityMinOrderByAggregateInput
    _sum?: CommunitySumOrderByAggregateInput
  }

  export type CommunityScalarWhereWithAggregatesInput = {
    AND?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    OR?: CommunityScalarWhereWithAggregatesInput[]
    NOT?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Community"> | string
    name?: StringWithAggregatesFilter<"Community"> | string
    customerId?: StringWithAggregatesFilter<"Community"> | string
    shippingYard?: StringWithAggregatesFilter<"Community"> | string
    jurisdiction?: StringNullableWithAggregatesFilter<"Community"> | string | null
    region?: StringNullableWithAggregatesFilter<"Community"> | string | null
    activePlans?: IntWithAggregatesFilter<"Community"> | number
    isActive?: BoolWithAggregatesFilter<"Community"> | boolean
    specialRequirements?: StringNullableWithAggregatesFilter<"Community"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Community"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Community"> | Date | string
  }

  export type LotWhereInput = {
    AND?: LotWhereInput | LotWhereInput[]
    OR?: LotWhereInput[]
    NOT?: LotWhereInput | LotWhereInput[]
    id?: StringFilter<"Lot"> | string
    communityId?: StringFilter<"Lot"> | string
    lotNumber?: StringFilter<"Lot"> | string
    status?: EnumLotStatusFilter<"Lot"> | $Enums.LotStatus
    sqft?: IntNullableFilter<"Lot"> | number | null
    frontage?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    depth?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Lot"> | string | null
    createdAt?: DateTimeFilter<"Lot"> | Date | string
    updatedAt?: DateTimeFilter<"Lot"> | Date | string
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    jobs?: JobListRelationFilter
  }

  export type LotOrderByWithRelationInput = {
    id?: SortOrder
    communityId?: SortOrder
    lotNumber?: SortOrder
    status?: SortOrder
    sqft?: SortOrderInput | SortOrder
    frontage?: SortOrderInput | SortOrder
    depth?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    community?: CommunityOrderByWithRelationInput
    jobs?: JobOrderByRelationAggregateInput
  }

  export type LotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    communityId_lotNumber?: LotCommunityIdLotNumberCompoundUniqueInput
    AND?: LotWhereInput | LotWhereInput[]
    OR?: LotWhereInput[]
    NOT?: LotWhereInput | LotWhereInput[]
    communityId?: StringFilter<"Lot"> | string
    lotNumber?: StringFilter<"Lot"> | string
    status?: EnumLotStatusFilter<"Lot"> | $Enums.LotStatus
    sqft?: IntNullableFilter<"Lot"> | number | null
    frontage?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    depth?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Lot"> | string | null
    createdAt?: DateTimeFilter<"Lot"> | Date | string
    updatedAt?: DateTimeFilter<"Lot"> | Date | string
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    jobs?: JobListRelationFilter
  }, "id" | "communityId_lotNumber">

  export type LotOrderByWithAggregationInput = {
    id?: SortOrder
    communityId?: SortOrder
    lotNumber?: SortOrder
    status?: SortOrder
    sqft?: SortOrderInput | SortOrder
    frontage?: SortOrderInput | SortOrder
    depth?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LotCountOrderByAggregateInput
    _avg?: LotAvgOrderByAggregateInput
    _max?: LotMaxOrderByAggregateInput
    _min?: LotMinOrderByAggregateInput
    _sum?: LotSumOrderByAggregateInput
  }

  export type LotScalarWhereWithAggregatesInput = {
    AND?: LotScalarWhereWithAggregatesInput | LotScalarWhereWithAggregatesInput[]
    OR?: LotScalarWhereWithAggregatesInput[]
    NOT?: LotScalarWhereWithAggregatesInput | LotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lot"> | string
    communityId?: StringWithAggregatesFilter<"Lot"> | string
    lotNumber?: StringWithAggregatesFilter<"Lot"> | string
    status?: EnumLotStatusWithAggregatesFilter<"Lot"> | $Enums.LotStatus
    sqft?: IntNullableWithAggregatesFilter<"Lot"> | number | null
    frontage?: DecimalNullableWithAggregatesFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    depth?: DecimalNullableWithAggregatesFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"Lot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lot"> | Date | string
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: StringFilter<"Job"> | string
    jobNumber?: StringFilter<"Job"> | string
    customerId?: StringFilter<"Job"> | string
    planId?: StringFilter<"Job"> | string
    elevationId?: StringNullableFilter<"Job"> | string | null
    communityId?: StringNullableFilter<"Job"> | string | null
    lotId?: StringNullableFilter<"Job"> | string | null
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    estimatedCost?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    actualCost?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    margin?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFilter<"Job"> | string
    approvedById?: StringNullableFilter<"Job"> | string | null
    approvedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    completionDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    notes?: StringNullableFilter<"Job"> | string | null
    folderPath?: StringNullableFilter<"Job"> | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    elevation?: XOR<PlanElevationNullableScalarRelationFilter, PlanElevationWhereInput> | null
    community?: XOR<CommunityNullableScalarRelationFilter, CommunityWhereInput> | null
    lot?: XOR<LotNullableScalarRelationFilter, LotWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    jobOptions?: JobOptionListRelationFilter
    takeoff?: XOR<TakeoffNullableScalarRelationFilter, TakeoffWhereInput> | null
    purchaseOrders?: PurchaseOrderListRelationFilter
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    elevationId?: SortOrderInput | SortOrder
    communityId?: SortOrderInput | SortOrder
    lotId?: SortOrderInput | SortOrder
    status?: SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    margin?: SortOrderInput | SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
    elevation?: PlanElevationOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
    lot?: LotOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
    jobOptions?: JobOptionOrderByRelationAggregateInput
    takeoff?: TakeoffOrderByWithRelationInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobNumber?: string
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    customerId?: StringFilter<"Job"> | string
    planId?: StringFilter<"Job"> | string
    elevationId?: StringNullableFilter<"Job"> | string | null
    communityId?: StringNullableFilter<"Job"> | string | null
    lotId?: StringNullableFilter<"Job"> | string | null
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    estimatedCost?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    actualCost?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    margin?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFilter<"Job"> | string
    approvedById?: StringNullableFilter<"Job"> | string | null
    approvedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    completionDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    notes?: StringNullableFilter<"Job"> | string | null
    folderPath?: StringNullableFilter<"Job"> | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    elevation?: XOR<PlanElevationNullableScalarRelationFilter, PlanElevationWhereInput> | null
    community?: XOR<CommunityNullableScalarRelationFilter, CommunityWhereInput> | null
    lot?: XOR<LotNullableScalarRelationFilter, LotWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    jobOptions?: JobOptionListRelationFilter
    takeoff?: XOR<TakeoffNullableScalarRelationFilter, TakeoffWhereInput> | null
    purchaseOrders?: PurchaseOrderListRelationFilter
  }, "id" | "jobNumber">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    elevationId?: SortOrderInput | SortOrder
    communityId?: SortOrderInput | SortOrder
    lotId?: SortOrderInput | SortOrder
    status?: SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    margin?: SortOrderInput | SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Job"> | string
    jobNumber?: StringWithAggregatesFilter<"Job"> | string
    customerId?: StringWithAggregatesFilter<"Job"> | string
    planId?: StringWithAggregatesFilter<"Job"> | string
    elevationId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    communityId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    lotId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    status?: EnumJobStatusWithAggregatesFilter<"Job"> | $Enums.JobStatus
    estimatedCost?: DecimalNullableWithAggregatesFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    actualCost?: DecimalNullableWithAggregatesFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    margin?: DecimalNullableWithAggregatesFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    createdById?: StringWithAggregatesFilter<"Job"> | string
    approvedById?: StringNullableWithAggregatesFilter<"Job"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    completionDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Job"> | string | null
    folderPath?: StringNullableWithAggregatesFilter<"Job"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
  }

  export type JobOptionWhereInput = {
    AND?: JobOptionWhereInput | JobOptionWhereInput[]
    OR?: JobOptionWhereInput[]
    NOT?: JobOptionWhereInput | JobOptionWhereInput[]
    id?: StringFilter<"JobOption"> | string
    jobId?: StringFilter<"JobOption"> | string
    optionId?: StringFilter<"JobOption"> | string
    quantity?: IntFilter<"JobOption"> | number
    price?: DecimalFilter<"JobOption"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"JobOption"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    option?: XOR<PlanOptionScalarRelationFilter, PlanOptionWhereInput>
  }

  export type JobOptionOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    optionId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    job?: JobOrderByWithRelationInput
    option?: PlanOptionOrderByWithRelationInput
  }

  export type JobOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId_optionId?: JobOptionJobIdOptionIdCompoundUniqueInput
    AND?: JobOptionWhereInput | JobOptionWhereInput[]
    OR?: JobOptionWhereInput[]
    NOT?: JobOptionWhereInput | JobOptionWhereInput[]
    jobId?: StringFilter<"JobOption"> | string
    optionId?: StringFilter<"JobOption"> | string
    quantity?: IntFilter<"JobOption"> | number
    price?: DecimalFilter<"JobOption"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"JobOption"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    option?: XOR<PlanOptionScalarRelationFilter, PlanOptionWhereInput>
  }, "id" | "jobId_optionId">

  export type JobOptionOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    optionId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    _count?: JobOptionCountOrderByAggregateInput
    _avg?: JobOptionAvgOrderByAggregateInput
    _max?: JobOptionMaxOrderByAggregateInput
    _min?: JobOptionMinOrderByAggregateInput
    _sum?: JobOptionSumOrderByAggregateInput
  }

  export type JobOptionScalarWhereWithAggregatesInput = {
    AND?: JobOptionScalarWhereWithAggregatesInput | JobOptionScalarWhereWithAggregatesInput[]
    OR?: JobOptionScalarWhereWithAggregatesInput[]
    NOT?: JobOptionScalarWhereWithAggregatesInput | JobOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobOption"> | string
    jobId?: StringWithAggregatesFilter<"JobOption"> | string
    optionId?: StringWithAggregatesFilter<"JobOption"> | string
    quantity?: IntWithAggregatesFilter<"JobOption"> | number
    price?: DecimalWithAggregatesFilter<"JobOption"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"JobOption"> | Date | string
  }

  export type TakeoffWhereInput = {
    AND?: TakeoffWhereInput | TakeoffWhereInput[]
    OR?: TakeoffWhereInput[]
    NOT?: TakeoffWhereInput | TakeoffWhereInput[]
    id?: StringFilter<"Takeoff"> | string
    jobId?: StringFilter<"Takeoff"> | string
    status?: EnumTakeoffStatusFilter<"Takeoff"> | $Enums.TakeoffStatus
    isValidated?: BoolFilter<"Takeoff"> | boolean
    validatedAt?: DateTimeNullableFilter<"Takeoff"> | Date | string | null
    validationResults?: JsonNullableFilter<"Takeoff">
    totalEstimated?: DecimalFilter<"Takeoff"> | Decimal | DecimalJsLike | number | string
    totalActual?: DecimalNullableFilter<"Takeoff"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Takeoff"> | Date | string
    updatedAt?: DateTimeFilter<"Takeoff"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    lineItems?: TakeoffLineItemListRelationFilter
    validation?: XOR<TakeoffValidationNullableScalarRelationFilter, TakeoffValidationWhereInput> | null
  }

  export type TakeoffOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validationResults?: SortOrderInput | SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    job?: JobOrderByWithRelationInput
    lineItems?: TakeoffLineItemOrderByRelationAggregateInput
    validation?: TakeoffValidationOrderByWithRelationInput
  }

  export type TakeoffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId?: string
    AND?: TakeoffWhereInput | TakeoffWhereInput[]
    OR?: TakeoffWhereInput[]
    NOT?: TakeoffWhereInput | TakeoffWhereInput[]
    status?: EnumTakeoffStatusFilter<"Takeoff"> | $Enums.TakeoffStatus
    isValidated?: BoolFilter<"Takeoff"> | boolean
    validatedAt?: DateTimeNullableFilter<"Takeoff"> | Date | string | null
    validationResults?: JsonNullableFilter<"Takeoff">
    totalEstimated?: DecimalFilter<"Takeoff"> | Decimal | DecimalJsLike | number | string
    totalActual?: DecimalNullableFilter<"Takeoff"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Takeoff"> | Date | string
    updatedAt?: DateTimeFilter<"Takeoff"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    lineItems?: TakeoffLineItemListRelationFilter
    validation?: XOR<TakeoffValidationNullableScalarRelationFilter, TakeoffValidationWhereInput> | null
  }, "id" | "jobId">

  export type TakeoffOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validationResults?: SortOrderInput | SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TakeoffCountOrderByAggregateInput
    _avg?: TakeoffAvgOrderByAggregateInput
    _max?: TakeoffMaxOrderByAggregateInput
    _min?: TakeoffMinOrderByAggregateInput
    _sum?: TakeoffSumOrderByAggregateInput
  }

  export type TakeoffScalarWhereWithAggregatesInput = {
    AND?: TakeoffScalarWhereWithAggregatesInput | TakeoffScalarWhereWithAggregatesInput[]
    OR?: TakeoffScalarWhereWithAggregatesInput[]
    NOT?: TakeoffScalarWhereWithAggregatesInput | TakeoffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Takeoff"> | string
    jobId?: StringWithAggregatesFilter<"Takeoff"> | string
    status?: EnumTakeoffStatusWithAggregatesFilter<"Takeoff"> | $Enums.TakeoffStatus
    isValidated?: BoolWithAggregatesFilter<"Takeoff"> | boolean
    validatedAt?: DateTimeNullableWithAggregatesFilter<"Takeoff"> | Date | string | null
    validationResults?: JsonNullableWithAggregatesFilter<"Takeoff">
    totalEstimated?: DecimalWithAggregatesFilter<"Takeoff"> | Decimal | DecimalJsLike | number | string
    totalActual?: DecimalNullableWithAggregatesFilter<"Takeoff"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Takeoff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Takeoff"> | Date | string
  }

  export type TakeoffLineItemWhereInput = {
    AND?: TakeoffLineItemWhereInput | TakeoffLineItemWhereInput[]
    OR?: TakeoffLineItemWhereInput[]
    NOT?: TakeoffLineItemWhereInput | TakeoffLineItemWhereInput[]
    id?: StringFilter<"TakeoffLineItem"> | string
    takeoffId?: StringFilter<"TakeoffLineItem"> | string
    materialId?: StringFilter<"TakeoffLineItem"> | string
    quantityEstimated?: DecimalFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    quantityActual?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"TakeoffLineItem"> | string
    unitPrice?: DecimalFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    totalActual?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    variancePercent?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    varianceReason?: StringNullableFilter<"TakeoffLineItem"> | string | null
    category?: StringFilter<"TakeoffLineItem"> | string
    subcategory?: StringNullableFilter<"TakeoffLineItem"> | string | null
    notes?: StringNullableFilter<"TakeoffLineItem"> | string | null
    createdAt?: DateTimeFilter<"TakeoffLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"TakeoffLineItem"> | Date | string
    takeoff?: XOR<TakeoffScalarRelationFilter, TakeoffWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }

  export type TakeoffLineItemOrderByWithRelationInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    materialId?: SortOrder
    quantityEstimated?: SortOrder
    quantityActual?: SortOrderInput | SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    variancePercent?: SortOrderInput | SortOrder
    varianceReason?: SortOrderInput | SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    takeoff?: TakeoffOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
  }

  export type TakeoffLineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TakeoffLineItemWhereInput | TakeoffLineItemWhereInput[]
    OR?: TakeoffLineItemWhereInput[]
    NOT?: TakeoffLineItemWhereInput | TakeoffLineItemWhereInput[]
    takeoffId?: StringFilter<"TakeoffLineItem"> | string
    materialId?: StringFilter<"TakeoffLineItem"> | string
    quantityEstimated?: DecimalFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    quantityActual?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"TakeoffLineItem"> | string
    unitPrice?: DecimalFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    totalActual?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    variancePercent?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    varianceReason?: StringNullableFilter<"TakeoffLineItem"> | string | null
    category?: StringFilter<"TakeoffLineItem"> | string
    subcategory?: StringNullableFilter<"TakeoffLineItem"> | string | null
    notes?: StringNullableFilter<"TakeoffLineItem"> | string | null
    createdAt?: DateTimeFilter<"TakeoffLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"TakeoffLineItem"> | Date | string
    takeoff?: XOR<TakeoffScalarRelationFilter, TakeoffWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }, "id">

  export type TakeoffLineItemOrderByWithAggregationInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    materialId?: SortOrder
    quantityEstimated?: SortOrder
    quantityActual?: SortOrderInput | SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    variancePercent?: SortOrderInput | SortOrder
    varianceReason?: SortOrderInput | SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TakeoffLineItemCountOrderByAggregateInput
    _avg?: TakeoffLineItemAvgOrderByAggregateInput
    _max?: TakeoffLineItemMaxOrderByAggregateInput
    _min?: TakeoffLineItemMinOrderByAggregateInput
    _sum?: TakeoffLineItemSumOrderByAggregateInput
  }

  export type TakeoffLineItemScalarWhereWithAggregatesInput = {
    AND?: TakeoffLineItemScalarWhereWithAggregatesInput | TakeoffLineItemScalarWhereWithAggregatesInput[]
    OR?: TakeoffLineItemScalarWhereWithAggregatesInput[]
    NOT?: TakeoffLineItemScalarWhereWithAggregatesInput | TakeoffLineItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TakeoffLineItem"> | string
    takeoffId?: StringWithAggregatesFilter<"TakeoffLineItem"> | string
    materialId?: StringWithAggregatesFilter<"TakeoffLineItem"> | string
    quantityEstimated?: DecimalWithAggregatesFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    quantityActual?: DecimalNullableWithAggregatesFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringWithAggregatesFilter<"TakeoffLineItem"> | string
    unitPrice?: DecimalWithAggregatesFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalWithAggregatesFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    totalActual?: DecimalNullableWithAggregatesFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableWithAggregatesFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    variancePercent?: DecimalNullableWithAggregatesFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    varianceReason?: StringNullableWithAggregatesFilter<"TakeoffLineItem"> | string | null
    category?: StringWithAggregatesFilter<"TakeoffLineItem"> | string
    subcategory?: StringNullableWithAggregatesFilter<"TakeoffLineItem"> | string | null
    notes?: StringNullableWithAggregatesFilter<"TakeoffLineItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TakeoffLineItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TakeoffLineItem"> | Date | string
  }

  export type TakeoffValidationWhereInput = {
    AND?: TakeoffValidationWhereInput | TakeoffValidationWhereInput[]
    OR?: TakeoffValidationWhereInput[]
    NOT?: TakeoffValidationWhereInput | TakeoffValidationWhereInput[]
    id?: StringFilter<"TakeoffValidation"> | string
    takeoffId?: StringFilter<"TakeoffValidation"> | string
    specCompliant?: BoolFilter<"TakeoffValidation"> | boolean
    pricingCurrent?: BoolFilter<"TakeoffValidation"> | boolean
    varianceAcceptable?: BoolFilter<"TakeoffValidation"> | boolean
    issues?: JsonFilter<"TakeoffValidation">
    warnings?: JsonFilter<"TakeoffValidation">
    comparedToJobs?: StringNullableListFilter<"TakeoffValidation">
    avgVariance?: DecimalNullableFilter<"TakeoffValidation"> | Decimal | DecimalJsLike | number | string | null
    validatedAt?: DateTimeFilter<"TakeoffValidation"> | Date | string
    takeoff?: XOR<TakeoffScalarRelationFilter, TakeoffWhereInput>
  }

  export type TakeoffValidationOrderByWithRelationInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    specCompliant?: SortOrder
    pricingCurrent?: SortOrder
    varianceAcceptable?: SortOrder
    issues?: SortOrder
    warnings?: SortOrder
    comparedToJobs?: SortOrder
    avgVariance?: SortOrderInput | SortOrder
    validatedAt?: SortOrder
    takeoff?: TakeoffOrderByWithRelationInput
  }

  export type TakeoffValidationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    takeoffId?: string
    AND?: TakeoffValidationWhereInput | TakeoffValidationWhereInput[]
    OR?: TakeoffValidationWhereInput[]
    NOT?: TakeoffValidationWhereInput | TakeoffValidationWhereInput[]
    specCompliant?: BoolFilter<"TakeoffValidation"> | boolean
    pricingCurrent?: BoolFilter<"TakeoffValidation"> | boolean
    varianceAcceptable?: BoolFilter<"TakeoffValidation"> | boolean
    issues?: JsonFilter<"TakeoffValidation">
    warnings?: JsonFilter<"TakeoffValidation">
    comparedToJobs?: StringNullableListFilter<"TakeoffValidation">
    avgVariance?: DecimalNullableFilter<"TakeoffValidation"> | Decimal | DecimalJsLike | number | string | null
    validatedAt?: DateTimeFilter<"TakeoffValidation"> | Date | string
    takeoff?: XOR<TakeoffScalarRelationFilter, TakeoffWhereInput>
  }, "id" | "takeoffId">

  export type TakeoffValidationOrderByWithAggregationInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    specCompliant?: SortOrder
    pricingCurrent?: SortOrder
    varianceAcceptable?: SortOrder
    issues?: SortOrder
    warnings?: SortOrder
    comparedToJobs?: SortOrder
    avgVariance?: SortOrderInput | SortOrder
    validatedAt?: SortOrder
    _count?: TakeoffValidationCountOrderByAggregateInput
    _avg?: TakeoffValidationAvgOrderByAggregateInput
    _max?: TakeoffValidationMaxOrderByAggregateInput
    _min?: TakeoffValidationMinOrderByAggregateInput
    _sum?: TakeoffValidationSumOrderByAggregateInput
  }

  export type TakeoffValidationScalarWhereWithAggregatesInput = {
    AND?: TakeoffValidationScalarWhereWithAggregatesInput | TakeoffValidationScalarWhereWithAggregatesInput[]
    OR?: TakeoffValidationScalarWhereWithAggregatesInput[]
    NOT?: TakeoffValidationScalarWhereWithAggregatesInput | TakeoffValidationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TakeoffValidation"> | string
    takeoffId?: StringWithAggregatesFilter<"TakeoffValidation"> | string
    specCompliant?: BoolWithAggregatesFilter<"TakeoffValidation"> | boolean
    pricingCurrent?: BoolWithAggregatesFilter<"TakeoffValidation"> | boolean
    varianceAcceptable?: BoolWithAggregatesFilter<"TakeoffValidation"> | boolean
    issues?: JsonWithAggregatesFilter<"TakeoffValidation">
    warnings?: JsonWithAggregatesFilter<"TakeoffValidation">
    comparedToJobs?: StringNullableListFilter<"TakeoffValidation">
    avgVariance?: DecimalNullableWithAggregatesFilter<"TakeoffValidation"> | Decimal | DecimalJsLike | number | string | null
    validatedAt?: DateTimeWithAggregatesFilter<"TakeoffValidation"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    poNumber?: StringFilter<"PurchaseOrder"> | string
    jobId?: StringFilter<"PurchaseOrder"> | string
    vendorId?: StringNullableFilter<"PurchaseOrder"> | string | null
    status?: EnumPOStatusFilter<"PurchaseOrder"> | $Enums.POStatus
    totalAmount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    approvedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    scheduledDelivery?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    actualDelivery?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    deliveryNotes?: StringNullableFilter<"PurchaseOrder"> | string | null
    hyphenBuildProId?: StringNullableFilter<"PurchaseOrder"> | string | null
    holtPortalId?: StringNullableFilter<"PurchaseOrder"> | string | null
    signatureUrl?: StringNullableFilter<"PurchaseOrder"> | string | null
    photoUrls?: StringNullableListFilter<"PurchaseOrder">
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    poNumber?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    scheduledDelivery?: SortOrderInput | SortOrder
    actualDelivery?: SortOrderInput | SortOrder
    deliveryNotes?: SortOrderInput | SortOrder
    hyphenBuildProId?: SortOrderInput | SortOrder
    holtPortalId?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    photoUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    job?: JobOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    poNumber?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    jobId?: StringFilter<"PurchaseOrder"> | string
    vendorId?: StringNullableFilter<"PurchaseOrder"> | string | null
    status?: EnumPOStatusFilter<"PurchaseOrder"> | $Enums.POStatus
    totalAmount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    approvedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    scheduledDelivery?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    actualDelivery?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    deliveryNotes?: StringNullableFilter<"PurchaseOrder"> | string | null
    hyphenBuildProId?: StringNullableFilter<"PurchaseOrder"> | string | null
    holtPortalId?: StringNullableFilter<"PurchaseOrder"> | string | null
    signatureUrl?: StringNullableFilter<"PurchaseOrder"> | string | null
    photoUrls?: StringNullableListFilter<"PurchaseOrder">
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }, "id" | "poNumber">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    poNumber?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    scheduledDelivery?: SortOrderInput | SortOrder
    actualDelivery?: SortOrderInput | SortOrder
    deliveryNotes?: SortOrderInput | SortOrder
    hyphenBuildProId?: SortOrderInput | SortOrder
    holtPortalId?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    photoUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    poNumber?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    jobId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    vendorId?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    status?: EnumPOStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.POStatus
    totalAmount?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    scheduledDelivery?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    actualDelivery?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    deliveryNotes?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    hyphenBuildProId?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    holtPortalId?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    signatureUrl?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    photoUrls?: StringNullableListFilter<"PurchaseOrder">
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type VariancePatternWhereInput = {
    AND?: VariancePatternWhereInput | VariancePatternWhereInput[]
    OR?: VariancePatternWhereInput[]
    NOT?: VariancePatternWhereInput | VariancePatternWhereInput[]
    id?: StringFilter<"VariancePattern"> | string
    scope?: EnumVarianceScopeFilter<"VariancePattern"> | $Enums.VarianceScope
    planId?: StringNullableFilter<"VariancePattern"> | string | null
    communityId?: StringNullableFilter<"VariancePattern"> | string | null
    customerId?: StringNullableFilter<"VariancePattern"> | string | null
    region?: StringNullableFilter<"VariancePattern"> | string | null
    materialCategory?: StringFilter<"VariancePattern"> | string
    subcategory?: StringNullableFilter<"VariancePattern"> | string | null
    sampleSize?: IntFilter<"VariancePattern"> | number
    avgVariance?: DecimalFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: DecimalNullableFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string | null
    reasoning?: StringNullableFilter<"VariancePattern"> | string | null
    status?: EnumPatternStatusFilter<"VariancePattern"> | $Enums.PatternStatus
    reviewedAt?: DateTimeNullableFilter<"VariancePattern"> | Date | string | null
    appliedAt?: DateTimeNullableFilter<"VariancePattern"> | Date | string | null
    createdAt?: DateTimeFilter<"VariancePattern"> | Date | string
    updatedAt?: DateTimeFilter<"VariancePattern"> | Date | string
    plan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    community?: XOR<CommunityNullableScalarRelationFilter, CommunityWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    reviews?: VarianceReviewListRelationFilter
  }

  export type VariancePatternOrderByWithRelationInput = {
    id?: SortOrder
    scope?: SortOrder
    planId?: SortOrderInput | SortOrder
    communityId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    materialCategory?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    sampleSize?: SortOrder
    avgVariance?: SortOrder
    stdDeviation?: SortOrder
    confidenceScore?: SortOrder
    recommendedAdjustment?: SortOrderInput | SortOrder
    reasoning?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    appliedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    reviews?: VarianceReviewOrderByRelationAggregateInput
  }

  export type VariancePatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VariancePatternWhereInput | VariancePatternWhereInput[]
    OR?: VariancePatternWhereInput[]
    NOT?: VariancePatternWhereInput | VariancePatternWhereInput[]
    scope?: EnumVarianceScopeFilter<"VariancePattern"> | $Enums.VarianceScope
    planId?: StringNullableFilter<"VariancePattern"> | string | null
    communityId?: StringNullableFilter<"VariancePattern"> | string | null
    customerId?: StringNullableFilter<"VariancePattern"> | string | null
    region?: StringNullableFilter<"VariancePattern"> | string | null
    materialCategory?: StringFilter<"VariancePattern"> | string
    subcategory?: StringNullableFilter<"VariancePattern"> | string | null
    sampleSize?: IntFilter<"VariancePattern"> | number
    avgVariance?: DecimalFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: DecimalNullableFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string | null
    reasoning?: StringNullableFilter<"VariancePattern"> | string | null
    status?: EnumPatternStatusFilter<"VariancePattern"> | $Enums.PatternStatus
    reviewedAt?: DateTimeNullableFilter<"VariancePattern"> | Date | string | null
    appliedAt?: DateTimeNullableFilter<"VariancePattern"> | Date | string | null
    createdAt?: DateTimeFilter<"VariancePattern"> | Date | string
    updatedAt?: DateTimeFilter<"VariancePattern"> | Date | string
    plan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    community?: XOR<CommunityNullableScalarRelationFilter, CommunityWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    reviews?: VarianceReviewListRelationFilter
  }, "id">

  export type VariancePatternOrderByWithAggregationInput = {
    id?: SortOrder
    scope?: SortOrder
    planId?: SortOrderInput | SortOrder
    communityId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    materialCategory?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    sampleSize?: SortOrder
    avgVariance?: SortOrder
    stdDeviation?: SortOrder
    confidenceScore?: SortOrder
    recommendedAdjustment?: SortOrderInput | SortOrder
    reasoning?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    appliedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VariancePatternCountOrderByAggregateInput
    _avg?: VariancePatternAvgOrderByAggregateInput
    _max?: VariancePatternMaxOrderByAggregateInput
    _min?: VariancePatternMinOrderByAggregateInput
    _sum?: VariancePatternSumOrderByAggregateInput
  }

  export type VariancePatternScalarWhereWithAggregatesInput = {
    AND?: VariancePatternScalarWhereWithAggregatesInput | VariancePatternScalarWhereWithAggregatesInput[]
    OR?: VariancePatternScalarWhereWithAggregatesInput[]
    NOT?: VariancePatternScalarWhereWithAggregatesInput | VariancePatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VariancePattern"> | string
    scope?: EnumVarianceScopeWithAggregatesFilter<"VariancePattern"> | $Enums.VarianceScope
    planId?: StringNullableWithAggregatesFilter<"VariancePattern"> | string | null
    communityId?: StringNullableWithAggregatesFilter<"VariancePattern"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"VariancePattern"> | string | null
    region?: StringNullableWithAggregatesFilter<"VariancePattern"> | string | null
    materialCategory?: StringWithAggregatesFilter<"VariancePattern"> | string
    subcategory?: StringNullableWithAggregatesFilter<"VariancePattern"> | string | null
    sampleSize?: IntWithAggregatesFilter<"VariancePattern"> | number
    avgVariance?: DecimalWithAggregatesFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalWithAggregatesFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalWithAggregatesFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: DecimalNullableWithAggregatesFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string | null
    reasoning?: StringNullableWithAggregatesFilter<"VariancePattern"> | string | null
    status?: EnumPatternStatusWithAggregatesFilter<"VariancePattern"> | $Enums.PatternStatus
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"VariancePattern"> | Date | string | null
    appliedAt?: DateTimeNullableWithAggregatesFilter<"VariancePattern"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VariancePattern"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VariancePattern"> | Date | string
  }

  export type VarianceReviewWhereInput = {
    AND?: VarianceReviewWhereInput | VarianceReviewWhereInput[]
    OR?: VarianceReviewWhereInput[]
    NOT?: VarianceReviewWhereInput | VarianceReviewWhereInput[]
    id?: StringFilter<"VarianceReview"> | string
    patternId?: StringFilter<"VarianceReview"> | string
    reviewerId?: StringFilter<"VarianceReview"> | string
    decision?: EnumReviewDecisionFilter<"VarianceReview"> | $Enums.ReviewDecision
    notes?: StringNullableFilter<"VarianceReview"> | string | null
    reviewedAt?: DateTimeFilter<"VarianceReview"> | Date | string
    pattern?: XOR<VariancePatternScalarRelationFilter, VariancePatternWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VarianceReviewOrderByWithRelationInput = {
    id?: SortOrder
    patternId?: SortOrder
    reviewerId?: SortOrder
    decision?: SortOrder
    notes?: SortOrderInput | SortOrder
    reviewedAt?: SortOrder
    pattern?: VariancePatternOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type VarianceReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VarianceReviewWhereInput | VarianceReviewWhereInput[]
    OR?: VarianceReviewWhereInput[]
    NOT?: VarianceReviewWhereInput | VarianceReviewWhereInput[]
    patternId?: StringFilter<"VarianceReview"> | string
    reviewerId?: StringFilter<"VarianceReview"> | string
    decision?: EnumReviewDecisionFilter<"VarianceReview"> | $Enums.ReviewDecision
    notes?: StringNullableFilter<"VarianceReview"> | string | null
    reviewedAt?: DateTimeFilter<"VarianceReview"> | Date | string
    pattern?: XOR<VariancePatternScalarRelationFilter, VariancePatternWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VarianceReviewOrderByWithAggregationInput = {
    id?: SortOrder
    patternId?: SortOrder
    reviewerId?: SortOrder
    decision?: SortOrder
    notes?: SortOrderInput | SortOrder
    reviewedAt?: SortOrder
    _count?: VarianceReviewCountOrderByAggregateInput
    _max?: VarianceReviewMaxOrderByAggregateInput
    _min?: VarianceReviewMinOrderByAggregateInput
  }

  export type VarianceReviewScalarWhereWithAggregatesInput = {
    AND?: VarianceReviewScalarWhereWithAggregatesInput | VarianceReviewScalarWhereWithAggregatesInput[]
    OR?: VarianceReviewScalarWhereWithAggregatesInput[]
    NOT?: VarianceReviewScalarWhereWithAggregatesInput | VarianceReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VarianceReview"> | string
    patternId?: StringWithAggregatesFilter<"VarianceReview"> | string
    reviewerId?: StringWithAggregatesFilter<"VarianceReview"> | string
    decision?: EnumReviewDecisionWithAggregatesFilter<"VarianceReview"> | $Enums.ReviewDecision
    notes?: StringNullableWithAggregatesFilter<"VarianceReview"> | string | null
    reviewedAt?: DateTimeWithAggregatesFilter<"VarianceReview"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobCreateNestedManyWithoutCreatedByInput
    approvedJobs?: JobCreateNestedManyWithoutApprovedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobUncheckedCreateNestedManyWithoutCreatedByInput
    approvedJobs?: JobUncheckedCreateNestedManyWithoutApprovedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUpdateManyWithoutCreatedByNestedInput
    approvedJobs?: JobUpdateManyWithoutApprovedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedJobs?: JobUncheckedUpdateManyWithoutApprovedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    communities?: CommunityCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierUncheckedCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    communities?: CommunityUncheckedCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUncheckedUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUncheckedUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactCreateInput = {
    id?: string
    contactName: string
    role?: string | null
    email?: string | null
    phone?: string | null
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutContactsInput
  }

  export type CustomerContactUncheckedCreateInput = {
    id?: string
    customerId: string
    contactName: string
    role?: string | null
    email?: string | null
    phone?: string | null
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type CustomerContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    receivesNotifications?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutContactsNestedInput
  }

  export type CustomerContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    receivesNotifications?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactCreateManyInput = {
    id?: string
    customerId: string
    contactName: string
    role?: string | null
    email?: string | null
    phone?: string | null
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type CustomerContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    receivesNotifications?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    receivesNotifications?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingTierCreateInput = {
    id?: string
    tierName: string
    discountPercentage: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutPricingTiersInput
  }

  export type CustomerPricingTierUncheckedCreateInput = {
    id?: string
    customerId: string
    tierName: string
    discountPercentage: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type CustomerPricingTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPricingTiersNestedInput
  }

  export type CustomerPricingTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingTierCreateManyInput = {
    id?: string
    customerId: string
    tierName: string
    discountPercentage: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type CustomerPricingTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerExternalIdCreateInput = {
    id?: string
    externalSystem: string
    externalCustomerId: string
    externalCustomerName?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutExternalIdsInput
  }

  export type CustomerExternalIdUncheckedCreateInput = {
    id?: string
    customerId: string
    externalSystem: string
    externalCustomerId: string
    externalCustomerName?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type CustomerExternalIdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalSystem?: StringFieldUpdateOperationsInput | string
    externalCustomerId?: StringFieldUpdateOperationsInput | string
    externalCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutExternalIdsNestedInput
  }

  export type CustomerExternalIdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    externalSystem?: StringFieldUpdateOperationsInput | string
    externalCustomerId?: StringFieldUpdateOperationsInput | string
    externalCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerExternalIdCreateManyInput = {
    id?: string
    customerId: string
    externalSystem: string
    externalCustomerId: string
    externalCustomerName?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type CustomerExternalIdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalSystem?: StringFieldUpdateOperationsInput | string
    externalCustomerId?: StringFieldUpdateOperationsInput | string
    externalCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerExternalIdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    externalSystem?: StringFieldUpdateOperationsInput | string
    externalCustomerId?: StringFieldUpdateOperationsInput | string
    externalCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingCreateInput = {
    id?: string
    overridePrice?: Decimal | DecimalJsLike | number | string | null
    overrideMargin?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: Decimal | DecimalJsLike | number | string | null
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerPricingInput
    material: MaterialCreateNestedOneWithoutCustomerPricingInput
  }

  export type CustomerPricingUncheckedCreateInput = {
    id?: string
    customerId: string
    materialId: string
    overridePrice?: Decimal | DecimalJsLike | number | string | null
    overrideMargin?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: Decimal | DecimalJsLike | number | string | null
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPricingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerPricingNestedInput
    material?: MaterialUpdateOneRequiredWithoutCustomerPricingNestedInput
  }

  export type CustomerPricingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingCreateManyInput = {
    id?: string
    customerId: string
    materialId: string
    overridePrice?: Decimal | DecimalJsLike | number | string | null
    overrideMargin?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: Decimal | DecimalJsLike | number | string | null
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPricingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationCreateNestedManyWithoutPlanInput
    options?: PlanOptionCreateNestedManyWithoutPlansInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutPlanInput
    jobs?: JobCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationUncheckedCreateNestedManyWithoutPlanInput
    options?: PlanOptionUncheckedCreateNestedManyWithoutPlansInput
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutPlanInput
    jobs?: JobUncheckedCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUpdateManyWithoutPlanNestedInput
    options?: PlanOptionUpdateManyWithoutPlansNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutPlanNestedInput
    jobs?: JobUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUncheckedUpdateManyWithoutPlanNestedInput
    options?: PlanOptionUncheckedUpdateManyWithoutPlansNestedInput
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutPlanNestedInput
    jobs?: JobUncheckedUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanElevationCreateInput = {
    id?: string
    code: string
    name?: string | null
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutElevationsInput
    jobs?: JobCreateNestedManyWithoutElevationInput
  }

  export type PlanElevationUncheckedCreateInput = {
    id?: string
    planId: string
    code: string
    name?: string | null
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutElevationInput
  }

  export type PlanElevationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutElevationsNestedInput
    jobs?: JobUpdateManyWithoutElevationNestedInput
  }

  export type PlanElevationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutElevationNestedInput
  }

  export type PlanElevationCreateManyInput = {
    id?: string
    planId: string
    code: string
    name?: string | null
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanElevationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanElevationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanOptionCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.OptionCategory
    basePrice: Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionCreatetriggersPacksInput | string[]
    appliesTo?: PlanOptionCreateappliesToInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: PlanCreateNestedManyWithoutOptionsInput
    jobOptions?: JobOptionCreateNestedManyWithoutOptionInput
  }

  export type PlanOptionUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.OptionCategory
    basePrice: Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionCreatetriggersPacksInput | string[]
    appliesTo?: PlanOptionCreateappliesToInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: PlanUncheckedCreateNestedManyWithoutOptionsInput
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type PlanOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumOptionCategoryFieldUpdateOperationsInput | $Enums.OptionCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionUpdatetriggersPacksInput | string[]
    appliesTo?: PlanOptionUpdateappliesToInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: PlanUpdateManyWithoutOptionsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutOptionNestedInput
  }

  export type PlanOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumOptionCategoryFieldUpdateOperationsInput | $Enums.OptionCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionUpdatetriggersPacksInput | string[]
    appliesTo?: PlanOptionUpdateappliesToInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: PlanUncheckedUpdateManyWithoutOptionsNestedInput
    jobOptions?: JobOptionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type PlanOptionCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.OptionCategory
    basePrice: Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionCreatetriggersPacksInput | string[]
    appliesTo?: PlanOptionCreateappliesToInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumOptionCategoryFieldUpdateOperationsInput | $Enums.OptionCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionUpdatetriggersPacksInput | string[]
    appliesTo?: PlanOptionUpdateappliesToInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumOptionCategoryFieldUpdateOperationsInput | $Enums.OptionCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionUpdatetriggersPacksInput | string[]
    appliesTo?: PlanOptionUpdateappliesToInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanTemplateItemCreateInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    wasteFactor?: Decimal | DecimalJsLike | number | string
    category: string
    subcategory?: string | null
    averageVariance?: Decimal | DecimalJsLike | number | string | null
    varianceCount?: number
    lastVarianceDate?: Date | string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutTemplateItemsInput
    material: MaterialCreateNestedOneWithoutTemplateItemsInput
  }

  export type PlanTemplateItemUncheckedCreateInput = {
    id?: string
    planId: string
    materialId: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    wasteFactor?: Decimal | DecimalJsLike | number | string
    category: string
    subcategory?: string | null
    averageVariance?: Decimal | DecimalJsLike | number | string | null
    varianceCount?: number
    lastVarianceDate?: Date | string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanTemplateItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutTemplateItemsNestedInput
    material?: MaterialUpdateOneRequiredWithoutTemplateItemsNestedInput
  }

  export type PlanTemplateItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanTemplateItemCreateManyInput = {
    id?: string
    planId: string
    materialId: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    wasteFactor?: Decimal | DecimalJsLike | number | string
    category: string
    subcategory?: string | null
    averageVariance?: Decimal | DecimalJsLike | number | string | null
    varianceCount?: number
    lastVarianceDate?: Date | string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanTemplateItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanTemplateItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutMaterialsInput
    pricingHistory?: PricingHistoryCreateNestedManyWithoutMaterialInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: string | null
    pricingHistory?: PricingHistoryUncheckedCreateNestedManyWithoutMaterialInput
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutMaterialsNestedInput
    pricingHistory?: PricingHistoryUpdateManyWithoutMaterialNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingHistory?: PricingHistoryUncheckedUpdateManyWithoutMaterialNestedInput
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: string | null
  }

  export type MaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorCreateInput = {
    id?: string
    name: string
    code: string
    primaryContact?: string | null
    email?: string | null
    phone?: string | null
    paymentTerms?: string | null
    leadTimeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialCreateNestedManyWithoutVendorInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    primaryContact?: string | null
    email?: string | null
    phone?: string | null
    paymentTerms?: string | null
    leadTimeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialUncheckedCreateNestedManyWithoutVendorInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    primaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUpdateManyWithoutVendorNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    primaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUncheckedUpdateManyWithoutVendorNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    name: string
    code: string
    primaryContact?: string | null
    email?: string | null
    phone?: string | null
    paymentTerms?: string | null
    leadTimeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    primaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    primaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingHistoryCreateInput = {
    id?: string
    baseVendorCost: Decimal | DecimalJsLike | number | string
    commodityAdjustment?: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginPercentage: Decimal | DecimalJsLike | number | string
    marginAmount: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    calculationSteps: JsonNullValueInput | InputJsonValue
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    material: MaterialCreateNestedOneWithoutPricingHistoryInput
  }

  export type PricingHistoryUncheckedCreateInput = {
    id?: string
    materialId: string
    baseVendorCost: Decimal | DecimalJsLike | number | string
    commodityAdjustment?: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginPercentage: Decimal | DecimalJsLike | number | string
    marginAmount: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    calculationSteps: JsonNullValueInput | InputJsonValue
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PricingHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseVendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutPricingHistoryNestedInput
  }

  export type PricingHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    baseVendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingHistoryCreateManyInput = {
    id?: string
    materialId: string
    baseVendorCost: Decimal | DecimalJsLike | number | string
    commodityAdjustment?: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginPercentage: Decimal | DecimalJsLike | number | string
    marginAmount: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    calculationSteps: JsonNullValueInput | InputJsonValue
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PricingHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseVendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    baseVendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RandomLengthsPricingCreateInput = {
    id?: string
    tag: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    unit: string
    region?: string | null
    grade?: string | null
    effectiveDate: Date | string
    source: string
    createdAt?: Date | string
  }

  export type RandomLengthsPricingUncheckedCreateInput = {
    id?: string
    tag: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    unit: string
    region?: string | null
    grade?: string | null
    effectiveDate: Date | string
    source: string
    createdAt?: Date | string
  }

  export type RandomLengthsPricingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RandomLengthsPricingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RandomLengthsPricingCreateManyInput = {
    id?: string
    tag: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    unit: string
    region?: string | null
    grade?: string | null
    effectiveDate: Date | string
    source: string
    createdAt?: Date | string
  }

  export type RandomLengthsPricingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RandomLengthsPricingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCreateInput = {
    id?: string
    name: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCommunitiesInput
    lots?: LotCreateNestedManyWithoutCommunityInput
    jobs?: JobCreateNestedManyWithoutCommunityInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateInput = {
    id?: string
    name: string
    customerId: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: LotUncheckedCreateNestedManyWithoutCommunityInput
    jobs?: JobUncheckedCreateNestedManyWithoutCommunityInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCommunitiesNestedInput
    lots?: LotUpdateManyWithoutCommunityNestedInput
    jobs?: JobUpdateManyWithoutCommunityNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: LotUncheckedUpdateManyWithoutCommunityNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCommunityNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateManyInput = {
    id?: string
    name: string
    customerId: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotCreateInput = {
    id?: string
    lotNumber: string
    status?: $Enums.LotStatus
    sqft?: number | null
    frontage?: Decimal | DecimalJsLike | number | string | null
    depth?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutLotsInput
    jobs?: JobCreateNestedManyWithoutLotInput
  }

  export type LotUncheckedCreateInput = {
    id?: string
    communityId: string
    lotNumber: string
    status?: $Enums.LotStatus
    sqft?: number | null
    frontage?: Decimal | DecimalJsLike | number | string | null
    depth?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutLotInput
  }

  export type LotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    frontage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutLotsNestedInput
    jobs?: JobUpdateManyWithoutLotNestedInput
  }

  export type LotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    frontage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutLotNestedInput
  }

  export type LotCreateManyInput = {
    id?: string
    communityId: string
    lotNumber: string
    status?: $Enums.LotStatus
    sqft?: number | null
    frontage?: Decimal | DecimalJsLike | number | string | null
    depth?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    frontage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    frontage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    plan: PlanCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobCreateManyInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOptionCreateInput = {
    id?: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutJobOptionsInput
    option: PlanOptionCreateNestedOneWithoutJobOptionsInput
  }

  export type JobOptionUncheckedCreateInput = {
    id?: string
    jobId: string
    optionId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type JobOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutJobOptionsNestedInput
    option?: PlanOptionUpdateOneRequiredWithoutJobOptionsNestedInput
  }

  export type JobOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOptionCreateManyInput = {
    id?: string
    jobId: string
    optionId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type JobOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffCreateInput = {
    id?: string
    status?: $Enums.TakeoffStatus
    isValidated?: boolean
    validatedAt?: Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutTakeoffInput
    lineItems?: TakeoffLineItemCreateNestedManyWithoutTakeoffInput
    validation?: TakeoffValidationCreateNestedOneWithoutTakeoffInput
  }

  export type TakeoffUncheckedCreateInput = {
    id?: string
    jobId: string
    status?: $Enums.TakeoffStatus
    isValidated?: boolean
    validatedAt?: Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: TakeoffLineItemUncheckedCreateNestedManyWithoutTakeoffInput
    validation?: TakeoffValidationUncheckedCreateNestedOneWithoutTakeoffInput
  }

  export type TakeoffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutTakeoffNestedInput
    lineItems?: TakeoffLineItemUpdateManyWithoutTakeoffNestedInput
    validation?: TakeoffValidationUpdateOneWithoutTakeoffNestedInput
  }

  export type TakeoffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: TakeoffLineItemUncheckedUpdateManyWithoutTakeoffNestedInput
    validation?: TakeoffValidationUncheckedUpdateOneWithoutTakeoffNestedInput
  }

  export type TakeoffCreateManyInput = {
    id?: string
    jobId: string
    status?: $Enums.TakeoffStatus
    isValidated?: boolean
    validatedAt?: Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakeoffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffLineItemCreateInput = {
    id?: string
    quantityEstimated: Decimal | DecimalJsLike | number | string
    quantityActual?: Decimal | DecimalJsLike | number | string | null
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    variancePercent?: Decimal | DecimalJsLike | number | string | null
    varianceReason?: string | null
    category: string
    subcategory?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    takeoff: TakeoffCreateNestedOneWithoutLineItemsInput
    material: MaterialCreateNestedOneWithoutTakeoffLineItemsInput
  }

  export type TakeoffLineItemUncheckedCreateInput = {
    id?: string
    takeoffId: string
    materialId: string
    quantityEstimated: Decimal | DecimalJsLike | number | string
    quantityActual?: Decimal | DecimalJsLike | number | string | null
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    variancePercent?: Decimal | DecimalJsLike | number | string | null
    varianceReason?: string | null
    category: string
    subcategory?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakeoffLineItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    takeoff?: TakeoffUpdateOneRequiredWithoutLineItemsNestedInput
    material?: MaterialUpdateOneRequiredWithoutTakeoffLineItemsNestedInput
  }

  export type TakeoffLineItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    takeoffId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffLineItemCreateManyInput = {
    id?: string
    takeoffId: string
    materialId: string
    quantityEstimated: Decimal | DecimalJsLike | number | string
    quantityActual?: Decimal | DecimalJsLike | number | string | null
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    variancePercent?: Decimal | DecimalJsLike | number | string | null
    varianceReason?: string | null
    category: string
    subcategory?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakeoffLineItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffLineItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    takeoffId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffValidationCreateInput = {
    id?: string
    specCompliant?: boolean
    pricingCurrent?: boolean
    varianceAcceptable?: boolean
    issues: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationCreatecomparedToJobsInput | string[]
    avgVariance?: Decimal | DecimalJsLike | number | string | null
    validatedAt?: Date | string
    takeoff: TakeoffCreateNestedOneWithoutValidationInput
  }

  export type TakeoffValidationUncheckedCreateInput = {
    id?: string
    takeoffId: string
    specCompliant?: boolean
    pricingCurrent?: boolean
    varianceAcceptable?: boolean
    issues: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationCreatecomparedToJobsInput | string[]
    avgVariance?: Decimal | DecimalJsLike | number | string | null
    validatedAt?: Date | string
  }

  export type TakeoffValidationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    specCompliant?: BoolFieldUpdateOperationsInput | boolean
    pricingCurrent?: BoolFieldUpdateOperationsInput | boolean
    varianceAcceptable?: BoolFieldUpdateOperationsInput | boolean
    issues?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationUpdatecomparedToJobsInput | string[]
    avgVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    takeoff?: TakeoffUpdateOneRequiredWithoutValidationNestedInput
  }

  export type TakeoffValidationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    takeoffId?: StringFieldUpdateOperationsInput | string
    specCompliant?: BoolFieldUpdateOperationsInput | boolean
    pricingCurrent?: BoolFieldUpdateOperationsInput | boolean
    varianceAcceptable?: BoolFieldUpdateOperationsInput | boolean
    issues?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationUpdatecomparedToJobsInput | string[]
    avgVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffValidationCreateManyInput = {
    id?: string
    takeoffId: string
    specCompliant?: boolean
    pricingCurrent?: boolean
    varianceAcceptable?: boolean
    issues: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationCreatecomparedToJobsInput | string[]
    avgVariance?: Decimal | DecimalJsLike | number | string | null
    validatedAt?: Date | string
  }

  export type TakeoffValidationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    specCompliant?: BoolFieldUpdateOperationsInput | boolean
    pricingCurrent?: BoolFieldUpdateOperationsInput | boolean
    varianceAcceptable?: BoolFieldUpdateOperationsInput | boolean
    issues?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationUpdatecomparedToJobsInput | string[]
    avgVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffValidationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    takeoffId?: StringFieldUpdateOperationsInput | string
    specCompliant?: BoolFieldUpdateOperationsInput | boolean
    pricingCurrent?: BoolFieldUpdateOperationsInput | boolean
    varianceAcceptable?: BoolFieldUpdateOperationsInput | boolean
    issues?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationUpdatecomparedToJobsInput | string[]
    avgVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    poNumber: string
    status?: $Enums.POStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    approvedAt?: Date | string | null
    sentAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    scheduledDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    deliveryNotes?: string | null
    hyphenBuildProId?: string | null
    holtPortalId?: string | null
    signatureUrl?: string | null
    photoUrls?: PurchaseOrderCreatephotoUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutPurchaseOrdersInput
    vendor?: VendorCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    poNumber: string
    jobId: string
    vendorId?: string | null
    status?: $Enums.POStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    approvedAt?: Date | string | null
    sentAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    scheduledDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    deliveryNotes?: string | null
    hyphenBuildProId?: string | null
    holtPortalId?: string | null
    signatureUrl?: string | null
    photoUrls?: PurchaseOrderCreatephotoUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    vendor?: VendorUpdateOneWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    poNumber: string
    jobId: string
    vendorId?: string | null
    status?: $Enums.POStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    approvedAt?: Date | string | null
    sentAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    scheduledDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    deliveryNotes?: string | null
    hyphenBuildProId?: string | null
    holtPortalId?: string | null
    signatureUrl?: string | null
    photoUrls?: PurchaseOrderCreatephotoUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariancePatternCreateInput = {
    id?: string
    scope: $Enums.VarianceScope
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutVariancePatternsInput
    community?: CommunityCreateNestedOneWithoutVariancePatternsInput
    customer?: CustomerCreateNestedOneWithoutVariancePatternsInput
    reviews?: VarianceReviewCreateNestedManyWithoutPatternInput
  }

  export type VariancePatternUncheckedCreateInput = {
    id?: string
    scope: $Enums.VarianceScope
    planId?: string | null
    communityId?: string | null
    customerId?: string | null
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VarianceReviewUncheckedCreateNestedManyWithoutPatternInput
  }

  export type VariancePatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutVariancePatternsNestedInput
    community?: CommunityUpdateOneWithoutVariancePatternsNestedInput
    customer?: CustomerUpdateOneWithoutVariancePatternsNestedInput
    reviews?: VarianceReviewUpdateManyWithoutPatternNestedInput
  }

  export type VariancePatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VarianceReviewUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type VariancePatternCreateManyInput = {
    id?: string
    scope: $Enums.VarianceScope
    planId?: string | null
    communityId?: string | null
    customerId?: string | null
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariancePatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariancePatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceReviewCreateInput = {
    id?: string
    decision: $Enums.ReviewDecision
    notes?: string | null
    reviewedAt?: Date | string
    pattern: VariancePatternCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutVarianceReviewsInput
  }

  export type VarianceReviewUncheckedCreateInput = {
    id?: string
    patternId: string
    reviewerId: string
    decision: $Enums.ReviewDecision
    notes?: string | null
    reviewedAt?: Date | string
  }

  export type VarianceReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: VariancePatternUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutVarianceReviewsNestedInput
  }

  export type VarianceReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceReviewCreateManyInput = {
    id?: string
    patternId: string
    reviewerId: string
    decision: $Enums.ReviewDecision
    notes?: string | null
    reviewedAt?: Date | string
  }

  export type VarianceReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type VarianceReviewListRelationFilter = {
    every?: VarianceReviewWhereInput
    some?: VarianceReviewWhereInput
    none?: VarianceReviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VarianceReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type CustomerContactListRelationFilter = {
    every?: CustomerContactWhereInput
    some?: CustomerContactWhereInput
    none?: CustomerContactWhereInput
  }

  export type CustomerPricingTierListRelationFilter = {
    every?: CustomerPricingTierWhereInput
    some?: CustomerPricingTierWhereInput
    none?: CustomerPricingTierWhereInput
  }

  export type CustomerExternalIdListRelationFilter = {
    every?: CustomerExternalIdWhereInput
    some?: CustomerExternalIdWhereInput
    none?: CustomerExternalIdWhereInput
  }

  export type CommunityListRelationFilter = {
    every?: CommunityWhereInput
    some?: CommunityWhereInput
    none?: CommunityWhereInput
  }

  export type CustomerPricingListRelationFilter = {
    every?: CustomerPricingWhereInput
    some?: CustomerPricingWhereInput
    none?: CustomerPricingWhereInput
  }

  export type VariancePatternListRelationFilter = {
    every?: VariancePatternWhereInput
    some?: VariancePatternWhereInput
    none?: VariancePatternWhereInput
  }

  export type CustomerContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerPricingTierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerExternalIdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerPricingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariancePatternOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerType?: SortOrder
    pricingTier?: SortOrder
    primaryContactId?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerType?: SortOrder
    pricingTier?: SortOrder
    primaryContactId?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerType?: SortOrder
    pricingTier?: SortOrder
    primaryContactId?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerContactCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    contactName?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    receivesNotifications?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerContactMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    contactName?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    receivesNotifications?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerContactMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    contactName?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    receivesNotifications?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CustomerPricingTierCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    tierName?: SortOrder
    discountPercentage?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerPricingTierAvgOrderByAggregateInput = {
    discountPercentage?: SortOrder
  }

  export type CustomerPricingTierMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    tierName?: SortOrder
    discountPercentage?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerPricingTierMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    tierName?: SortOrder
    discountPercentage?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerPricingTierSumOrderByAggregateInput = {
    discountPercentage?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CustomerExternalIdCustomerIdExternalSystemCompoundUniqueInput = {
    customerId: string
    externalSystem: string
  }

  export type CustomerExternalIdCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    externalSystem?: SortOrder
    externalCustomerId?: SortOrder
    externalCustomerName?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerExternalIdMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    externalSystem?: SortOrder
    externalCustomerId?: SortOrder
    externalCustomerName?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerExternalIdMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    externalSystem?: SortOrder
    externalCustomerId?: SortOrder
    externalCustomerName?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type MaterialScalarRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type CustomerPricingCustomerIdMaterialIdCompoundUniqueInput = {
    customerId: string
    materialId: string
  }

  export type CustomerPricingCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    materialId?: SortOrder
    overridePrice?: SortOrder
    overrideMargin?: SortOrder
    discountPercentage?: SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPricingAvgOrderByAggregateInput = {
    overridePrice?: SortOrder
    overrideMargin?: SortOrder
    discountPercentage?: SortOrder
  }

  export type CustomerPricingMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    materialId?: SortOrder
    overridePrice?: SortOrder
    overrideMargin?: SortOrder
    discountPercentage?: SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPricingMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    materialId?: SortOrder
    overridePrice?: SortOrder
    overrideMargin?: SortOrder
    discountPercentage?: SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPricingSumOrderByAggregateInput = {
    overridePrice?: SortOrder
    overrideMargin?: SortOrder
    discountPercentage?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PlanElevationListRelationFilter = {
    every?: PlanElevationWhereInput
    some?: PlanElevationWhereInput
    none?: PlanElevationWhereInput
  }

  export type PlanOptionListRelationFilter = {
    every?: PlanOptionWhereInput
    some?: PlanOptionWhereInput
    none?: PlanOptionWhereInput
  }

  export type PlanTemplateItemListRelationFilter = {
    every?: PlanTemplateItemWhereInput
    some?: PlanTemplateItemWhereInput
    none?: PlanTemplateItemWhereInput
  }

  export type PlanElevationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanTemplateItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sqft?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    garage?: SortOrder
    style?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    pdssUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    sqft?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    version?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sqft?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    garage?: SortOrder
    style?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    pdssUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sqft?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    garage?: SortOrder
    style?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    pdssUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    sqft?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    version?: SortOrder
  }

  export type EnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type PlanElevationPlanIdCodeCompoundUniqueInput = {
    planId: string
    code: string
  }

  export type PlanElevationCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanElevationMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanElevationMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOptionCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionCategory | EnumOptionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.OptionCategory[] | ListEnumOptionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.OptionCategory[] | ListEnumOptionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumOptionCategoryFilter<$PrismaModel> | $Enums.OptionCategory
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PlanListRelationFilter = {
    every?: PlanWhereInput
    some?: PlanWhereInput
    none?: PlanWhereInput
  }

  export type JobOptionListRelationFilter = {
    every?: JobOptionWhereInput
    some?: JobOptionWhereInput
    none?: JobOptionWhereInput
  }

  export type PlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanOptionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    triggersPacks?: SortOrder
    appliesTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanOptionAvgOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type PlanOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanOptionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanOptionSumOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type EnumOptionCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionCategory | EnumOptionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.OptionCategory[] | ListEnumOptionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.OptionCategory[] | ListEnumOptionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumOptionCategoryWithAggregatesFilter<$PrismaModel> | $Enums.OptionCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptionCategoryFilter<$PrismaModel>
    _max?: NestedEnumOptionCategoryFilter<$PrismaModel>
  }

  export type PlanTemplateItemPlanIdMaterialIdCompoundUniqueInput = {
    planId: string
    materialId: string
  }

  export type PlanTemplateItemCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    wasteFactor?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    averageVariance?: SortOrder
    varianceCount?: SortOrder
    lastVarianceDate?: SortOrder
    confidenceScore?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanTemplateItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    wasteFactor?: SortOrder
    averageVariance?: SortOrder
    varianceCount?: SortOrder
    confidenceScore?: SortOrder
  }

  export type PlanTemplateItemMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    wasteFactor?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    averageVariance?: SortOrder
    varianceCount?: SortOrder
    lastVarianceDate?: SortOrder
    confidenceScore?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanTemplateItemMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    wasteFactor?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    averageVariance?: SortOrder
    varianceCount?: SortOrder
    lastVarianceDate?: SortOrder
    confidenceScore?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanTemplateItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    wasteFactor?: SortOrder
    averageVariance?: SortOrder
    varianceCount?: SortOrder
    confidenceScore?: SortOrder
  }

  export type EnumMaterialCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialCategory | EnumMaterialCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialCategory[] | ListEnumMaterialCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialCategory[] | ListEnumMaterialCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialCategoryFilter<$PrismaModel> | $Enums.MaterialCategory
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VendorNullableScalarRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type PricingHistoryListRelationFilter = {
    every?: PricingHistoryWhereInput
    some?: PricingHistoryWhereInput
    none?: PricingHistoryWhereInput
  }

  export type TakeoffLineItemListRelationFilter = {
    every?: TakeoffLineItemWhereInput
    some?: TakeoffLineItemWhereInput
    none?: TakeoffLineItemWhereInput
  }

  export type PricingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TakeoffLineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    unitOfMeasure?: SortOrder
    vendorCost?: SortOrder
    freight?: SortOrder
    isRLLinked?: SortOrder
    rlTag?: SortOrder
    rlBasePrice?: SortOrder
    rlLastUpdated?: SortOrder
    lengthAdders?: SortOrder
    gradeMultipliers?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    vendorCost?: SortOrder
    freight?: SortOrder
    rlBasePrice?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    unitOfMeasure?: SortOrder
    vendorCost?: SortOrder
    freight?: SortOrder
    isRLLinked?: SortOrder
    rlTag?: SortOrder
    rlBasePrice?: SortOrder
    rlLastUpdated?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    unitOfMeasure?: SortOrder
    vendorCost?: SortOrder
    freight?: SortOrder
    isRLLinked?: SortOrder
    rlTag?: SortOrder
    rlBasePrice?: SortOrder
    rlLastUpdated?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    vendorCost?: SortOrder
    freight?: SortOrder
    rlBasePrice?: SortOrder
  }

  export type EnumMaterialCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialCategory | EnumMaterialCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialCategory[] | ListEnumMaterialCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialCategory[] | ListEnumMaterialCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MaterialCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialCategoryFilter<$PrismaModel>
    _max?: NestedEnumMaterialCategoryFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    primaryContact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    paymentTerms?: SortOrder
    leadTimeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    leadTimeDays?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    primaryContact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    paymentTerms?: SortOrder
    leadTimeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    primaryContact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    paymentTerms?: SortOrder
    leadTimeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    leadTimeDays?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PricingHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    baseVendorCost?: SortOrder
    commodityAdjustment?: SortOrder
    freight?: SortOrder
    totalCost?: SortOrder
    marginPercentage?: SortOrder
    marginAmount?: SortOrder
    unitPrice?: SortOrder
    calculationSteps?: SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PricingHistoryAvgOrderByAggregateInput = {
    baseVendorCost?: SortOrder
    commodityAdjustment?: SortOrder
    freight?: SortOrder
    totalCost?: SortOrder
    marginPercentage?: SortOrder
    marginAmount?: SortOrder
    unitPrice?: SortOrder
  }

  export type PricingHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    baseVendorCost?: SortOrder
    commodityAdjustment?: SortOrder
    freight?: SortOrder
    totalCost?: SortOrder
    marginPercentage?: SortOrder
    marginAmount?: SortOrder
    unitPrice?: SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PricingHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    baseVendorCost?: SortOrder
    commodityAdjustment?: SortOrder
    freight?: SortOrder
    totalCost?: SortOrder
    marginPercentage?: SortOrder
    marginAmount?: SortOrder
    unitPrice?: SortOrder
    effectiveDate?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PricingHistorySumOrderByAggregateInput = {
    baseVendorCost?: SortOrder
    commodityAdjustment?: SortOrder
    freight?: SortOrder
    totalCost?: SortOrder
    marginPercentage?: SortOrder
    marginAmount?: SortOrder
    unitPrice?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type RandomLengthsPricingTagEffectiveDateCompoundUniqueInput = {
    tag: string
    effectiveDate: Date | string
  }

  export type RandomLengthsPricingCountOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    region?: SortOrder
    grade?: SortOrder
    effectiveDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type RandomLengthsPricingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type RandomLengthsPricingMaxOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    region?: SortOrder
    grade?: SortOrder
    effectiveDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type RandomLengthsPricingMinOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    region?: SortOrder
    grade?: SortOrder
    effectiveDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type RandomLengthsPricingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type LotListRelationFilter = {
    every?: LotWhereInput
    some?: LotWhereInput
    none?: LotWhereInput
  }

  export type LotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
    shippingYard?: SortOrder
    jurisdiction?: SortOrder
    region?: SortOrder
    activePlans?: SortOrder
    isActive?: SortOrder
    specialRequirements?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityAvgOrderByAggregateInput = {
    activePlans?: SortOrder
  }

  export type CommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
    shippingYard?: SortOrder
    jurisdiction?: SortOrder
    region?: SortOrder
    activePlans?: SortOrder
    isActive?: SortOrder
    specialRequirements?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
    shippingYard?: SortOrder
    jurisdiction?: SortOrder
    region?: SortOrder
    activePlans?: SortOrder
    isActive?: SortOrder
    specialRequirements?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunitySumOrderByAggregateInput = {
    activePlans?: SortOrder
  }

  export type EnumLotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LotStatus | EnumLotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLotStatusFilter<$PrismaModel> | $Enums.LotStatus
  }

  export type CommunityScalarRelationFilter = {
    is?: CommunityWhereInput
    isNot?: CommunityWhereInput
  }

  export type LotCommunityIdLotNumberCompoundUniqueInput = {
    communityId: string
    lotNumber: string
  }

  export type LotCountOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    lotNumber?: SortOrder
    status?: SortOrder
    sqft?: SortOrder
    frontage?: SortOrder
    depth?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LotAvgOrderByAggregateInput = {
    sqft?: SortOrder
    frontage?: SortOrder
    depth?: SortOrder
  }

  export type LotMaxOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    lotNumber?: SortOrder
    status?: SortOrder
    sqft?: SortOrder
    frontage?: SortOrder
    depth?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LotMinOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    lotNumber?: SortOrder
    status?: SortOrder
    sqft?: SortOrder
    frontage?: SortOrder
    depth?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LotSumOrderByAggregateInput = {
    sqft?: SortOrder
    frontage?: SortOrder
    depth?: SortOrder
  }

  export type EnumLotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LotStatus | EnumLotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLotStatusWithAggregatesFilter<$PrismaModel> | $Enums.LotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLotStatusFilter<$PrismaModel>
    _max?: NestedEnumLotStatusFilter<$PrismaModel>
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type PlanElevationNullableScalarRelationFilter = {
    is?: PlanElevationWhereInput | null
    isNot?: PlanElevationWhereInput | null
  }

  export type CommunityNullableScalarRelationFilter = {
    is?: CommunityWhereInput | null
    isNot?: CommunityWhereInput | null
  }

  export type LotNullableScalarRelationFilter = {
    is?: LotWhereInput | null
    isNot?: LotWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TakeoffNullableScalarRelationFilter = {
    is?: TakeoffWhereInput | null
    isNot?: TakeoffWhereInput | null
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    elevationId?: SortOrder
    communityId?: SortOrder
    lotId?: SortOrder
    status?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    margin?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    startDate?: SortOrder
    completionDate?: SortOrder
    notes?: SortOrder
    folderPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    margin?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    elevationId?: SortOrder
    communityId?: SortOrder
    lotId?: SortOrder
    status?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    margin?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    startDate?: SortOrder
    completionDate?: SortOrder
    notes?: SortOrder
    folderPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    elevationId?: SortOrder
    communityId?: SortOrder
    lotId?: SortOrder
    status?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    margin?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    startDate?: SortOrder
    completionDate?: SortOrder
    notes?: SortOrder
    folderPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    margin?: SortOrder
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type JobScalarRelationFilter = {
    is?: JobWhereInput
    isNot?: JobWhereInput
  }

  export type PlanOptionScalarRelationFilter = {
    is?: PlanOptionWhereInput
    isNot?: PlanOptionWhereInput
  }

  export type JobOptionJobIdOptionIdCompoundUniqueInput = {
    jobId: string
    optionId: string
  }

  export type JobOptionCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    optionId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type JobOptionAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type JobOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    optionId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type JobOptionMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    optionId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type JobOptionSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EnumTakeoffStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TakeoffStatus | EnumTakeoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TakeoffStatus[] | ListEnumTakeoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TakeoffStatus[] | ListEnumTakeoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTakeoffStatusFilter<$PrismaModel> | $Enums.TakeoffStatus
  }

  export type TakeoffValidationNullableScalarRelationFilter = {
    is?: TakeoffValidationWhereInput | null
    isNot?: TakeoffValidationWhereInput | null
  }

  export type TakeoffCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validationResults?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TakeoffAvgOrderByAggregateInput = {
    totalEstimated?: SortOrder
    totalActual?: SortOrder
  }

  export type TakeoffMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TakeoffMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TakeoffSumOrderByAggregateInput = {
    totalEstimated?: SortOrder
    totalActual?: SortOrder
  }

  export type EnumTakeoffStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TakeoffStatus | EnumTakeoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TakeoffStatus[] | ListEnumTakeoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TakeoffStatus[] | ListEnumTakeoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTakeoffStatusWithAggregatesFilter<$PrismaModel> | $Enums.TakeoffStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTakeoffStatusFilter<$PrismaModel>
    _max?: NestedEnumTakeoffStatusFilter<$PrismaModel>
  }

  export type TakeoffScalarRelationFilter = {
    is?: TakeoffWhereInput
    isNot?: TakeoffWhereInput
  }

  export type TakeoffLineItemCountOrderByAggregateInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    materialId?: SortOrder
    quantityEstimated?: SortOrder
    quantityActual?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrder
    variance?: SortOrder
    variancePercent?: SortOrder
    varianceReason?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TakeoffLineItemAvgOrderByAggregateInput = {
    quantityEstimated?: SortOrder
    quantityActual?: SortOrder
    unitPrice?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrder
    variance?: SortOrder
    variancePercent?: SortOrder
  }

  export type TakeoffLineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    materialId?: SortOrder
    quantityEstimated?: SortOrder
    quantityActual?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrder
    variance?: SortOrder
    variancePercent?: SortOrder
    varianceReason?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TakeoffLineItemMinOrderByAggregateInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    materialId?: SortOrder
    quantityEstimated?: SortOrder
    quantityActual?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrder
    variance?: SortOrder
    variancePercent?: SortOrder
    varianceReason?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TakeoffLineItemSumOrderByAggregateInput = {
    quantityEstimated?: SortOrder
    quantityActual?: SortOrder
    unitPrice?: SortOrder
    totalEstimated?: SortOrder
    totalActual?: SortOrder
    variance?: SortOrder
    variancePercent?: SortOrder
  }

  export type TakeoffValidationCountOrderByAggregateInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    specCompliant?: SortOrder
    pricingCurrent?: SortOrder
    varianceAcceptable?: SortOrder
    issues?: SortOrder
    warnings?: SortOrder
    comparedToJobs?: SortOrder
    avgVariance?: SortOrder
    validatedAt?: SortOrder
  }

  export type TakeoffValidationAvgOrderByAggregateInput = {
    avgVariance?: SortOrder
  }

  export type TakeoffValidationMaxOrderByAggregateInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    specCompliant?: SortOrder
    pricingCurrent?: SortOrder
    varianceAcceptable?: SortOrder
    avgVariance?: SortOrder
    validatedAt?: SortOrder
  }

  export type TakeoffValidationMinOrderByAggregateInput = {
    id?: SortOrder
    takeoffId?: SortOrder
    specCompliant?: SortOrder
    pricingCurrent?: SortOrder
    varianceAcceptable?: SortOrder
    avgVariance?: SortOrder
    validatedAt?: SortOrder
  }

  export type TakeoffValidationSumOrderByAggregateInput = {
    avgVariance?: SortOrder
  }

  export type EnumPOStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.POStatus | EnumPOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOStatusFilter<$PrismaModel> | $Enums.POStatus
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    poNumber?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    approvedAt?: SortOrder
    sentAt?: SortOrder
    confirmedAt?: SortOrder
    deliveredAt?: SortOrder
    scheduledDelivery?: SortOrder
    actualDelivery?: SortOrder
    deliveryNotes?: SortOrder
    hyphenBuildProId?: SortOrder
    holtPortalId?: SortOrder
    signatureUrl?: SortOrder
    photoUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    poNumber?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    approvedAt?: SortOrder
    sentAt?: SortOrder
    confirmedAt?: SortOrder
    deliveredAt?: SortOrder
    scheduledDelivery?: SortOrder
    actualDelivery?: SortOrder
    deliveryNotes?: SortOrder
    hyphenBuildProId?: SortOrder
    holtPortalId?: SortOrder
    signatureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    poNumber?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    approvedAt?: SortOrder
    sentAt?: SortOrder
    confirmedAt?: SortOrder
    deliveredAt?: SortOrder
    scheduledDelivery?: SortOrder
    actualDelivery?: SortOrder
    deliveryNotes?: SortOrder
    hyphenBuildProId?: SortOrder
    holtPortalId?: SortOrder
    signatureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumPOStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POStatus | EnumPOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOStatusWithAggregatesFilter<$PrismaModel> | $Enums.POStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOStatusFilter<$PrismaModel>
    _max?: NestedEnumPOStatusFilter<$PrismaModel>
  }

  export type EnumVarianceScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.VarianceScope | EnumVarianceScopeFieldRefInput<$PrismaModel>
    in?: $Enums.VarianceScope[] | ListEnumVarianceScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VarianceScope[] | ListEnumVarianceScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumVarianceScopeFilter<$PrismaModel> | $Enums.VarianceScope
  }

  export type EnumPatternStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternStatus | EnumPatternStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternStatusFilter<$PrismaModel> | $Enums.PatternStatus
  }

  export type PlanNullableScalarRelationFilter = {
    is?: PlanWhereInput | null
    isNot?: PlanWhereInput | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type VariancePatternCountOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
    planId?: SortOrder
    communityId?: SortOrder
    customerId?: SortOrder
    region?: SortOrder
    materialCategory?: SortOrder
    subcategory?: SortOrder
    sampleSize?: SortOrder
    avgVariance?: SortOrder
    stdDeviation?: SortOrder
    confidenceScore?: SortOrder
    recommendedAdjustment?: SortOrder
    reasoning?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    appliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariancePatternAvgOrderByAggregateInput = {
    sampleSize?: SortOrder
    avgVariance?: SortOrder
    stdDeviation?: SortOrder
    confidenceScore?: SortOrder
    recommendedAdjustment?: SortOrder
  }

  export type VariancePatternMaxOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
    planId?: SortOrder
    communityId?: SortOrder
    customerId?: SortOrder
    region?: SortOrder
    materialCategory?: SortOrder
    subcategory?: SortOrder
    sampleSize?: SortOrder
    avgVariance?: SortOrder
    stdDeviation?: SortOrder
    confidenceScore?: SortOrder
    recommendedAdjustment?: SortOrder
    reasoning?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    appliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariancePatternMinOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
    planId?: SortOrder
    communityId?: SortOrder
    customerId?: SortOrder
    region?: SortOrder
    materialCategory?: SortOrder
    subcategory?: SortOrder
    sampleSize?: SortOrder
    avgVariance?: SortOrder
    stdDeviation?: SortOrder
    confidenceScore?: SortOrder
    recommendedAdjustment?: SortOrder
    reasoning?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    appliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariancePatternSumOrderByAggregateInput = {
    sampleSize?: SortOrder
    avgVariance?: SortOrder
    stdDeviation?: SortOrder
    confidenceScore?: SortOrder
    recommendedAdjustment?: SortOrder
  }

  export type EnumVarianceScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VarianceScope | EnumVarianceScopeFieldRefInput<$PrismaModel>
    in?: $Enums.VarianceScope[] | ListEnumVarianceScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VarianceScope[] | ListEnumVarianceScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumVarianceScopeWithAggregatesFilter<$PrismaModel> | $Enums.VarianceScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVarianceScopeFilter<$PrismaModel>
    _max?: NestedEnumVarianceScopeFilter<$PrismaModel>
  }

  export type EnumPatternStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternStatus | EnumPatternStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternStatusWithAggregatesFilter<$PrismaModel> | $Enums.PatternStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPatternStatusFilter<$PrismaModel>
    _max?: NestedEnumPatternStatusFilter<$PrismaModel>
  }

  export type EnumReviewDecisionFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewDecisionFilter<$PrismaModel> | $Enums.ReviewDecision
  }

  export type VariancePatternScalarRelationFilter = {
    is?: VariancePatternWhereInput
    isNot?: VariancePatternWhereInput
  }

  export type VarianceReviewCountOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    reviewerId?: SortOrder
    decision?: SortOrder
    notes?: SortOrder
    reviewedAt?: SortOrder
  }

  export type VarianceReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    reviewerId?: SortOrder
    decision?: SortOrder
    notes?: SortOrder
    reviewedAt?: SortOrder
  }

  export type VarianceReviewMinOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    reviewerId?: SortOrder
    decision?: SortOrder
    notes?: SortOrder
    reviewedAt?: SortOrder
  }

  export type EnumReviewDecisionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewDecisionWithAggregatesFilter<$PrismaModel> | $Enums.ReviewDecision
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewDecisionFilter<$PrismaModel>
    _max?: NestedEnumReviewDecisionFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type JobCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<JobCreateWithoutCreatedByInput, JobUncheckedCreateWithoutCreatedByInput> | JobCreateWithoutCreatedByInput[] | JobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCreatedByInput | JobCreateOrConnectWithoutCreatedByInput[]
    createMany?: JobCreateManyCreatedByInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<JobCreateWithoutApprovedByInput, JobUncheckedCreateWithoutApprovedByInput> | JobCreateWithoutApprovedByInput[] | JobUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: JobCreateOrConnectWithoutApprovedByInput | JobCreateOrConnectWithoutApprovedByInput[]
    createMany?: JobCreateManyApprovedByInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type VarianceReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<VarianceReviewCreateWithoutReviewerInput, VarianceReviewUncheckedCreateWithoutReviewerInput> | VarianceReviewCreateWithoutReviewerInput[] | VarianceReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: VarianceReviewCreateOrConnectWithoutReviewerInput | VarianceReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: VarianceReviewCreateManyReviewerInputEnvelope
    connect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<JobCreateWithoutCreatedByInput, JobUncheckedCreateWithoutCreatedByInput> | JobCreateWithoutCreatedByInput[] | JobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCreatedByInput | JobCreateOrConnectWithoutCreatedByInput[]
    createMany?: JobCreateManyCreatedByInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<JobCreateWithoutApprovedByInput, JobUncheckedCreateWithoutApprovedByInput> | JobCreateWithoutApprovedByInput[] | JobUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: JobCreateOrConnectWithoutApprovedByInput | JobCreateOrConnectWithoutApprovedByInput[]
    createMany?: JobCreateManyApprovedByInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type VarianceReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<VarianceReviewCreateWithoutReviewerInput, VarianceReviewUncheckedCreateWithoutReviewerInput> | VarianceReviewCreateWithoutReviewerInput[] | VarianceReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: VarianceReviewCreateOrConnectWithoutReviewerInput | VarianceReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: VarianceReviewCreateManyReviewerInputEnvelope
    connect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type JobUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<JobCreateWithoutCreatedByInput, JobUncheckedCreateWithoutCreatedByInput> | JobCreateWithoutCreatedByInput[] | JobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCreatedByInput | JobCreateOrConnectWithoutCreatedByInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCreatedByInput | JobUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: JobCreateManyCreatedByInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCreatedByInput | JobUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCreatedByInput | JobUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type JobUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<JobCreateWithoutApprovedByInput, JobUncheckedCreateWithoutApprovedByInput> | JobCreateWithoutApprovedByInput[] | JobUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: JobCreateOrConnectWithoutApprovedByInput | JobCreateOrConnectWithoutApprovedByInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutApprovedByInput | JobUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: JobCreateManyApprovedByInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutApprovedByInput | JobUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: JobUpdateManyWithWhereWithoutApprovedByInput | JobUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type VarianceReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<VarianceReviewCreateWithoutReviewerInput, VarianceReviewUncheckedCreateWithoutReviewerInput> | VarianceReviewCreateWithoutReviewerInput[] | VarianceReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: VarianceReviewCreateOrConnectWithoutReviewerInput | VarianceReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: VarianceReviewUpsertWithWhereUniqueWithoutReviewerInput | VarianceReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: VarianceReviewCreateManyReviewerInputEnvelope
    set?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    disconnect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    delete?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    connect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    update?: VarianceReviewUpdateWithWhereUniqueWithoutReviewerInput | VarianceReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: VarianceReviewUpdateManyWithWhereWithoutReviewerInput | VarianceReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: VarianceReviewScalarWhereInput | VarianceReviewScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<JobCreateWithoutCreatedByInput, JobUncheckedCreateWithoutCreatedByInput> | JobCreateWithoutCreatedByInput[] | JobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCreatedByInput | JobCreateOrConnectWithoutCreatedByInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCreatedByInput | JobUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: JobCreateManyCreatedByInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCreatedByInput | JobUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCreatedByInput | JobUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<JobCreateWithoutApprovedByInput, JobUncheckedCreateWithoutApprovedByInput> | JobCreateWithoutApprovedByInput[] | JobUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: JobCreateOrConnectWithoutApprovedByInput | JobCreateOrConnectWithoutApprovedByInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutApprovedByInput | JobUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: JobCreateManyApprovedByInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutApprovedByInput | JobUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: JobUpdateManyWithWhereWithoutApprovedByInput | JobUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type VarianceReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<VarianceReviewCreateWithoutReviewerInput, VarianceReviewUncheckedCreateWithoutReviewerInput> | VarianceReviewCreateWithoutReviewerInput[] | VarianceReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: VarianceReviewCreateOrConnectWithoutReviewerInput | VarianceReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: VarianceReviewUpsertWithWhereUniqueWithoutReviewerInput | VarianceReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: VarianceReviewCreateManyReviewerInputEnvelope
    set?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    disconnect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    delete?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    connect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    update?: VarianceReviewUpdateWithWhereUniqueWithoutReviewerInput | VarianceReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: VarianceReviewUpdateManyWithWhereWithoutReviewerInput | VarianceReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: VarianceReviewScalarWhereInput | VarianceReviewScalarWhereInput[]
  }

  export type CustomerContactCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput> | CustomerContactCreateWithoutCustomerInput[] | CustomerContactUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerContactCreateOrConnectWithoutCustomerInput | CustomerContactCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerContactCreateManyCustomerInputEnvelope
    connect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
  }

  export type CustomerPricingTierCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerPricingTierCreateWithoutCustomerInput, CustomerPricingTierUncheckedCreateWithoutCustomerInput> | CustomerPricingTierCreateWithoutCustomerInput[] | CustomerPricingTierUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPricingTierCreateOrConnectWithoutCustomerInput | CustomerPricingTierCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerPricingTierCreateManyCustomerInputEnvelope
    connect?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
  }

  export type CustomerExternalIdCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerExternalIdCreateWithoutCustomerInput, CustomerExternalIdUncheckedCreateWithoutCustomerInput> | CustomerExternalIdCreateWithoutCustomerInput[] | CustomerExternalIdUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerExternalIdCreateOrConnectWithoutCustomerInput | CustomerExternalIdCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerExternalIdCreateManyCustomerInputEnvelope
    connect?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutCustomerInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type CommunityCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CommunityCreateWithoutCustomerInput, CommunityUncheckedCreateWithoutCustomerInput> | CommunityCreateWithoutCustomerInput[] | CommunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutCustomerInput | CommunityCreateOrConnectWithoutCustomerInput[]
    createMany?: CommunityCreateManyCustomerInputEnvelope
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type CustomerPricingCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerPricingCreateWithoutCustomerInput, CustomerPricingUncheckedCreateWithoutCustomerInput> | CustomerPricingCreateWithoutCustomerInput[] | CustomerPricingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPricingCreateOrConnectWithoutCustomerInput | CustomerPricingCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerPricingCreateManyCustomerInputEnvelope
    connect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
  }

  export type VariancePatternCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VariancePatternCreateWithoutCustomerInput, VariancePatternUncheckedCreateWithoutCustomerInput> | VariancePatternCreateWithoutCustomerInput[] | VariancePatternUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutCustomerInput | VariancePatternCreateOrConnectWithoutCustomerInput[]
    createMany?: VariancePatternCreateManyCustomerInputEnvelope
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
  }

  export type CustomerContactUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput> | CustomerContactCreateWithoutCustomerInput[] | CustomerContactUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerContactCreateOrConnectWithoutCustomerInput | CustomerContactCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerContactCreateManyCustomerInputEnvelope
    connect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
  }

  export type CustomerPricingTierUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerPricingTierCreateWithoutCustomerInput, CustomerPricingTierUncheckedCreateWithoutCustomerInput> | CustomerPricingTierCreateWithoutCustomerInput[] | CustomerPricingTierUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPricingTierCreateOrConnectWithoutCustomerInput | CustomerPricingTierCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerPricingTierCreateManyCustomerInputEnvelope
    connect?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
  }

  export type CustomerExternalIdUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerExternalIdCreateWithoutCustomerInput, CustomerExternalIdUncheckedCreateWithoutCustomerInput> | CustomerExternalIdCreateWithoutCustomerInput[] | CustomerExternalIdUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerExternalIdCreateOrConnectWithoutCustomerInput | CustomerExternalIdCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerExternalIdCreateManyCustomerInputEnvelope
    connect?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type CommunityUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CommunityCreateWithoutCustomerInput, CommunityUncheckedCreateWithoutCustomerInput> | CommunityCreateWithoutCustomerInput[] | CommunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutCustomerInput | CommunityCreateOrConnectWithoutCustomerInput[]
    createMany?: CommunityCreateManyCustomerInputEnvelope
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type CustomerPricingUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerPricingCreateWithoutCustomerInput, CustomerPricingUncheckedCreateWithoutCustomerInput> | CustomerPricingCreateWithoutCustomerInput[] | CustomerPricingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPricingCreateOrConnectWithoutCustomerInput | CustomerPricingCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerPricingCreateManyCustomerInputEnvelope
    connect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
  }

  export type VariancePatternUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VariancePatternCreateWithoutCustomerInput, VariancePatternUncheckedCreateWithoutCustomerInput> | VariancePatternCreateWithoutCustomerInput[] | VariancePatternUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutCustomerInput | VariancePatternCreateOrConnectWithoutCustomerInput[]
    createMany?: VariancePatternCreateManyCustomerInputEnvelope
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
  }

  export type EnumCustomerTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerType
  }

  export type CustomerContactUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput> | CustomerContactCreateWithoutCustomerInput[] | CustomerContactUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerContactCreateOrConnectWithoutCustomerInput | CustomerContactCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerContactUpsertWithWhereUniqueWithoutCustomerInput | CustomerContactUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerContactCreateManyCustomerInputEnvelope
    set?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    disconnect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    delete?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    connect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    update?: CustomerContactUpdateWithWhereUniqueWithoutCustomerInput | CustomerContactUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerContactUpdateManyWithWhereWithoutCustomerInput | CustomerContactUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerContactScalarWhereInput | CustomerContactScalarWhereInput[]
  }

  export type CustomerPricingTierUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerPricingTierCreateWithoutCustomerInput, CustomerPricingTierUncheckedCreateWithoutCustomerInput> | CustomerPricingTierCreateWithoutCustomerInput[] | CustomerPricingTierUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPricingTierCreateOrConnectWithoutCustomerInput | CustomerPricingTierCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerPricingTierUpsertWithWhereUniqueWithoutCustomerInput | CustomerPricingTierUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerPricingTierCreateManyCustomerInputEnvelope
    set?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
    disconnect?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
    delete?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
    connect?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
    update?: CustomerPricingTierUpdateWithWhereUniqueWithoutCustomerInput | CustomerPricingTierUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerPricingTierUpdateManyWithWhereWithoutCustomerInput | CustomerPricingTierUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerPricingTierScalarWhereInput | CustomerPricingTierScalarWhereInput[]
  }

  export type CustomerExternalIdUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerExternalIdCreateWithoutCustomerInput, CustomerExternalIdUncheckedCreateWithoutCustomerInput> | CustomerExternalIdCreateWithoutCustomerInput[] | CustomerExternalIdUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerExternalIdCreateOrConnectWithoutCustomerInput | CustomerExternalIdCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerExternalIdUpsertWithWhereUniqueWithoutCustomerInput | CustomerExternalIdUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerExternalIdCreateManyCustomerInputEnvelope
    set?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
    disconnect?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
    delete?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
    connect?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
    update?: CustomerExternalIdUpdateWithWhereUniqueWithoutCustomerInput | CustomerExternalIdUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerExternalIdUpdateManyWithWhereWithoutCustomerInput | CustomerExternalIdUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerExternalIdScalarWhereInput | CustomerExternalIdScalarWhereInput[]
  }

  export type JobUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCustomerInput | JobUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCustomerInput | JobUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCustomerInput | JobUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type CommunityUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CommunityCreateWithoutCustomerInput, CommunityUncheckedCreateWithoutCustomerInput> | CommunityCreateWithoutCustomerInput[] | CommunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutCustomerInput | CommunityCreateOrConnectWithoutCustomerInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutCustomerInput | CommunityUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CommunityCreateManyCustomerInputEnvelope
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutCustomerInput | CommunityUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutCustomerInput | CommunityUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type CustomerPricingUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerPricingCreateWithoutCustomerInput, CustomerPricingUncheckedCreateWithoutCustomerInput> | CustomerPricingCreateWithoutCustomerInput[] | CustomerPricingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPricingCreateOrConnectWithoutCustomerInput | CustomerPricingCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerPricingUpsertWithWhereUniqueWithoutCustomerInput | CustomerPricingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerPricingCreateManyCustomerInputEnvelope
    set?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    disconnect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    delete?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    connect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    update?: CustomerPricingUpdateWithWhereUniqueWithoutCustomerInput | CustomerPricingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerPricingUpdateManyWithWhereWithoutCustomerInput | CustomerPricingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerPricingScalarWhereInput | CustomerPricingScalarWhereInput[]
  }

  export type VariancePatternUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VariancePatternCreateWithoutCustomerInput, VariancePatternUncheckedCreateWithoutCustomerInput> | VariancePatternCreateWithoutCustomerInput[] | VariancePatternUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutCustomerInput | VariancePatternCreateOrConnectWithoutCustomerInput[]
    upsert?: VariancePatternUpsertWithWhereUniqueWithoutCustomerInput | VariancePatternUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VariancePatternCreateManyCustomerInputEnvelope
    set?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    disconnect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    delete?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    update?: VariancePatternUpdateWithWhereUniqueWithoutCustomerInput | VariancePatternUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VariancePatternUpdateManyWithWhereWithoutCustomerInput | VariancePatternUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VariancePatternScalarWhereInput | VariancePatternScalarWhereInput[]
  }

  export type CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput> | CustomerContactCreateWithoutCustomerInput[] | CustomerContactUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerContactCreateOrConnectWithoutCustomerInput | CustomerContactCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerContactUpsertWithWhereUniqueWithoutCustomerInput | CustomerContactUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerContactCreateManyCustomerInputEnvelope
    set?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    disconnect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    delete?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    connect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    update?: CustomerContactUpdateWithWhereUniqueWithoutCustomerInput | CustomerContactUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerContactUpdateManyWithWhereWithoutCustomerInput | CustomerContactUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerContactScalarWhereInput | CustomerContactScalarWhereInput[]
  }

  export type CustomerPricingTierUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerPricingTierCreateWithoutCustomerInput, CustomerPricingTierUncheckedCreateWithoutCustomerInput> | CustomerPricingTierCreateWithoutCustomerInput[] | CustomerPricingTierUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPricingTierCreateOrConnectWithoutCustomerInput | CustomerPricingTierCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerPricingTierUpsertWithWhereUniqueWithoutCustomerInput | CustomerPricingTierUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerPricingTierCreateManyCustomerInputEnvelope
    set?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
    disconnect?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
    delete?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
    connect?: CustomerPricingTierWhereUniqueInput | CustomerPricingTierWhereUniqueInput[]
    update?: CustomerPricingTierUpdateWithWhereUniqueWithoutCustomerInput | CustomerPricingTierUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerPricingTierUpdateManyWithWhereWithoutCustomerInput | CustomerPricingTierUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerPricingTierScalarWhereInput | CustomerPricingTierScalarWhereInput[]
  }

  export type CustomerExternalIdUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerExternalIdCreateWithoutCustomerInput, CustomerExternalIdUncheckedCreateWithoutCustomerInput> | CustomerExternalIdCreateWithoutCustomerInput[] | CustomerExternalIdUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerExternalIdCreateOrConnectWithoutCustomerInput | CustomerExternalIdCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerExternalIdUpsertWithWhereUniqueWithoutCustomerInput | CustomerExternalIdUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerExternalIdCreateManyCustomerInputEnvelope
    set?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
    disconnect?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
    delete?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
    connect?: CustomerExternalIdWhereUniqueInput | CustomerExternalIdWhereUniqueInput[]
    update?: CustomerExternalIdUpdateWithWhereUniqueWithoutCustomerInput | CustomerExternalIdUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerExternalIdUpdateManyWithWhereWithoutCustomerInput | CustomerExternalIdUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerExternalIdScalarWhereInput | CustomerExternalIdScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCustomerInput | JobUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCustomerInput | JobUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCustomerInput | JobUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type CommunityUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CommunityCreateWithoutCustomerInput, CommunityUncheckedCreateWithoutCustomerInput> | CommunityCreateWithoutCustomerInput[] | CommunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutCustomerInput | CommunityCreateOrConnectWithoutCustomerInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutCustomerInput | CommunityUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CommunityCreateManyCustomerInputEnvelope
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutCustomerInput | CommunityUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutCustomerInput | CommunityUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type CustomerPricingUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerPricingCreateWithoutCustomerInput, CustomerPricingUncheckedCreateWithoutCustomerInput> | CustomerPricingCreateWithoutCustomerInput[] | CustomerPricingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPricingCreateOrConnectWithoutCustomerInput | CustomerPricingCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerPricingUpsertWithWhereUniqueWithoutCustomerInput | CustomerPricingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerPricingCreateManyCustomerInputEnvelope
    set?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    disconnect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    delete?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    connect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    update?: CustomerPricingUpdateWithWhereUniqueWithoutCustomerInput | CustomerPricingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerPricingUpdateManyWithWhereWithoutCustomerInput | CustomerPricingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerPricingScalarWhereInput | CustomerPricingScalarWhereInput[]
  }

  export type VariancePatternUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VariancePatternCreateWithoutCustomerInput, VariancePatternUncheckedCreateWithoutCustomerInput> | VariancePatternCreateWithoutCustomerInput[] | VariancePatternUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutCustomerInput | VariancePatternCreateOrConnectWithoutCustomerInput[]
    upsert?: VariancePatternUpsertWithWhereUniqueWithoutCustomerInput | VariancePatternUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VariancePatternCreateManyCustomerInputEnvelope
    set?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    disconnect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    delete?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    update?: VariancePatternUpdateWithWhereUniqueWithoutCustomerInput | VariancePatternUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VariancePatternUpdateManyWithWhereWithoutCustomerInput | VariancePatternUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VariancePatternScalarWhereInput | VariancePatternScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutContactsInput = {
    create?: XOR<CustomerCreateWithoutContactsInput, CustomerUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutContactsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<CustomerCreateWithoutContactsInput, CustomerUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutContactsInput
    upsert?: CustomerUpsertWithoutContactsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutContactsInput, CustomerUpdateWithoutContactsInput>, CustomerUncheckedUpdateWithoutContactsInput>
  }

  export type CustomerCreateNestedOneWithoutPricingTiersInput = {
    create?: XOR<CustomerCreateWithoutPricingTiersInput, CustomerUncheckedCreateWithoutPricingTiersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPricingTiersInput
    connect?: CustomerWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerUpdateOneRequiredWithoutPricingTiersNestedInput = {
    create?: XOR<CustomerCreateWithoutPricingTiersInput, CustomerUncheckedCreateWithoutPricingTiersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPricingTiersInput
    upsert?: CustomerUpsertWithoutPricingTiersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPricingTiersInput, CustomerUpdateWithoutPricingTiersInput>, CustomerUncheckedUpdateWithoutPricingTiersInput>
  }

  export type CustomerCreateNestedOneWithoutExternalIdsInput = {
    create?: XOR<CustomerCreateWithoutExternalIdsInput, CustomerUncheckedCreateWithoutExternalIdsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutExternalIdsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutExternalIdsNestedInput = {
    create?: XOR<CustomerCreateWithoutExternalIdsInput, CustomerUncheckedCreateWithoutExternalIdsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutExternalIdsInput
    upsert?: CustomerUpsertWithoutExternalIdsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutExternalIdsInput, CustomerUpdateWithoutExternalIdsInput>, CustomerUncheckedUpdateWithoutExternalIdsInput>
  }

  export type CustomerCreateNestedOneWithoutCustomerPricingInput = {
    create?: XOR<CustomerCreateWithoutCustomerPricingInput, CustomerUncheckedCreateWithoutCustomerPricingInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerPricingInput
    connect?: CustomerWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutCustomerPricingInput = {
    create?: XOR<MaterialCreateWithoutCustomerPricingInput, MaterialUncheckedCreateWithoutCustomerPricingInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutCustomerPricingInput
    connect?: MaterialWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CustomerUpdateOneRequiredWithoutCustomerPricingNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerPricingInput, CustomerUncheckedCreateWithoutCustomerPricingInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerPricingInput
    upsert?: CustomerUpsertWithoutCustomerPricingInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerPricingInput, CustomerUpdateWithoutCustomerPricingInput>, CustomerUncheckedUpdateWithoutCustomerPricingInput>
  }

  export type MaterialUpdateOneRequiredWithoutCustomerPricingNestedInput = {
    create?: XOR<MaterialCreateWithoutCustomerPricingInput, MaterialUncheckedCreateWithoutCustomerPricingInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutCustomerPricingInput
    upsert?: MaterialUpsertWithoutCustomerPricingInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutCustomerPricingInput, MaterialUpdateWithoutCustomerPricingInput>, MaterialUncheckedUpdateWithoutCustomerPricingInput>
  }

  export type PlanElevationCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanElevationCreateWithoutPlanInput, PlanElevationUncheckedCreateWithoutPlanInput> | PlanElevationCreateWithoutPlanInput[] | PlanElevationUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanElevationCreateOrConnectWithoutPlanInput | PlanElevationCreateOrConnectWithoutPlanInput[]
    createMany?: PlanElevationCreateManyPlanInputEnvelope
    connect?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
  }

  export type PlanOptionCreateNestedManyWithoutPlansInput = {
    create?: XOR<PlanOptionCreateWithoutPlansInput, PlanOptionUncheckedCreateWithoutPlansInput> | PlanOptionCreateWithoutPlansInput[] | PlanOptionUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: PlanOptionCreateOrConnectWithoutPlansInput | PlanOptionCreateOrConnectWithoutPlansInput[]
    connect?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
  }

  export type PlanTemplateItemCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanTemplateItemCreateWithoutPlanInput, PlanTemplateItemUncheckedCreateWithoutPlanInput> | PlanTemplateItemCreateWithoutPlanInput[] | PlanTemplateItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanTemplateItemCreateOrConnectWithoutPlanInput | PlanTemplateItemCreateOrConnectWithoutPlanInput[]
    createMany?: PlanTemplateItemCreateManyPlanInputEnvelope
    connect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutPlanInput = {
    create?: XOR<JobCreateWithoutPlanInput, JobUncheckedCreateWithoutPlanInput> | JobCreateWithoutPlanInput[] | JobUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: JobCreateOrConnectWithoutPlanInput | JobCreateOrConnectWithoutPlanInput[]
    createMany?: JobCreateManyPlanInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type VariancePatternCreateNestedManyWithoutPlanInput = {
    create?: XOR<VariancePatternCreateWithoutPlanInput, VariancePatternUncheckedCreateWithoutPlanInput> | VariancePatternCreateWithoutPlanInput[] | VariancePatternUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutPlanInput | VariancePatternCreateOrConnectWithoutPlanInput[]
    createMany?: VariancePatternCreateManyPlanInputEnvelope
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
  }

  export type PlanElevationUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanElevationCreateWithoutPlanInput, PlanElevationUncheckedCreateWithoutPlanInput> | PlanElevationCreateWithoutPlanInput[] | PlanElevationUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanElevationCreateOrConnectWithoutPlanInput | PlanElevationCreateOrConnectWithoutPlanInput[]
    createMany?: PlanElevationCreateManyPlanInputEnvelope
    connect?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
  }

  export type PlanOptionUncheckedCreateNestedManyWithoutPlansInput = {
    create?: XOR<PlanOptionCreateWithoutPlansInput, PlanOptionUncheckedCreateWithoutPlansInput> | PlanOptionCreateWithoutPlansInput[] | PlanOptionUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: PlanOptionCreateOrConnectWithoutPlansInput | PlanOptionCreateOrConnectWithoutPlansInput[]
    connect?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
  }

  export type PlanTemplateItemUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanTemplateItemCreateWithoutPlanInput, PlanTemplateItemUncheckedCreateWithoutPlanInput> | PlanTemplateItemCreateWithoutPlanInput[] | PlanTemplateItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanTemplateItemCreateOrConnectWithoutPlanInput | PlanTemplateItemCreateOrConnectWithoutPlanInput[]
    createMany?: PlanTemplateItemCreateManyPlanInputEnvelope
    connect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<JobCreateWithoutPlanInput, JobUncheckedCreateWithoutPlanInput> | JobCreateWithoutPlanInput[] | JobUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: JobCreateOrConnectWithoutPlanInput | JobCreateOrConnectWithoutPlanInput[]
    createMany?: JobCreateManyPlanInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type VariancePatternUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<VariancePatternCreateWithoutPlanInput, VariancePatternUncheckedCreateWithoutPlanInput> | VariancePatternCreateWithoutPlanInput[] | VariancePatternUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutPlanInput | VariancePatternCreateOrConnectWithoutPlanInput[]
    createMany?: VariancePatternCreateManyPlanInputEnvelope
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
  }

  export type EnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlanElevationUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanElevationCreateWithoutPlanInput, PlanElevationUncheckedCreateWithoutPlanInput> | PlanElevationCreateWithoutPlanInput[] | PlanElevationUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanElevationCreateOrConnectWithoutPlanInput | PlanElevationCreateOrConnectWithoutPlanInput[]
    upsert?: PlanElevationUpsertWithWhereUniqueWithoutPlanInput | PlanElevationUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanElevationCreateManyPlanInputEnvelope
    set?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
    disconnect?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
    delete?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
    connect?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
    update?: PlanElevationUpdateWithWhereUniqueWithoutPlanInput | PlanElevationUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanElevationUpdateManyWithWhereWithoutPlanInput | PlanElevationUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanElevationScalarWhereInput | PlanElevationScalarWhereInput[]
  }

  export type PlanOptionUpdateManyWithoutPlansNestedInput = {
    create?: XOR<PlanOptionCreateWithoutPlansInput, PlanOptionUncheckedCreateWithoutPlansInput> | PlanOptionCreateWithoutPlansInput[] | PlanOptionUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: PlanOptionCreateOrConnectWithoutPlansInput | PlanOptionCreateOrConnectWithoutPlansInput[]
    upsert?: PlanOptionUpsertWithWhereUniqueWithoutPlansInput | PlanOptionUpsertWithWhereUniqueWithoutPlansInput[]
    set?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
    disconnect?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
    delete?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
    connect?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
    update?: PlanOptionUpdateWithWhereUniqueWithoutPlansInput | PlanOptionUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: PlanOptionUpdateManyWithWhereWithoutPlansInput | PlanOptionUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: PlanOptionScalarWhereInput | PlanOptionScalarWhereInput[]
  }

  export type PlanTemplateItemUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanTemplateItemCreateWithoutPlanInput, PlanTemplateItemUncheckedCreateWithoutPlanInput> | PlanTemplateItemCreateWithoutPlanInput[] | PlanTemplateItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanTemplateItemCreateOrConnectWithoutPlanInput | PlanTemplateItemCreateOrConnectWithoutPlanInput[]
    upsert?: PlanTemplateItemUpsertWithWhereUniqueWithoutPlanInput | PlanTemplateItemUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanTemplateItemCreateManyPlanInputEnvelope
    set?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    disconnect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    delete?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    connect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    update?: PlanTemplateItemUpdateWithWhereUniqueWithoutPlanInput | PlanTemplateItemUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanTemplateItemUpdateManyWithWhereWithoutPlanInput | PlanTemplateItemUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanTemplateItemScalarWhereInput | PlanTemplateItemScalarWhereInput[]
  }

  export type JobUpdateManyWithoutPlanNestedInput = {
    create?: XOR<JobCreateWithoutPlanInput, JobUncheckedCreateWithoutPlanInput> | JobCreateWithoutPlanInput[] | JobUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: JobCreateOrConnectWithoutPlanInput | JobCreateOrConnectWithoutPlanInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutPlanInput | JobUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: JobCreateManyPlanInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutPlanInput | JobUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: JobUpdateManyWithWhereWithoutPlanInput | JobUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type VariancePatternUpdateManyWithoutPlanNestedInput = {
    create?: XOR<VariancePatternCreateWithoutPlanInput, VariancePatternUncheckedCreateWithoutPlanInput> | VariancePatternCreateWithoutPlanInput[] | VariancePatternUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutPlanInput | VariancePatternCreateOrConnectWithoutPlanInput[]
    upsert?: VariancePatternUpsertWithWhereUniqueWithoutPlanInput | VariancePatternUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: VariancePatternCreateManyPlanInputEnvelope
    set?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    disconnect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    delete?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    update?: VariancePatternUpdateWithWhereUniqueWithoutPlanInput | VariancePatternUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: VariancePatternUpdateManyWithWhereWithoutPlanInput | VariancePatternUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: VariancePatternScalarWhereInput | VariancePatternScalarWhereInput[]
  }

  export type PlanElevationUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanElevationCreateWithoutPlanInput, PlanElevationUncheckedCreateWithoutPlanInput> | PlanElevationCreateWithoutPlanInput[] | PlanElevationUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanElevationCreateOrConnectWithoutPlanInput | PlanElevationCreateOrConnectWithoutPlanInput[]
    upsert?: PlanElevationUpsertWithWhereUniqueWithoutPlanInput | PlanElevationUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanElevationCreateManyPlanInputEnvelope
    set?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
    disconnect?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
    delete?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
    connect?: PlanElevationWhereUniqueInput | PlanElevationWhereUniqueInput[]
    update?: PlanElevationUpdateWithWhereUniqueWithoutPlanInput | PlanElevationUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanElevationUpdateManyWithWhereWithoutPlanInput | PlanElevationUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanElevationScalarWhereInput | PlanElevationScalarWhereInput[]
  }

  export type PlanOptionUncheckedUpdateManyWithoutPlansNestedInput = {
    create?: XOR<PlanOptionCreateWithoutPlansInput, PlanOptionUncheckedCreateWithoutPlansInput> | PlanOptionCreateWithoutPlansInput[] | PlanOptionUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: PlanOptionCreateOrConnectWithoutPlansInput | PlanOptionCreateOrConnectWithoutPlansInput[]
    upsert?: PlanOptionUpsertWithWhereUniqueWithoutPlansInput | PlanOptionUpsertWithWhereUniqueWithoutPlansInput[]
    set?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
    disconnect?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
    delete?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
    connect?: PlanOptionWhereUniqueInput | PlanOptionWhereUniqueInput[]
    update?: PlanOptionUpdateWithWhereUniqueWithoutPlansInput | PlanOptionUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: PlanOptionUpdateManyWithWhereWithoutPlansInput | PlanOptionUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: PlanOptionScalarWhereInput | PlanOptionScalarWhereInput[]
  }

  export type PlanTemplateItemUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanTemplateItemCreateWithoutPlanInput, PlanTemplateItemUncheckedCreateWithoutPlanInput> | PlanTemplateItemCreateWithoutPlanInput[] | PlanTemplateItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanTemplateItemCreateOrConnectWithoutPlanInput | PlanTemplateItemCreateOrConnectWithoutPlanInput[]
    upsert?: PlanTemplateItemUpsertWithWhereUniqueWithoutPlanInput | PlanTemplateItemUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanTemplateItemCreateManyPlanInputEnvelope
    set?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    disconnect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    delete?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    connect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    update?: PlanTemplateItemUpdateWithWhereUniqueWithoutPlanInput | PlanTemplateItemUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanTemplateItemUpdateManyWithWhereWithoutPlanInput | PlanTemplateItemUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanTemplateItemScalarWhereInput | PlanTemplateItemScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<JobCreateWithoutPlanInput, JobUncheckedCreateWithoutPlanInput> | JobCreateWithoutPlanInput[] | JobUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: JobCreateOrConnectWithoutPlanInput | JobCreateOrConnectWithoutPlanInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutPlanInput | JobUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: JobCreateManyPlanInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutPlanInput | JobUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: JobUpdateManyWithWhereWithoutPlanInput | JobUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type VariancePatternUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<VariancePatternCreateWithoutPlanInput, VariancePatternUncheckedCreateWithoutPlanInput> | VariancePatternCreateWithoutPlanInput[] | VariancePatternUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutPlanInput | VariancePatternCreateOrConnectWithoutPlanInput[]
    upsert?: VariancePatternUpsertWithWhereUniqueWithoutPlanInput | VariancePatternUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: VariancePatternCreateManyPlanInputEnvelope
    set?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    disconnect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    delete?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    update?: VariancePatternUpdateWithWhereUniqueWithoutPlanInput | VariancePatternUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: VariancePatternUpdateManyWithWhereWithoutPlanInput | VariancePatternUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: VariancePatternScalarWhereInput | VariancePatternScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutElevationsInput = {
    create?: XOR<PlanCreateWithoutElevationsInput, PlanUncheckedCreateWithoutElevationsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutElevationsInput
    connect?: PlanWhereUniqueInput
  }

  export type JobCreateNestedManyWithoutElevationInput = {
    create?: XOR<JobCreateWithoutElevationInput, JobUncheckedCreateWithoutElevationInput> | JobCreateWithoutElevationInput[] | JobUncheckedCreateWithoutElevationInput[]
    connectOrCreate?: JobCreateOrConnectWithoutElevationInput | JobCreateOrConnectWithoutElevationInput[]
    createMany?: JobCreateManyElevationInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutElevationInput = {
    create?: XOR<JobCreateWithoutElevationInput, JobUncheckedCreateWithoutElevationInput> | JobCreateWithoutElevationInput[] | JobUncheckedCreateWithoutElevationInput[]
    connectOrCreate?: JobCreateOrConnectWithoutElevationInput | JobCreateOrConnectWithoutElevationInput[]
    createMany?: JobCreateManyElevationInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type PlanUpdateOneRequiredWithoutElevationsNestedInput = {
    create?: XOR<PlanCreateWithoutElevationsInput, PlanUncheckedCreateWithoutElevationsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutElevationsInput
    upsert?: PlanUpsertWithoutElevationsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutElevationsInput, PlanUpdateWithoutElevationsInput>, PlanUncheckedUpdateWithoutElevationsInput>
  }

  export type JobUpdateManyWithoutElevationNestedInput = {
    create?: XOR<JobCreateWithoutElevationInput, JobUncheckedCreateWithoutElevationInput> | JobCreateWithoutElevationInput[] | JobUncheckedCreateWithoutElevationInput[]
    connectOrCreate?: JobCreateOrConnectWithoutElevationInput | JobCreateOrConnectWithoutElevationInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutElevationInput | JobUpsertWithWhereUniqueWithoutElevationInput[]
    createMany?: JobCreateManyElevationInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutElevationInput | JobUpdateWithWhereUniqueWithoutElevationInput[]
    updateMany?: JobUpdateManyWithWhereWithoutElevationInput | JobUpdateManyWithWhereWithoutElevationInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutElevationNestedInput = {
    create?: XOR<JobCreateWithoutElevationInput, JobUncheckedCreateWithoutElevationInput> | JobCreateWithoutElevationInput[] | JobUncheckedCreateWithoutElevationInput[]
    connectOrCreate?: JobCreateOrConnectWithoutElevationInput | JobCreateOrConnectWithoutElevationInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutElevationInput | JobUpsertWithWhereUniqueWithoutElevationInput[]
    createMany?: JobCreateManyElevationInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutElevationInput | JobUpdateWithWhereUniqueWithoutElevationInput[]
    updateMany?: JobUpdateManyWithWhereWithoutElevationInput | JobUpdateManyWithWhereWithoutElevationInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type PlanOptionCreatetriggersPacksInput = {
    set: string[]
  }

  export type PlanOptionCreateappliesToInput = {
    set: string[]
  }

  export type PlanCreateNestedManyWithoutOptionsInput = {
    create?: XOR<PlanCreateWithoutOptionsInput, PlanUncheckedCreateWithoutOptionsInput> | PlanCreateWithoutOptionsInput[] | PlanUncheckedCreateWithoutOptionsInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutOptionsInput | PlanCreateOrConnectWithoutOptionsInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type JobOptionCreateNestedManyWithoutOptionInput = {
    create?: XOR<JobOptionCreateWithoutOptionInput, JobOptionUncheckedCreateWithoutOptionInput> | JobOptionCreateWithoutOptionInput[] | JobOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: JobOptionCreateOrConnectWithoutOptionInput | JobOptionCreateOrConnectWithoutOptionInput[]
    createMany?: JobOptionCreateManyOptionInputEnvelope
    connect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
  }

  export type PlanUncheckedCreateNestedManyWithoutOptionsInput = {
    create?: XOR<PlanCreateWithoutOptionsInput, PlanUncheckedCreateWithoutOptionsInput> | PlanCreateWithoutOptionsInput[] | PlanUncheckedCreateWithoutOptionsInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutOptionsInput | PlanCreateOrConnectWithoutOptionsInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type JobOptionUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<JobOptionCreateWithoutOptionInput, JobOptionUncheckedCreateWithoutOptionInput> | JobOptionCreateWithoutOptionInput[] | JobOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: JobOptionCreateOrConnectWithoutOptionInput | JobOptionCreateOrConnectWithoutOptionInput[]
    createMany?: JobOptionCreateManyOptionInputEnvelope
    connect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
  }

  export type EnumOptionCategoryFieldUpdateOperationsInput = {
    set?: $Enums.OptionCategory
  }

  export type PlanOptionUpdatetriggersPacksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlanOptionUpdateappliesToInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlanUpdateManyWithoutOptionsNestedInput = {
    create?: XOR<PlanCreateWithoutOptionsInput, PlanUncheckedCreateWithoutOptionsInput> | PlanCreateWithoutOptionsInput[] | PlanUncheckedCreateWithoutOptionsInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutOptionsInput | PlanCreateOrConnectWithoutOptionsInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutOptionsInput | PlanUpsertWithWhereUniqueWithoutOptionsInput[]
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutOptionsInput | PlanUpdateWithWhereUniqueWithoutOptionsInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutOptionsInput | PlanUpdateManyWithWhereWithoutOptionsInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type JobOptionUpdateManyWithoutOptionNestedInput = {
    create?: XOR<JobOptionCreateWithoutOptionInput, JobOptionUncheckedCreateWithoutOptionInput> | JobOptionCreateWithoutOptionInput[] | JobOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: JobOptionCreateOrConnectWithoutOptionInput | JobOptionCreateOrConnectWithoutOptionInput[]
    upsert?: JobOptionUpsertWithWhereUniqueWithoutOptionInput | JobOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: JobOptionCreateManyOptionInputEnvelope
    set?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    disconnect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    delete?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    connect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    update?: JobOptionUpdateWithWhereUniqueWithoutOptionInput | JobOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: JobOptionUpdateManyWithWhereWithoutOptionInput | JobOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: JobOptionScalarWhereInput | JobOptionScalarWhereInput[]
  }

  export type PlanUncheckedUpdateManyWithoutOptionsNestedInput = {
    create?: XOR<PlanCreateWithoutOptionsInput, PlanUncheckedCreateWithoutOptionsInput> | PlanCreateWithoutOptionsInput[] | PlanUncheckedCreateWithoutOptionsInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutOptionsInput | PlanCreateOrConnectWithoutOptionsInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutOptionsInput | PlanUpsertWithWhereUniqueWithoutOptionsInput[]
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutOptionsInput | PlanUpdateWithWhereUniqueWithoutOptionsInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutOptionsInput | PlanUpdateManyWithWhereWithoutOptionsInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type JobOptionUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<JobOptionCreateWithoutOptionInput, JobOptionUncheckedCreateWithoutOptionInput> | JobOptionCreateWithoutOptionInput[] | JobOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: JobOptionCreateOrConnectWithoutOptionInput | JobOptionCreateOrConnectWithoutOptionInput[]
    upsert?: JobOptionUpsertWithWhereUniqueWithoutOptionInput | JobOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: JobOptionCreateManyOptionInputEnvelope
    set?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    disconnect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    delete?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    connect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    update?: JobOptionUpdateWithWhereUniqueWithoutOptionInput | JobOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: JobOptionUpdateManyWithWhereWithoutOptionInput | JobOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: JobOptionScalarWhereInput | JobOptionScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutTemplateItemsInput = {
    create?: XOR<PlanCreateWithoutTemplateItemsInput, PlanUncheckedCreateWithoutTemplateItemsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutTemplateItemsInput
    connect?: PlanWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutTemplateItemsInput = {
    create?: XOR<MaterialCreateWithoutTemplateItemsInput, MaterialUncheckedCreateWithoutTemplateItemsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutTemplateItemsInput
    connect?: MaterialWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutTemplateItemsNestedInput = {
    create?: XOR<PlanCreateWithoutTemplateItemsInput, PlanUncheckedCreateWithoutTemplateItemsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutTemplateItemsInput
    upsert?: PlanUpsertWithoutTemplateItemsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutTemplateItemsInput, PlanUpdateWithoutTemplateItemsInput>, PlanUncheckedUpdateWithoutTemplateItemsInput>
  }

  export type MaterialUpdateOneRequiredWithoutTemplateItemsNestedInput = {
    create?: XOR<MaterialCreateWithoutTemplateItemsInput, MaterialUncheckedCreateWithoutTemplateItemsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutTemplateItemsInput
    upsert?: MaterialUpsertWithoutTemplateItemsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutTemplateItemsInput, MaterialUpdateWithoutTemplateItemsInput>, MaterialUncheckedUpdateWithoutTemplateItemsInput>
  }

  export type VendorCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<VendorCreateWithoutMaterialsInput, VendorUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutMaterialsInput
    connect?: VendorWhereUniqueInput
  }

  export type PricingHistoryCreateNestedManyWithoutMaterialInput = {
    create?: XOR<PricingHistoryCreateWithoutMaterialInput, PricingHistoryUncheckedCreateWithoutMaterialInput> | PricingHistoryCreateWithoutMaterialInput[] | PricingHistoryUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PricingHistoryCreateOrConnectWithoutMaterialInput | PricingHistoryCreateOrConnectWithoutMaterialInput[]
    createMany?: PricingHistoryCreateManyMaterialInputEnvelope
    connect?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
  }

  export type PlanTemplateItemCreateNestedManyWithoutMaterialInput = {
    create?: XOR<PlanTemplateItemCreateWithoutMaterialInput, PlanTemplateItemUncheckedCreateWithoutMaterialInput> | PlanTemplateItemCreateWithoutMaterialInput[] | PlanTemplateItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PlanTemplateItemCreateOrConnectWithoutMaterialInput | PlanTemplateItemCreateOrConnectWithoutMaterialInput[]
    createMany?: PlanTemplateItemCreateManyMaterialInputEnvelope
    connect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
  }

  export type CustomerPricingCreateNestedManyWithoutMaterialInput = {
    create?: XOR<CustomerPricingCreateWithoutMaterialInput, CustomerPricingUncheckedCreateWithoutMaterialInput> | CustomerPricingCreateWithoutMaterialInput[] | CustomerPricingUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CustomerPricingCreateOrConnectWithoutMaterialInput | CustomerPricingCreateOrConnectWithoutMaterialInput[]
    createMany?: CustomerPricingCreateManyMaterialInputEnvelope
    connect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
  }

  export type TakeoffLineItemCreateNestedManyWithoutMaterialInput = {
    create?: XOR<TakeoffLineItemCreateWithoutMaterialInput, TakeoffLineItemUncheckedCreateWithoutMaterialInput> | TakeoffLineItemCreateWithoutMaterialInput[] | TakeoffLineItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: TakeoffLineItemCreateOrConnectWithoutMaterialInput | TakeoffLineItemCreateOrConnectWithoutMaterialInput[]
    createMany?: TakeoffLineItemCreateManyMaterialInputEnvelope
    connect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
  }

  export type PricingHistoryUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<PricingHistoryCreateWithoutMaterialInput, PricingHistoryUncheckedCreateWithoutMaterialInput> | PricingHistoryCreateWithoutMaterialInput[] | PricingHistoryUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PricingHistoryCreateOrConnectWithoutMaterialInput | PricingHistoryCreateOrConnectWithoutMaterialInput[]
    createMany?: PricingHistoryCreateManyMaterialInputEnvelope
    connect?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
  }

  export type PlanTemplateItemUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<PlanTemplateItemCreateWithoutMaterialInput, PlanTemplateItemUncheckedCreateWithoutMaterialInput> | PlanTemplateItemCreateWithoutMaterialInput[] | PlanTemplateItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PlanTemplateItemCreateOrConnectWithoutMaterialInput | PlanTemplateItemCreateOrConnectWithoutMaterialInput[]
    createMany?: PlanTemplateItemCreateManyMaterialInputEnvelope
    connect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
  }

  export type CustomerPricingUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<CustomerPricingCreateWithoutMaterialInput, CustomerPricingUncheckedCreateWithoutMaterialInput> | CustomerPricingCreateWithoutMaterialInput[] | CustomerPricingUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CustomerPricingCreateOrConnectWithoutMaterialInput | CustomerPricingCreateOrConnectWithoutMaterialInput[]
    createMany?: CustomerPricingCreateManyMaterialInputEnvelope
    connect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
  }

  export type TakeoffLineItemUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<TakeoffLineItemCreateWithoutMaterialInput, TakeoffLineItemUncheckedCreateWithoutMaterialInput> | TakeoffLineItemCreateWithoutMaterialInput[] | TakeoffLineItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: TakeoffLineItemCreateOrConnectWithoutMaterialInput | TakeoffLineItemCreateOrConnectWithoutMaterialInput[]
    createMany?: TakeoffLineItemCreateManyMaterialInputEnvelope
    connect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
  }

  export type EnumMaterialCategoryFieldUpdateOperationsInput = {
    set?: $Enums.MaterialCategory
  }

  export type VendorUpdateOneWithoutMaterialsNestedInput = {
    create?: XOR<VendorCreateWithoutMaterialsInput, VendorUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutMaterialsInput
    upsert?: VendorUpsertWithoutMaterialsInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutMaterialsInput, VendorUpdateWithoutMaterialsInput>, VendorUncheckedUpdateWithoutMaterialsInput>
  }

  export type PricingHistoryUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<PricingHistoryCreateWithoutMaterialInput, PricingHistoryUncheckedCreateWithoutMaterialInput> | PricingHistoryCreateWithoutMaterialInput[] | PricingHistoryUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PricingHistoryCreateOrConnectWithoutMaterialInput | PricingHistoryCreateOrConnectWithoutMaterialInput[]
    upsert?: PricingHistoryUpsertWithWhereUniqueWithoutMaterialInput | PricingHistoryUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: PricingHistoryCreateManyMaterialInputEnvelope
    set?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
    disconnect?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
    delete?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
    connect?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
    update?: PricingHistoryUpdateWithWhereUniqueWithoutMaterialInput | PricingHistoryUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: PricingHistoryUpdateManyWithWhereWithoutMaterialInput | PricingHistoryUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: PricingHistoryScalarWhereInput | PricingHistoryScalarWhereInput[]
  }

  export type PlanTemplateItemUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<PlanTemplateItemCreateWithoutMaterialInput, PlanTemplateItemUncheckedCreateWithoutMaterialInput> | PlanTemplateItemCreateWithoutMaterialInput[] | PlanTemplateItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PlanTemplateItemCreateOrConnectWithoutMaterialInput | PlanTemplateItemCreateOrConnectWithoutMaterialInput[]
    upsert?: PlanTemplateItemUpsertWithWhereUniqueWithoutMaterialInput | PlanTemplateItemUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: PlanTemplateItemCreateManyMaterialInputEnvelope
    set?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    disconnect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    delete?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    connect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    update?: PlanTemplateItemUpdateWithWhereUniqueWithoutMaterialInput | PlanTemplateItemUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: PlanTemplateItemUpdateManyWithWhereWithoutMaterialInput | PlanTemplateItemUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: PlanTemplateItemScalarWhereInput | PlanTemplateItemScalarWhereInput[]
  }

  export type CustomerPricingUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<CustomerPricingCreateWithoutMaterialInput, CustomerPricingUncheckedCreateWithoutMaterialInput> | CustomerPricingCreateWithoutMaterialInput[] | CustomerPricingUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CustomerPricingCreateOrConnectWithoutMaterialInput | CustomerPricingCreateOrConnectWithoutMaterialInput[]
    upsert?: CustomerPricingUpsertWithWhereUniqueWithoutMaterialInput | CustomerPricingUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: CustomerPricingCreateManyMaterialInputEnvelope
    set?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    disconnect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    delete?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    connect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    update?: CustomerPricingUpdateWithWhereUniqueWithoutMaterialInput | CustomerPricingUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: CustomerPricingUpdateManyWithWhereWithoutMaterialInput | CustomerPricingUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: CustomerPricingScalarWhereInput | CustomerPricingScalarWhereInput[]
  }

  export type TakeoffLineItemUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<TakeoffLineItemCreateWithoutMaterialInput, TakeoffLineItemUncheckedCreateWithoutMaterialInput> | TakeoffLineItemCreateWithoutMaterialInput[] | TakeoffLineItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: TakeoffLineItemCreateOrConnectWithoutMaterialInput | TakeoffLineItemCreateOrConnectWithoutMaterialInput[]
    upsert?: TakeoffLineItemUpsertWithWhereUniqueWithoutMaterialInput | TakeoffLineItemUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: TakeoffLineItemCreateManyMaterialInputEnvelope
    set?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    disconnect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    delete?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    connect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    update?: TakeoffLineItemUpdateWithWhereUniqueWithoutMaterialInput | TakeoffLineItemUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: TakeoffLineItemUpdateManyWithWhereWithoutMaterialInput | TakeoffLineItemUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: TakeoffLineItemScalarWhereInput | TakeoffLineItemScalarWhereInput[]
  }

  export type PricingHistoryUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<PricingHistoryCreateWithoutMaterialInput, PricingHistoryUncheckedCreateWithoutMaterialInput> | PricingHistoryCreateWithoutMaterialInput[] | PricingHistoryUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PricingHistoryCreateOrConnectWithoutMaterialInput | PricingHistoryCreateOrConnectWithoutMaterialInput[]
    upsert?: PricingHistoryUpsertWithWhereUniqueWithoutMaterialInput | PricingHistoryUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: PricingHistoryCreateManyMaterialInputEnvelope
    set?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
    disconnect?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
    delete?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
    connect?: PricingHistoryWhereUniqueInput | PricingHistoryWhereUniqueInput[]
    update?: PricingHistoryUpdateWithWhereUniqueWithoutMaterialInput | PricingHistoryUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: PricingHistoryUpdateManyWithWhereWithoutMaterialInput | PricingHistoryUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: PricingHistoryScalarWhereInput | PricingHistoryScalarWhereInput[]
  }

  export type PlanTemplateItemUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<PlanTemplateItemCreateWithoutMaterialInput, PlanTemplateItemUncheckedCreateWithoutMaterialInput> | PlanTemplateItemCreateWithoutMaterialInput[] | PlanTemplateItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PlanTemplateItemCreateOrConnectWithoutMaterialInput | PlanTemplateItemCreateOrConnectWithoutMaterialInput[]
    upsert?: PlanTemplateItemUpsertWithWhereUniqueWithoutMaterialInput | PlanTemplateItemUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: PlanTemplateItemCreateManyMaterialInputEnvelope
    set?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    disconnect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    delete?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    connect?: PlanTemplateItemWhereUniqueInput | PlanTemplateItemWhereUniqueInput[]
    update?: PlanTemplateItemUpdateWithWhereUniqueWithoutMaterialInput | PlanTemplateItemUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: PlanTemplateItemUpdateManyWithWhereWithoutMaterialInput | PlanTemplateItemUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: PlanTemplateItemScalarWhereInput | PlanTemplateItemScalarWhereInput[]
  }

  export type CustomerPricingUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<CustomerPricingCreateWithoutMaterialInput, CustomerPricingUncheckedCreateWithoutMaterialInput> | CustomerPricingCreateWithoutMaterialInput[] | CustomerPricingUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CustomerPricingCreateOrConnectWithoutMaterialInput | CustomerPricingCreateOrConnectWithoutMaterialInput[]
    upsert?: CustomerPricingUpsertWithWhereUniqueWithoutMaterialInput | CustomerPricingUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: CustomerPricingCreateManyMaterialInputEnvelope
    set?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    disconnect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    delete?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    connect?: CustomerPricingWhereUniqueInput | CustomerPricingWhereUniqueInput[]
    update?: CustomerPricingUpdateWithWhereUniqueWithoutMaterialInput | CustomerPricingUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: CustomerPricingUpdateManyWithWhereWithoutMaterialInput | CustomerPricingUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: CustomerPricingScalarWhereInput | CustomerPricingScalarWhereInput[]
  }

  export type TakeoffLineItemUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<TakeoffLineItemCreateWithoutMaterialInput, TakeoffLineItemUncheckedCreateWithoutMaterialInput> | TakeoffLineItemCreateWithoutMaterialInput[] | TakeoffLineItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: TakeoffLineItemCreateOrConnectWithoutMaterialInput | TakeoffLineItemCreateOrConnectWithoutMaterialInput[]
    upsert?: TakeoffLineItemUpsertWithWhereUniqueWithoutMaterialInput | TakeoffLineItemUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: TakeoffLineItemCreateManyMaterialInputEnvelope
    set?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    disconnect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    delete?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    connect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    update?: TakeoffLineItemUpdateWithWhereUniqueWithoutMaterialInput | TakeoffLineItemUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: TakeoffLineItemUpdateManyWithWhereWithoutMaterialInput | TakeoffLineItemUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: TakeoffLineItemScalarWhereInput | TakeoffLineItemScalarWhereInput[]
  }

  export type MaterialCreateNestedManyWithoutVendorInput = {
    create?: XOR<MaterialCreateWithoutVendorInput, MaterialUncheckedCreateWithoutVendorInput> | MaterialCreateWithoutVendorInput[] | MaterialUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutVendorInput | MaterialCreateOrConnectWithoutVendorInput[]
    createMany?: MaterialCreateManyVendorInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<MaterialCreateWithoutVendorInput, MaterialUncheckedCreateWithoutVendorInput> | MaterialCreateWithoutVendorInput[] | MaterialUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutVendorInput | MaterialCreateOrConnectWithoutVendorInput[]
    createMany?: MaterialCreateManyVendorInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type MaterialUpdateManyWithoutVendorNestedInput = {
    create?: XOR<MaterialCreateWithoutVendorInput, MaterialUncheckedCreateWithoutVendorInput> | MaterialCreateWithoutVendorInput[] | MaterialUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutVendorInput | MaterialCreateOrConnectWithoutVendorInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutVendorInput | MaterialUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: MaterialCreateManyVendorInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutVendorInput | MaterialUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutVendorInput | MaterialUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput | PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput | PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutVendorInput | PurchaseOrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<MaterialCreateWithoutVendorInput, MaterialUncheckedCreateWithoutVendorInput> | MaterialCreateWithoutVendorInput[] | MaterialUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutVendorInput | MaterialCreateOrConnectWithoutVendorInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutVendorInput | MaterialUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: MaterialCreateManyVendorInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutVendorInput | MaterialUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutVendorInput | MaterialUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput | PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput | PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutVendorInput | PurchaseOrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type MaterialCreateNestedOneWithoutPricingHistoryInput = {
    create?: XOR<MaterialCreateWithoutPricingHistoryInput, MaterialUncheckedCreateWithoutPricingHistoryInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutPricingHistoryInput
    connect?: MaterialWhereUniqueInput
  }

  export type MaterialUpdateOneRequiredWithoutPricingHistoryNestedInput = {
    create?: XOR<MaterialCreateWithoutPricingHistoryInput, MaterialUncheckedCreateWithoutPricingHistoryInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutPricingHistoryInput
    upsert?: MaterialUpsertWithoutPricingHistoryInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutPricingHistoryInput, MaterialUpdateWithoutPricingHistoryInput>, MaterialUncheckedUpdateWithoutPricingHistoryInput>
  }

  export type CustomerCreateNestedOneWithoutCommunitiesInput = {
    create?: XOR<CustomerCreateWithoutCommunitiesInput, CustomerUncheckedCreateWithoutCommunitiesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCommunitiesInput
    connect?: CustomerWhereUniqueInput
  }

  export type LotCreateNestedManyWithoutCommunityInput = {
    create?: XOR<LotCreateWithoutCommunityInput, LotUncheckedCreateWithoutCommunityInput> | LotCreateWithoutCommunityInput[] | LotUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LotCreateOrConnectWithoutCommunityInput | LotCreateOrConnectWithoutCommunityInput[]
    createMany?: LotCreateManyCommunityInputEnvelope
    connect?: LotWhereUniqueInput | LotWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutCommunityInput = {
    create?: XOR<JobCreateWithoutCommunityInput, JobUncheckedCreateWithoutCommunityInput> | JobCreateWithoutCommunityInput[] | JobUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCommunityInput | JobCreateOrConnectWithoutCommunityInput[]
    createMany?: JobCreateManyCommunityInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type VariancePatternCreateNestedManyWithoutCommunityInput = {
    create?: XOR<VariancePatternCreateWithoutCommunityInput, VariancePatternUncheckedCreateWithoutCommunityInput> | VariancePatternCreateWithoutCommunityInput[] | VariancePatternUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutCommunityInput | VariancePatternCreateOrConnectWithoutCommunityInput[]
    createMany?: VariancePatternCreateManyCommunityInputEnvelope
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
  }

  export type LotUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<LotCreateWithoutCommunityInput, LotUncheckedCreateWithoutCommunityInput> | LotCreateWithoutCommunityInput[] | LotUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LotCreateOrConnectWithoutCommunityInput | LotCreateOrConnectWithoutCommunityInput[]
    createMany?: LotCreateManyCommunityInputEnvelope
    connect?: LotWhereUniqueInput | LotWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<JobCreateWithoutCommunityInput, JobUncheckedCreateWithoutCommunityInput> | JobCreateWithoutCommunityInput[] | JobUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCommunityInput | JobCreateOrConnectWithoutCommunityInput[]
    createMany?: JobCreateManyCommunityInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type VariancePatternUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<VariancePatternCreateWithoutCommunityInput, VariancePatternUncheckedCreateWithoutCommunityInput> | VariancePatternCreateWithoutCommunityInput[] | VariancePatternUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutCommunityInput | VariancePatternCreateOrConnectWithoutCommunityInput[]
    createMany?: VariancePatternCreateManyCommunityInputEnvelope
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutCommunitiesNestedInput = {
    create?: XOR<CustomerCreateWithoutCommunitiesInput, CustomerUncheckedCreateWithoutCommunitiesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCommunitiesInput
    upsert?: CustomerUpsertWithoutCommunitiesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCommunitiesInput, CustomerUpdateWithoutCommunitiesInput>, CustomerUncheckedUpdateWithoutCommunitiesInput>
  }

  export type LotUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<LotCreateWithoutCommunityInput, LotUncheckedCreateWithoutCommunityInput> | LotCreateWithoutCommunityInput[] | LotUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LotCreateOrConnectWithoutCommunityInput | LotCreateOrConnectWithoutCommunityInput[]
    upsert?: LotUpsertWithWhereUniqueWithoutCommunityInput | LotUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: LotCreateManyCommunityInputEnvelope
    set?: LotWhereUniqueInput | LotWhereUniqueInput[]
    disconnect?: LotWhereUniqueInput | LotWhereUniqueInput[]
    delete?: LotWhereUniqueInput | LotWhereUniqueInput[]
    connect?: LotWhereUniqueInput | LotWhereUniqueInput[]
    update?: LotUpdateWithWhereUniqueWithoutCommunityInput | LotUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: LotUpdateManyWithWhereWithoutCommunityInput | LotUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: LotScalarWhereInput | LotScalarWhereInput[]
  }

  export type JobUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<JobCreateWithoutCommunityInput, JobUncheckedCreateWithoutCommunityInput> | JobCreateWithoutCommunityInput[] | JobUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCommunityInput | JobCreateOrConnectWithoutCommunityInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCommunityInput | JobUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: JobCreateManyCommunityInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCommunityInput | JobUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCommunityInput | JobUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type VariancePatternUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<VariancePatternCreateWithoutCommunityInput, VariancePatternUncheckedCreateWithoutCommunityInput> | VariancePatternCreateWithoutCommunityInput[] | VariancePatternUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutCommunityInput | VariancePatternCreateOrConnectWithoutCommunityInput[]
    upsert?: VariancePatternUpsertWithWhereUniqueWithoutCommunityInput | VariancePatternUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: VariancePatternCreateManyCommunityInputEnvelope
    set?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    disconnect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    delete?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    update?: VariancePatternUpdateWithWhereUniqueWithoutCommunityInput | VariancePatternUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: VariancePatternUpdateManyWithWhereWithoutCommunityInput | VariancePatternUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: VariancePatternScalarWhereInput | VariancePatternScalarWhereInput[]
  }

  export type LotUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<LotCreateWithoutCommunityInput, LotUncheckedCreateWithoutCommunityInput> | LotCreateWithoutCommunityInput[] | LotUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LotCreateOrConnectWithoutCommunityInput | LotCreateOrConnectWithoutCommunityInput[]
    upsert?: LotUpsertWithWhereUniqueWithoutCommunityInput | LotUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: LotCreateManyCommunityInputEnvelope
    set?: LotWhereUniqueInput | LotWhereUniqueInput[]
    disconnect?: LotWhereUniqueInput | LotWhereUniqueInput[]
    delete?: LotWhereUniqueInput | LotWhereUniqueInput[]
    connect?: LotWhereUniqueInput | LotWhereUniqueInput[]
    update?: LotUpdateWithWhereUniqueWithoutCommunityInput | LotUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: LotUpdateManyWithWhereWithoutCommunityInput | LotUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: LotScalarWhereInput | LotScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<JobCreateWithoutCommunityInput, JobUncheckedCreateWithoutCommunityInput> | JobCreateWithoutCommunityInput[] | JobUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCommunityInput | JobCreateOrConnectWithoutCommunityInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCommunityInput | JobUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: JobCreateManyCommunityInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCommunityInput | JobUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCommunityInput | JobUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type VariancePatternUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<VariancePatternCreateWithoutCommunityInput, VariancePatternUncheckedCreateWithoutCommunityInput> | VariancePatternCreateWithoutCommunityInput[] | VariancePatternUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: VariancePatternCreateOrConnectWithoutCommunityInput | VariancePatternCreateOrConnectWithoutCommunityInput[]
    upsert?: VariancePatternUpsertWithWhereUniqueWithoutCommunityInput | VariancePatternUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: VariancePatternCreateManyCommunityInputEnvelope
    set?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    disconnect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    delete?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    connect?: VariancePatternWhereUniqueInput | VariancePatternWhereUniqueInput[]
    update?: VariancePatternUpdateWithWhereUniqueWithoutCommunityInput | VariancePatternUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: VariancePatternUpdateManyWithWhereWithoutCommunityInput | VariancePatternUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: VariancePatternScalarWhereInput | VariancePatternScalarWhereInput[]
  }

  export type CommunityCreateNestedOneWithoutLotsInput = {
    create?: XOR<CommunityCreateWithoutLotsInput, CommunityUncheckedCreateWithoutLotsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutLotsInput
    connect?: CommunityWhereUniqueInput
  }

  export type JobCreateNestedManyWithoutLotInput = {
    create?: XOR<JobCreateWithoutLotInput, JobUncheckedCreateWithoutLotInput> | JobCreateWithoutLotInput[] | JobUncheckedCreateWithoutLotInput[]
    connectOrCreate?: JobCreateOrConnectWithoutLotInput | JobCreateOrConnectWithoutLotInput[]
    createMany?: JobCreateManyLotInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutLotInput = {
    create?: XOR<JobCreateWithoutLotInput, JobUncheckedCreateWithoutLotInput> | JobCreateWithoutLotInput[] | JobUncheckedCreateWithoutLotInput[]
    connectOrCreate?: JobCreateOrConnectWithoutLotInput | JobCreateOrConnectWithoutLotInput[]
    createMany?: JobCreateManyLotInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type EnumLotStatusFieldUpdateOperationsInput = {
    set?: $Enums.LotStatus
  }

  export type CommunityUpdateOneRequiredWithoutLotsNestedInput = {
    create?: XOR<CommunityCreateWithoutLotsInput, CommunityUncheckedCreateWithoutLotsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutLotsInput
    upsert?: CommunityUpsertWithoutLotsInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutLotsInput, CommunityUpdateWithoutLotsInput>, CommunityUncheckedUpdateWithoutLotsInput>
  }

  export type JobUpdateManyWithoutLotNestedInput = {
    create?: XOR<JobCreateWithoutLotInput, JobUncheckedCreateWithoutLotInput> | JobCreateWithoutLotInput[] | JobUncheckedCreateWithoutLotInput[]
    connectOrCreate?: JobCreateOrConnectWithoutLotInput | JobCreateOrConnectWithoutLotInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutLotInput | JobUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: JobCreateManyLotInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutLotInput | JobUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: JobUpdateManyWithWhereWithoutLotInput | JobUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutLotNestedInput = {
    create?: XOR<JobCreateWithoutLotInput, JobUncheckedCreateWithoutLotInput> | JobCreateWithoutLotInput[] | JobUncheckedCreateWithoutLotInput[]
    connectOrCreate?: JobCreateOrConnectWithoutLotInput | JobCreateOrConnectWithoutLotInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutLotInput | JobUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: JobCreateManyLotInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutLotInput | JobUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: JobUpdateManyWithWhereWithoutLotInput | JobUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutJobsInput = {
    create?: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJobsInput
    connect?: CustomerWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutJobsInput = {
    create?: XOR<PlanCreateWithoutJobsInput, PlanUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutJobsInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanElevationCreateNestedOneWithoutJobsInput = {
    create?: XOR<PlanElevationCreateWithoutJobsInput, PlanElevationUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PlanElevationCreateOrConnectWithoutJobsInput
    connect?: PlanElevationWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutJobsInput = {
    create?: XOR<CommunityCreateWithoutJobsInput, CommunityUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutJobsInput
    connect?: CommunityWhereUniqueInput
  }

  export type LotCreateNestedOneWithoutJobsInput = {
    create?: XOR<LotCreateWithoutJobsInput, LotUncheckedCreateWithoutJobsInput>
    connectOrCreate?: LotCreateOrConnectWithoutJobsInput
    connect?: LotWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedJobsInput = {
    create?: XOR<UserCreateWithoutCreatedJobsInput, UserUncheckedCreateWithoutCreatedJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedJobsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedJobsInput = {
    create?: XOR<UserCreateWithoutApprovedJobsInput, UserUncheckedCreateWithoutApprovedJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedJobsInput
    connect?: UserWhereUniqueInput
  }

  export type JobOptionCreateNestedManyWithoutJobInput = {
    create?: XOR<JobOptionCreateWithoutJobInput, JobOptionUncheckedCreateWithoutJobInput> | JobOptionCreateWithoutJobInput[] | JobOptionUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobOptionCreateOrConnectWithoutJobInput | JobOptionCreateOrConnectWithoutJobInput[]
    createMany?: JobOptionCreateManyJobInputEnvelope
    connect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
  }

  export type TakeoffCreateNestedOneWithoutJobInput = {
    create?: XOR<TakeoffCreateWithoutJobInput, TakeoffUncheckedCreateWithoutJobInput>
    connectOrCreate?: TakeoffCreateOrConnectWithoutJobInput
    connect?: TakeoffWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedManyWithoutJobInput = {
    create?: XOR<PurchaseOrderCreateWithoutJobInput, PurchaseOrderUncheckedCreateWithoutJobInput> | PurchaseOrderCreateWithoutJobInput[] | PurchaseOrderUncheckedCreateWithoutJobInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutJobInput | PurchaseOrderCreateOrConnectWithoutJobInput[]
    createMany?: PurchaseOrderCreateManyJobInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type JobOptionUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<JobOptionCreateWithoutJobInput, JobOptionUncheckedCreateWithoutJobInput> | JobOptionCreateWithoutJobInput[] | JobOptionUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobOptionCreateOrConnectWithoutJobInput | JobOptionCreateOrConnectWithoutJobInput[]
    createMany?: JobOptionCreateManyJobInputEnvelope
    connect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
  }

  export type TakeoffUncheckedCreateNestedOneWithoutJobInput = {
    create?: XOR<TakeoffCreateWithoutJobInput, TakeoffUncheckedCreateWithoutJobInput>
    connectOrCreate?: TakeoffCreateOrConnectWithoutJobInput
    connect?: TakeoffWhereUniqueInput
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<PurchaseOrderCreateWithoutJobInput, PurchaseOrderUncheckedCreateWithoutJobInput> | PurchaseOrderCreateWithoutJobInput[] | PurchaseOrderUncheckedCreateWithoutJobInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutJobInput | PurchaseOrderCreateOrConnectWithoutJobInput[]
    createMany?: PurchaseOrderCreateManyJobInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type CustomerUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJobsInput
    upsert?: CustomerUpsertWithoutJobsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutJobsInput, CustomerUpdateWithoutJobsInput>, CustomerUncheckedUpdateWithoutJobsInput>
  }

  export type PlanUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<PlanCreateWithoutJobsInput, PlanUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutJobsInput
    upsert?: PlanUpsertWithoutJobsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutJobsInput, PlanUpdateWithoutJobsInput>, PlanUncheckedUpdateWithoutJobsInput>
  }

  export type PlanElevationUpdateOneWithoutJobsNestedInput = {
    create?: XOR<PlanElevationCreateWithoutJobsInput, PlanElevationUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PlanElevationCreateOrConnectWithoutJobsInput
    upsert?: PlanElevationUpsertWithoutJobsInput
    disconnect?: PlanElevationWhereInput | boolean
    delete?: PlanElevationWhereInput | boolean
    connect?: PlanElevationWhereUniqueInput
    update?: XOR<XOR<PlanElevationUpdateToOneWithWhereWithoutJobsInput, PlanElevationUpdateWithoutJobsInput>, PlanElevationUncheckedUpdateWithoutJobsInput>
  }

  export type CommunityUpdateOneWithoutJobsNestedInput = {
    create?: XOR<CommunityCreateWithoutJobsInput, CommunityUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutJobsInput
    upsert?: CommunityUpsertWithoutJobsInput
    disconnect?: CommunityWhereInput | boolean
    delete?: CommunityWhereInput | boolean
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutJobsInput, CommunityUpdateWithoutJobsInput>, CommunityUncheckedUpdateWithoutJobsInput>
  }

  export type LotUpdateOneWithoutJobsNestedInput = {
    create?: XOR<LotCreateWithoutJobsInput, LotUncheckedCreateWithoutJobsInput>
    connectOrCreate?: LotCreateOrConnectWithoutJobsInput
    upsert?: LotUpsertWithoutJobsInput
    disconnect?: LotWhereInput | boolean
    delete?: LotWhereInput | boolean
    connect?: LotWhereUniqueInput
    update?: XOR<XOR<LotUpdateToOneWithWhereWithoutJobsInput, LotUpdateWithoutJobsInput>, LotUncheckedUpdateWithoutJobsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedJobsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedJobsInput, UserUncheckedCreateWithoutCreatedJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedJobsInput
    upsert?: UserUpsertWithoutCreatedJobsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedJobsInput, UserUpdateWithoutCreatedJobsInput>, UserUncheckedUpdateWithoutCreatedJobsInput>
  }

  export type UserUpdateOneWithoutApprovedJobsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedJobsInput, UserUncheckedCreateWithoutApprovedJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedJobsInput
    upsert?: UserUpsertWithoutApprovedJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedJobsInput, UserUpdateWithoutApprovedJobsInput>, UserUncheckedUpdateWithoutApprovedJobsInput>
  }

  export type JobOptionUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobOptionCreateWithoutJobInput, JobOptionUncheckedCreateWithoutJobInput> | JobOptionCreateWithoutJobInput[] | JobOptionUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobOptionCreateOrConnectWithoutJobInput | JobOptionCreateOrConnectWithoutJobInput[]
    upsert?: JobOptionUpsertWithWhereUniqueWithoutJobInput | JobOptionUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobOptionCreateManyJobInputEnvelope
    set?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    disconnect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    delete?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    connect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    update?: JobOptionUpdateWithWhereUniqueWithoutJobInput | JobOptionUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobOptionUpdateManyWithWhereWithoutJobInput | JobOptionUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobOptionScalarWhereInput | JobOptionScalarWhereInput[]
  }

  export type TakeoffUpdateOneWithoutJobNestedInput = {
    create?: XOR<TakeoffCreateWithoutJobInput, TakeoffUncheckedCreateWithoutJobInput>
    connectOrCreate?: TakeoffCreateOrConnectWithoutJobInput
    upsert?: TakeoffUpsertWithoutJobInput
    disconnect?: TakeoffWhereInput | boolean
    delete?: TakeoffWhereInput | boolean
    connect?: TakeoffWhereUniqueInput
    update?: XOR<XOR<TakeoffUpdateToOneWithWhereWithoutJobInput, TakeoffUpdateWithoutJobInput>, TakeoffUncheckedUpdateWithoutJobInput>
  }

  export type PurchaseOrderUpdateManyWithoutJobNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutJobInput, PurchaseOrderUncheckedCreateWithoutJobInput> | PurchaseOrderCreateWithoutJobInput[] | PurchaseOrderUncheckedCreateWithoutJobInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutJobInput | PurchaseOrderCreateOrConnectWithoutJobInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutJobInput | PurchaseOrderUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: PurchaseOrderCreateManyJobInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutJobInput | PurchaseOrderUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutJobInput | PurchaseOrderUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type JobOptionUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobOptionCreateWithoutJobInput, JobOptionUncheckedCreateWithoutJobInput> | JobOptionCreateWithoutJobInput[] | JobOptionUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobOptionCreateOrConnectWithoutJobInput | JobOptionCreateOrConnectWithoutJobInput[]
    upsert?: JobOptionUpsertWithWhereUniqueWithoutJobInput | JobOptionUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobOptionCreateManyJobInputEnvelope
    set?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    disconnect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    delete?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    connect?: JobOptionWhereUniqueInput | JobOptionWhereUniqueInput[]
    update?: JobOptionUpdateWithWhereUniqueWithoutJobInput | JobOptionUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobOptionUpdateManyWithWhereWithoutJobInput | JobOptionUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobOptionScalarWhereInput | JobOptionScalarWhereInput[]
  }

  export type TakeoffUncheckedUpdateOneWithoutJobNestedInput = {
    create?: XOR<TakeoffCreateWithoutJobInput, TakeoffUncheckedCreateWithoutJobInput>
    connectOrCreate?: TakeoffCreateOrConnectWithoutJobInput
    upsert?: TakeoffUpsertWithoutJobInput
    disconnect?: TakeoffWhereInput | boolean
    delete?: TakeoffWhereInput | boolean
    connect?: TakeoffWhereUniqueInput
    update?: XOR<XOR<TakeoffUpdateToOneWithWhereWithoutJobInput, TakeoffUpdateWithoutJobInput>, TakeoffUncheckedUpdateWithoutJobInput>
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutJobInput, PurchaseOrderUncheckedCreateWithoutJobInput> | PurchaseOrderCreateWithoutJobInput[] | PurchaseOrderUncheckedCreateWithoutJobInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutJobInput | PurchaseOrderCreateOrConnectWithoutJobInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutJobInput | PurchaseOrderUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: PurchaseOrderCreateManyJobInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutJobInput | PurchaseOrderUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutJobInput | PurchaseOrderUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type JobCreateNestedOneWithoutJobOptionsInput = {
    create?: XOR<JobCreateWithoutJobOptionsInput, JobUncheckedCreateWithoutJobOptionsInput>
    connectOrCreate?: JobCreateOrConnectWithoutJobOptionsInput
    connect?: JobWhereUniqueInput
  }

  export type PlanOptionCreateNestedOneWithoutJobOptionsInput = {
    create?: XOR<PlanOptionCreateWithoutJobOptionsInput, PlanOptionUncheckedCreateWithoutJobOptionsInput>
    connectOrCreate?: PlanOptionCreateOrConnectWithoutJobOptionsInput
    connect?: PlanOptionWhereUniqueInput
  }

  export type JobUpdateOneRequiredWithoutJobOptionsNestedInput = {
    create?: XOR<JobCreateWithoutJobOptionsInput, JobUncheckedCreateWithoutJobOptionsInput>
    connectOrCreate?: JobCreateOrConnectWithoutJobOptionsInput
    upsert?: JobUpsertWithoutJobOptionsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutJobOptionsInput, JobUpdateWithoutJobOptionsInput>, JobUncheckedUpdateWithoutJobOptionsInput>
  }

  export type PlanOptionUpdateOneRequiredWithoutJobOptionsNestedInput = {
    create?: XOR<PlanOptionCreateWithoutJobOptionsInput, PlanOptionUncheckedCreateWithoutJobOptionsInput>
    connectOrCreate?: PlanOptionCreateOrConnectWithoutJobOptionsInput
    upsert?: PlanOptionUpsertWithoutJobOptionsInput
    connect?: PlanOptionWhereUniqueInput
    update?: XOR<XOR<PlanOptionUpdateToOneWithWhereWithoutJobOptionsInput, PlanOptionUpdateWithoutJobOptionsInput>, PlanOptionUncheckedUpdateWithoutJobOptionsInput>
  }

  export type JobCreateNestedOneWithoutTakeoffInput = {
    create?: XOR<JobCreateWithoutTakeoffInput, JobUncheckedCreateWithoutTakeoffInput>
    connectOrCreate?: JobCreateOrConnectWithoutTakeoffInput
    connect?: JobWhereUniqueInput
  }

  export type TakeoffLineItemCreateNestedManyWithoutTakeoffInput = {
    create?: XOR<TakeoffLineItemCreateWithoutTakeoffInput, TakeoffLineItemUncheckedCreateWithoutTakeoffInput> | TakeoffLineItemCreateWithoutTakeoffInput[] | TakeoffLineItemUncheckedCreateWithoutTakeoffInput[]
    connectOrCreate?: TakeoffLineItemCreateOrConnectWithoutTakeoffInput | TakeoffLineItemCreateOrConnectWithoutTakeoffInput[]
    createMany?: TakeoffLineItemCreateManyTakeoffInputEnvelope
    connect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
  }

  export type TakeoffValidationCreateNestedOneWithoutTakeoffInput = {
    create?: XOR<TakeoffValidationCreateWithoutTakeoffInput, TakeoffValidationUncheckedCreateWithoutTakeoffInput>
    connectOrCreate?: TakeoffValidationCreateOrConnectWithoutTakeoffInput
    connect?: TakeoffValidationWhereUniqueInput
  }

  export type TakeoffLineItemUncheckedCreateNestedManyWithoutTakeoffInput = {
    create?: XOR<TakeoffLineItemCreateWithoutTakeoffInput, TakeoffLineItemUncheckedCreateWithoutTakeoffInput> | TakeoffLineItemCreateWithoutTakeoffInput[] | TakeoffLineItemUncheckedCreateWithoutTakeoffInput[]
    connectOrCreate?: TakeoffLineItemCreateOrConnectWithoutTakeoffInput | TakeoffLineItemCreateOrConnectWithoutTakeoffInput[]
    createMany?: TakeoffLineItemCreateManyTakeoffInputEnvelope
    connect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
  }

  export type TakeoffValidationUncheckedCreateNestedOneWithoutTakeoffInput = {
    create?: XOR<TakeoffValidationCreateWithoutTakeoffInput, TakeoffValidationUncheckedCreateWithoutTakeoffInput>
    connectOrCreate?: TakeoffValidationCreateOrConnectWithoutTakeoffInput
    connect?: TakeoffValidationWhereUniqueInput
  }

  export type EnumTakeoffStatusFieldUpdateOperationsInput = {
    set?: $Enums.TakeoffStatus
  }

  export type JobUpdateOneRequiredWithoutTakeoffNestedInput = {
    create?: XOR<JobCreateWithoutTakeoffInput, JobUncheckedCreateWithoutTakeoffInput>
    connectOrCreate?: JobCreateOrConnectWithoutTakeoffInput
    upsert?: JobUpsertWithoutTakeoffInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutTakeoffInput, JobUpdateWithoutTakeoffInput>, JobUncheckedUpdateWithoutTakeoffInput>
  }

  export type TakeoffLineItemUpdateManyWithoutTakeoffNestedInput = {
    create?: XOR<TakeoffLineItemCreateWithoutTakeoffInput, TakeoffLineItemUncheckedCreateWithoutTakeoffInput> | TakeoffLineItemCreateWithoutTakeoffInput[] | TakeoffLineItemUncheckedCreateWithoutTakeoffInput[]
    connectOrCreate?: TakeoffLineItemCreateOrConnectWithoutTakeoffInput | TakeoffLineItemCreateOrConnectWithoutTakeoffInput[]
    upsert?: TakeoffLineItemUpsertWithWhereUniqueWithoutTakeoffInput | TakeoffLineItemUpsertWithWhereUniqueWithoutTakeoffInput[]
    createMany?: TakeoffLineItemCreateManyTakeoffInputEnvelope
    set?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    disconnect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    delete?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    connect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    update?: TakeoffLineItemUpdateWithWhereUniqueWithoutTakeoffInput | TakeoffLineItemUpdateWithWhereUniqueWithoutTakeoffInput[]
    updateMany?: TakeoffLineItemUpdateManyWithWhereWithoutTakeoffInput | TakeoffLineItemUpdateManyWithWhereWithoutTakeoffInput[]
    deleteMany?: TakeoffLineItemScalarWhereInput | TakeoffLineItemScalarWhereInput[]
  }

  export type TakeoffValidationUpdateOneWithoutTakeoffNestedInput = {
    create?: XOR<TakeoffValidationCreateWithoutTakeoffInput, TakeoffValidationUncheckedCreateWithoutTakeoffInput>
    connectOrCreate?: TakeoffValidationCreateOrConnectWithoutTakeoffInput
    upsert?: TakeoffValidationUpsertWithoutTakeoffInput
    disconnect?: TakeoffValidationWhereInput | boolean
    delete?: TakeoffValidationWhereInput | boolean
    connect?: TakeoffValidationWhereUniqueInput
    update?: XOR<XOR<TakeoffValidationUpdateToOneWithWhereWithoutTakeoffInput, TakeoffValidationUpdateWithoutTakeoffInput>, TakeoffValidationUncheckedUpdateWithoutTakeoffInput>
  }

  export type TakeoffLineItemUncheckedUpdateManyWithoutTakeoffNestedInput = {
    create?: XOR<TakeoffLineItemCreateWithoutTakeoffInput, TakeoffLineItemUncheckedCreateWithoutTakeoffInput> | TakeoffLineItemCreateWithoutTakeoffInput[] | TakeoffLineItemUncheckedCreateWithoutTakeoffInput[]
    connectOrCreate?: TakeoffLineItemCreateOrConnectWithoutTakeoffInput | TakeoffLineItemCreateOrConnectWithoutTakeoffInput[]
    upsert?: TakeoffLineItemUpsertWithWhereUniqueWithoutTakeoffInput | TakeoffLineItemUpsertWithWhereUniqueWithoutTakeoffInput[]
    createMany?: TakeoffLineItemCreateManyTakeoffInputEnvelope
    set?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    disconnect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    delete?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    connect?: TakeoffLineItemWhereUniqueInput | TakeoffLineItemWhereUniqueInput[]
    update?: TakeoffLineItemUpdateWithWhereUniqueWithoutTakeoffInput | TakeoffLineItemUpdateWithWhereUniqueWithoutTakeoffInput[]
    updateMany?: TakeoffLineItemUpdateManyWithWhereWithoutTakeoffInput | TakeoffLineItemUpdateManyWithWhereWithoutTakeoffInput[]
    deleteMany?: TakeoffLineItemScalarWhereInput | TakeoffLineItemScalarWhereInput[]
  }

  export type TakeoffValidationUncheckedUpdateOneWithoutTakeoffNestedInput = {
    create?: XOR<TakeoffValidationCreateWithoutTakeoffInput, TakeoffValidationUncheckedCreateWithoutTakeoffInput>
    connectOrCreate?: TakeoffValidationCreateOrConnectWithoutTakeoffInput
    upsert?: TakeoffValidationUpsertWithoutTakeoffInput
    disconnect?: TakeoffValidationWhereInput | boolean
    delete?: TakeoffValidationWhereInput | boolean
    connect?: TakeoffValidationWhereUniqueInput
    update?: XOR<XOR<TakeoffValidationUpdateToOneWithWhereWithoutTakeoffInput, TakeoffValidationUpdateWithoutTakeoffInput>, TakeoffValidationUncheckedUpdateWithoutTakeoffInput>
  }

  export type TakeoffCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<TakeoffCreateWithoutLineItemsInput, TakeoffUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: TakeoffCreateOrConnectWithoutLineItemsInput
    connect?: TakeoffWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutTakeoffLineItemsInput = {
    create?: XOR<MaterialCreateWithoutTakeoffLineItemsInput, MaterialUncheckedCreateWithoutTakeoffLineItemsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutTakeoffLineItemsInput
    connect?: MaterialWhereUniqueInput
  }

  export type TakeoffUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<TakeoffCreateWithoutLineItemsInput, TakeoffUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: TakeoffCreateOrConnectWithoutLineItemsInput
    upsert?: TakeoffUpsertWithoutLineItemsInput
    connect?: TakeoffWhereUniqueInput
    update?: XOR<XOR<TakeoffUpdateToOneWithWhereWithoutLineItemsInput, TakeoffUpdateWithoutLineItemsInput>, TakeoffUncheckedUpdateWithoutLineItemsInput>
  }

  export type MaterialUpdateOneRequiredWithoutTakeoffLineItemsNestedInput = {
    create?: XOR<MaterialCreateWithoutTakeoffLineItemsInput, MaterialUncheckedCreateWithoutTakeoffLineItemsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutTakeoffLineItemsInput
    upsert?: MaterialUpsertWithoutTakeoffLineItemsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutTakeoffLineItemsInput, MaterialUpdateWithoutTakeoffLineItemsInput>, MaterialUncheckedUpdateWithoutTakeoffLineItemsInput>
  }

  export type TakeoffValidationCreatecomparedToJobsInput = {
    set: string[]
  }

  export type TakeoffCreateNestedOneWithoutValidationInput = {
    create?: XOR<TakeoffCreateWithoutValidationInput, TakeoffUncheckedCreateWithoutValidationInput>
    connectOrCreate?: TakeoffCreateOrConnectWithoutValidationInput
    connect?: TakeoffWhereUniqueInput
  }

  export type TakeoffValidationUpdatecomparedToJobsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TakeoffUpdateOneRequiredWithoutValidationNestedInput = {
    create?: XOR<TakeoffCreateWithoutValidationInput, TakeoffUncheckedCreateWithoutValidationInput>
    connectOrCreate?: TakeoffCreateOrConnectWithoutValidationInput
    upsert?: TakeoffUpsertWithoutValidationInput
    connect?: TakeoffWhereUniqueInput
    update?: XOR<XOR<TakeoffUpdateToOneWithWhereWithoutValidationInput, TakeoffUpdateWithoutValidationInput>, TakeoffUncheckedUpdateWithoutValidationInput>
  }

  export type PurchaseOrderCreatephotoUrlsInput = {
    set: string[]
  }

  export type JobCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<JobCreateWithoutPurchaseOrdersInput, JobUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: JobCreateOrConnectWithoutPurchaseOrdersInput
    connect?: JobWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<VendorCreateWithoutPurchaseOrdersInput, VendorUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseOrdersInput
    connect?: VendorWhereUniqueInput
  }

  export type EnumPOStatusFieldUpdateOperationsInput = {
    set?: $Enums.POStatus
  }

  export type PurchaseOrderUpdatephotoUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<JobCreateWithoutPurchaseOrdersInput, JobUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: JobCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: JobUpsertWithoutPurchaseOrdersInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutPurchaseOrdersInput, JobUpdateWithoutPurchaseOrdersInput>, JobUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type VendorUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<VendorCreateWithoutPurchaseOrdersInput, VendorUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: VendorUpsertWithoutPurchaseOrdersInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPurchaseOrdersInput, VendorUpdateWithoutPurchaseOrdersInput>, VendorUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PlanCreateNestedOneWithoutVariancePatternsInput = {
    create?: XOR<PlanCreateWithoutVariancePatternsInput, PlanUncheckedCreateWithoutVariancePatternsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutVariancePatternsInput
    connect?: PlanWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutVariancePatternsInput = {
    create?: XOR<CommunityCreateWithoutVariancePatternsInput, CommunityUncheckedCreateWithoutVariancePatternsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutVariancePatternsInput
    connect?: CommunityWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutVariancePatternsInput = {
    create?: XOR<CustomerCreateWithoutVariancePatternsInput, CustomerUncheckedCreateWithoutVariancePatternsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutVariancePatternsInput
    connect?: CustomerWhereUniqueInput
  }

  export type VarianceReviewCreateNestedManyWithoutPatternInput = {
    create?: XOR<VarianceReviewCreateWithoutPatternInput, VarianceReviewUncheckedCreateWithoutPatternInput> | VarianceReviewCreateWithoutPatternInput[] | VarianceReviewUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: VarianceReviewCreateOrConnectWithoutPatternInput | VarianceReviewCreateOrConnectWithoutPatternInput[]
    createMany?: VarianceReviewCreateManyPatternInputEnvelope
    connect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
  }

  export type VarianceReviewUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<VarianceReviewCreateWithoutPatternInput, VarianceReviewUncheckedCreateWithoutPatternInput> | VarianceReviewCreateWithoutPatternInput[] | VarianceReviewUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: VarianceReviewCreateOrConnectWithoutPatternInput | VarianceReviewCreateOrConnectWithoutPatternInput[]
    createMany?: VarianceReviewCreateManyPatternInputEnvelope
    connect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
  }

  export type EnumVarianceScopeFieldUpdateOperationsInput = {
    set?: $Enums.VarianceScope
  }

  export type EnumPatternStatusFieldUpdateOperationsInput = {
    set?: $Enums.PatternStatus
  }

  export type PlanUpdateOneWithoutVariancePatternsNestedInput = {
    create?: XOR<PlanCreateWithoutVariancePatternsInput, PlanUncheckedCreateWithoutVariancePatternsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutVariancePatternsInput
    upsert?: PlanUpsertWithoutVariancePatternsInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutVariancePatternsInput, PlanUpdateWithoutVariancePatternsInput>, PlanUncheckedUpdateWithoutVariancePatternsInput>
  }

  export type CommunityUpdateOneWithoutVariancePatternsNestedInput = {
    create?: XOR<CommunityCreateWithoutVariancePatternsInput, CommunityUncheckedCreateWithoutVariancePatternsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutVariancePatternsInput
    upsert?: CommunityUpsertWithoutVariancePatternsInput
    disconnect?: CommunityWhereInput | boolean
    delete?: CommunityWhereInput | boolean
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutVariancePatternsInput, CommunityUpdateWithoutVariancePatternsInput>, CommunityUncheckedUpdateWithoutVariancePatternsInput>
  }

  export type CustomerUpdateOneWithoutVariancePatternsNestedInput = {
    create?: XOR<CustomerCreateWithoutVariancePatternsInput, CustomerUncheckedCreateWithoutVariancePatternsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutVariancePatternsInput
    upsert?: CustomerUpsertWithoutVariancePatternsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutVariancePatternsInput, CustomerUpdateWithoutVariancePatternsInput>, CustomerUncheckedUpdateWithoutVariancePatternsInput>
  }

  export type VarianceReviewUpdateManyWithoutPatternNestedInput = {
    create?: XOR<VarianceReviewCreateWithoutPatternInput, VarianceReviewUncheckedCreateWithoutPatternInput> | VarianceReviewCreateWithoutPatternInput[] | VarianceReviewUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: VarianceReviewCreateOrConnectWithoutPatternInput | VarianceReviewCreateOrConnectWithoutPatternInput[]
    upsert?: VarianceReviewUpsertWithWhereUniqueWithoutPatternInput | VarianceReviewUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: VarianceReviewCreateManyPatternInputEnvelope
    set?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    disconnect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    delete?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    connect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    update?: VarianceReviewUpdateWithWhereUniqueWithoutPatternInput | VarianceReviewUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: VarianceReviewUpdateManyWithWhereWithoutPatternInput | VarianceReviewUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: VarianceReviewScalarWhereInput | VarianceReviewScalarWhereInput[]
  }

  export type VarianceReviewUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<VarianceReviewCreateWithoutPatternInput, VarianceReviewUncheckedCreateWithoutPatternInput> | VarianceReviewCreateWithoutPatternInput[] | VarianceReviewUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: VarianceReviewCreateOrConnectWithoutPatternInput | VarianceReviewCreateOrConnectWithoutPatternInput[]
    upsert?: VarianceReviewUpsertWithWhereUniqueWithoutPatternInput | VarianceReviewUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: VarianceReviewCreateManyPatternInputEnvelope
    set?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    disconnect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    delete?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    connect?: VarianceReviewWhereUniqueInput | VarianceReviewWhereUniqueInput[]
    update?: VarianceReviewUpdateWithWhereUniqueWithoutPatternInput | VarianceReviewUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: VarianceReviewUpdateManyWithWhereWithoutPatternInput | VarianceReviewUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: VarianceReviewScalarWhereInput | VarianceReviewScalarWhereInput[]
  }

  export type VariancePatternCreateNestedOneWithoutReviewsInput = {
    create?: XOR<VariancePatternCreateWithoutReviewsInput, VariancePatternUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: VariancePatternCreateOrConnectWithoutReviewsInput
    connect?: VariancePatternWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVarianceReviewsInput = {
    create?: XOR<UserCreateWithoutVarianceReviewsInput, UserUncheckedCreateWithoutVarianceReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVarianceReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReviewDecisionFieldUpdateOperationsInput = {
    set?: $Enums.ReviewDecision
  }

  export type VariancePatternUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<VariancePatternCreateWithoutReviewsInput, VariancePatternUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: VariancePatternCreateOrConnectWithoutReviewsInput
    upsert?: VariancePatternUpsertWithoutReviewsInput
    connect?: VariancePatternWhereUniqueInput
    update?: XOR<XOR<VariancePatternUpdateToOneWithWhereWithoutReviewsInput, VariancePatternUpdateWithoutReviewsInput>, VariancePatternUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutVarianceReviewsNestedInput = {
    create?: XOR<UserCreateWithoutVarianceReviewsInput, UserUncheckedCreateWithoutVarianceReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVarianceReviewsInput
    upsert?: UserUpsertWithoutVarianceReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVarianceReviewsInput, UserUpdateWithoutVarianceReviewsInput>, UserUncheckedUpdateWithoutVarianceReviewsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumOptionCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionCategory | EnumOptionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.OptionCategory[] | ListEnumOptionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.OptionCategory[] | ListEnumOptionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumOptionCategoryFilter<$PrismaModel> | $Enums.OptionCategory
  }

  export type NestedEnumOptionCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionCategory | EnumOptionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.OptionCategory[] | ListEnumOptionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.OptionCategory[] | ListEnumOptionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumOptionCategoryWithAggregatesFilter<$PrismaModel> | $Enums.OptionCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptionCategoryFilter<$PrismaModel>
    _max?: NestedEnumOptionCategoryFilter<$PrismaModel>
  }

  export type NestedEnumMaterialCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialCategory | EnumMaterialCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialCategory[] | ListEnumMaterialCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialCategory[] | ListEnumMaterialCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialCategoryFilter<$PrismaModel> | $Enums.MaterialCategory
  }

  export type NestedEnumMaterialCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialCategory | EnumMaterialCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialCategory[] | ListEnumMaterialCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialCategory[] | ListEnumMaterialCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MaterialCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialCategoryFilter<$PrismaModel>
    _max?: NestedEnumMaterialCategoryFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumLotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LotStatus | EnumLotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLotStatusFilter<$PrismaModel> | $Enums.LotStatus
  }

  export type NestedEnumLotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LotStatus | EnumLotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLotStatusWithAggregatesFilter<$PrismaModel> | $Enums.LotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLotStatusFilter<$PrismaModel>
    _max?: NestedEnumLotStatusFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumTakeoffStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TakeoffStatus | EnumTakeoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TakeoffStatus[] | ListEnumTakeoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TakeoffStatus[] | ListEnumTakeoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTakeoffStatusFilter<$PrismaModel> | $Enums.TakeoffStatus
  }

  export type NestedEnumTakeoffStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TakeoffStatus | EnumTakeoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TakeoffStatus[] | ListEnumTakeoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TakeoffStatus[] | ListEnumTakeoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTakeoffStatusWithAggregatesFilter<$PrismaModel> | $Enums.TakeoffStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTakeoffStatusFilter<$PrismaModel>
    _max?: NestedEnumTakeoffStatusFilter<$PrismaModel>
  }

  export type NestedEnumPOStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.POStatus | EnumPOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOStatusFilter<$PrismaModel> | $Enums.POStatus
  }

  export type NestedEnumPOStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POStatus | EnumPOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOStatusWithAggregatesFilter<$PrismaModel> | $Enums.POStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOStatusFilter<$PrismaModel>
    _max?: NestedEnumPOStatusFilter<$PrismaModel>
  }

  export type NestedEnumVarianceScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.VarianceScope | EnumVarianceScopeFieldRefInput<$PrismaModel>
    in?: $Enums.VarianceScope[] | ListEnumVarianceScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VarianceScope[] | ListEnumVarianceScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumVarianceScopeFilter<$PrismaModel> | $Enums.VarianceScope
  }

  export type NestedEnumPatternStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternStatus | EnumPatternStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternStatusFilter<$PrismaModel> | $Enums.PatternStatus
  }

  export type NestedEnumVarianceScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VarianceScope | EnumVarianceScopeFieldRefInput<$PrismaModel>
    in?: $Enums.VarianceScope[] | ListEnumVarianceScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VarianceScope[] | ListEnumVarianceScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumVarianceScopeWithAggregatesFilter<$PrismaModel> | $Enums.VarianceScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVarianceScopeFilter<$PrismaModel>
    _max?: NestedEnumVarianceScopeFilter<$PrismaModel>
  }

  export type NestedEnumPatternStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternStatus | EnumPatternStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternStatusWithAggregatesFilter<$PrismaModel> | $Enums.PatternStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPatternStatusFilter<$PrismaModel>
    _max?: NestedEnumPatternStatusFilter<$PrismaModel>
  }

  export type NestedEnumReviewDecisionFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewDecisionFilter<$PrismaModel> | $Enums.ReviewDecision
  }

  export type NestedEnumReviewDecisionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewDecisionWithAggregatesFilter<$PrismaModel> | $Enums.ReviewDecision
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewDecisionFilter<$PrismaModel>
    _max?: NestedEnumReviewDecisionFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type JobCreateWithoutCreatedByInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    plan: PlanCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutCreatedByInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutCreatedByInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutCreatedByInput, JobUncheckedCreateWithoutCreatedByInput>
  }

  export type JobCreateManyCreatedByInputEnvelope = {
    data: JobCreateManyCreatedByInput | JobCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutApprovedByInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    plan: PlanCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutApprovedByInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutApprovedByInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutApprovedByInput, JobUncheckedCreateWithoutApprovedByInput>
  }

  export type JobCreateManyApprovedByInputEnvelope = {
    data: JobCreateManyApprovedByInput | JobCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VarianceReviewCreateWithoutReviewerInput = {
    id?: string
    decision: $Enums.ReviewDecision
    notes?: string | null
    reviewedAt?: Date | string
    pattern: VariancePatternCreateNestedOneWithoutReviewsInput
  }

  export type VarianceReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    patternId: string
    decision: $Enums.ReviewDecision
    notes?: string | null
    reviewedAt?: Date | string
  }

  export type VarianceReviewCreateOrConnectWithoutReviewerInput = {
    where: VarianceReviewWhereUniqueInput
    create: XOR<VarianceReviewCreateWithoutReviewerInput, VarianceReviewUncheckedCreateWithoutReviewerInput>
  }

  export type VarianceReviewCreateManyReviewerInputEnvelope = {
    data: VarianceReviewCreateManyReviewerInput | VarianceReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type JobUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutCreatedByInput, JobUncheckedUpdateWithoutCreatedByInput>
    create: XOR<JobCreateWithoutCreatedByInput, JobUncheckedCreateWithoutCreatedByInput>
  }

  export type JobUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutCreatedByInput, JobUncheckedUpdateWithoutCreatedByInput>
  }

  export type JobUpdateManyWithWhereWithoutCreatedByInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: StringFilter<"Job"> | string
    jobNumber?: StringFilter<"Job"> | string
    customerId?: StringFilter<"Job"> | string
    planId?: StringFilter<"Job"> | string
    elevationId?: StringNullableFilter<"Job"> | string | null
    communityId?: StringNullableFilter<"Job"> | string | null
    lotId?: StringNullableFilter<"Job"> | string | null
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    estimatedCost?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    actualCost?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    margin?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFilter<"Job"> | string
    approvedById?: StringNullableFilter<"Job"> | string | null
    approvedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    completionDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    notes?: StringNullableFilter<"Job"> | string | null
    folderPath?: StringNullableFilter<"Job"> | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
  }

  export type JobUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutApprovedByInput, JobUncheckedUpdateWithoutApprovedByInput>
    create: XOR<JobCreateWithoutApprovedByInput, JobUncheckedCreateWithoutApprovedByInput>
  }

  export type JobUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutApprovedByInput, JobUncheckedUpdateWithoutApprovedByInput>
  }

  export type JobUpdateManyWithWhereWithoutApprovedByInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type VarianceReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: VarianceReviewWhereUniqueInput
    update: XOR<VarianceReviewUpdateWithoutReviewerInput, VarianceReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<VarianceReviewCreateWithoutReviewerInput, VarianceReviewUncheckedCreateWithoutReviewerInput>
  }

  export type VarianceReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: VarianceReviewWhereUniqueInput
    data: XOR<VarianceReviewUpdateWithoutReviewerInput, VarianceReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type VarianceReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: VarianceReviewScalarWhereInput
    data: XOR<VarianceReviewUpdateManyMutationInput, VarianceReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type VarianceReviewScalarWhereInput = {
    AND?: VarianceReviewScalarWhereInput | VarianceReviewScalarWhereInput[]
    OR?: VarianceReviewScalarWhereInput[]
    NOT?: VarianceReviewScalarWhereInput | VarianceReviewScalarWhereInput[]
    id?: StringFilter<"VarianceReview"> | string
    patternId?: StringFilter<"VarianceReview"> | string
    reviewerId?: StringFilter<"VarianceReview"> | string
    decision?: EnumReviewDecisionFilter<"VarianceReview"> | $Enums.ReviewDecision
    notes?: StringNullableFilter<"VarianceReview"> | string | null
    reviewedAt?: DateTimeFilter<"VarianceReview"> | Date | string
  }

  export type CustomerContactCreateWithoutCustomerInput = {
    id?: string
    contactName: string
    role?: string | null
    email?: string | null
    phone?: string | null
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type CustomerContactUncheckedCreateWithoutCustomerInput = {
    id?: string
    contactName: string
    role?: string | null
    email?: string | null
    phone?: string | null
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type CustomerContactCreateOrConnectWithoutCustomerInput = {
    where: CustomerContactWhereUniqueInput
    create: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerContactCreateManyCustomerInputEnvelope = {
    data: CustomerContactCreateManyCustomerInput | CustomerContactCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPricingTierCreateWithoutCustomerInput = {
    id?: string
    tierName: string
    discountPercentage: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type CustomerPricingTierUncheckedCreateWithoutCustomerInput = {
    id?: string
    tierName: string
    discountPercentage: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type CustomerPricingTierCreateOrConnectWithoutCustomerInput = {
    where: CustomerPricingTierWhereUniqueInput
    create: XOR<CustomerPricingTierCreateWithoutCustomerInput, CustomerPricingTierUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerPricingTierCreateManyCustomerInputEnvelope = {
    data: CustomerPricingTierCreateManyCustomerInput | CustomerPricingTierCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerExternalIdCreateWithoutCustomerInput = {
    id?: string
    externalSystem: string
    externalCustomerId: string
    externalCustomerName?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type CustomerExternalIdUncheckedCreateWithoutCustomerInput = {
    id?: string
    externalSystem: string
    externalCustomerId: string
    externalCustomerName?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type CustomerExternalIdCreateOrConnectWithoutCustomerInput = {
    where: CustomerExternalIdWhereUniqueInput
    create: XOR<CustomerExternalIdCreateWithoutCustomerInput, CustomerExternalIdUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerExternalIdCreateManyCustomerInputEnvelope = {
    data: CustomerExternalIdCreateManyCustomerInput | CustomerExternalIdCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutCustomerInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutCustomerInput = {
    id?: string
    jobNumber: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutCustomerInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput>
  }

  export type JobCreateManyCustomerInputEnvelope = {
    data: JobCreateManyCustomerInput | JobCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CommunityCreateWithoutCustomerInput = {
    id?: string
    name: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: LotCreateNestedManyWithoutCommunityInput
    jobs?: JobCreateNestedManyWithoutCommunityInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutCustomerInput = {
    id?: string
    name: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: LotUncheckedCreateNestedManyWithoutCommunityInput
    jobs?: JobUncheckedCreateNestedManyWithoutCommunityInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutCustomerInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutCustomerInput, CommunityUncheckedCreateWithoutCustomerInput>
  }

  export type CommunityCreateManyCustomerInputEnvelope = {
    data: CommunityCreateManyCustomerInput | CommunityCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPricingCreateWithoutCustomerInput = {
    id?: string
    overridePrice?: Decimal | DecimalJsLike | number | string | null
    overrideMargin?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: Decimal | DecimalJsLike | number | string | null
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutCustomerPricingInput
  }

  export type CustomerPricingUncheckedCreateWithoutCustomerInput = {
    id?: string
    materialId: string
    overridePrice?: Decimal | DecimalJsLike | number | string | null
    overrideMargin?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: Decimal | DecimalJsLike | number | string | null
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPricingCreateOrConnectWithoutCustomerInput = {
    where: CustomerPricingWhereUniqueInput
    create: XOR<CustomerPricingCreateWithoutCustomerInput, CustomerPricingUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerPricingCreateManyCustomerInputEnvelope = {
    data: CustomerPricingCreateManyCustomerInput | CustomerPricingCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type VariancePatternCreateWithoutCustomerInput = {
    id?: string
    scope: $Enums.VarianceScope
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutVariancePatternsInput
    community?: CommunityCreateNestedOneWithoutVariancePatternsInput
    reviews?: VarianceReviewCreateNestedManyWithoutPatternInput
  }

  export type VariancePatternUncheckedCreateWithoutCustomerInput = {
    id?: string
    scope: $Enums.VarianceScope
    planId?: string | null
    communityId?: string | null
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VarianceReviewUncheckedCreateNestedManyWithoutPatternInput
  }

  export type VariancePatternCreateOrConnectWithoutCustomerInput = {
    where: VariancePatternWhereUniqueInput
    create: XOR<VariancePatternCreateWithoutCustomerInput, VariancePatternUncheckedCreateWithoutCustomerInput>
  }

  export type VariancePatternCreateManyCustomerInputEnvelope = {
    data: VariancePatternCreateManyCustomerInput | VariancePatternCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerContactUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerContactWhereUniqueInput
    update: XOR<CustomerContactUpdateWithoutCustomerInput, CustomerContactUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerContactUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerContactWhereUniqueInput
    data: XOR<CustomerContactUpdateWithoutCustomerInput, CustomerContactUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerContactUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerContactScalarWhereInput
    data: XOR<CustomerContactUpdateManyMutationInput, CustomerContactUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerContactScalarWhereInput = {
    AND?: CustomerContactScalarWhereInput | CustomerContactScalarWhereInput[]
    OR?: CustomerContactScalarWhereInput[]
    NOT?: CustomerContactScalarWhereInput | CustomerContactScalarWhereInput[]
    id?: StringFilter<"CustomerContact"> | string
    customerId?: StringFilter<"CustomerContact"> | string
    contactName?: StringFilter<"CustomerContact"> | string
    role?: StringNullableFilter<"CustomerContact"> | string | null
    email?: StringNullableFilter<"CustomerContact"> | string | null
    phone?: StringNullableFilter<"CustomerContact"> | string | null
    receivesNotifications?: BoolFilter<"CustomerContact"> | boolean
    isPrimary?: BoolFilter<"CustomerContact"> | boolean
    createdAt?: DateTimeFilter<"CustomerContact"> | Date | string
  }

  export type CustomerPricingTierUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerPricingTierWhereUniqueInput
    update: XOR<CustomerPricingTierUpdateWithoutCustomerInput, CustomerPricingTierUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerPricingTierCreateWithoutCustomerInput, CustomerPricingTierUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerPricingTierUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerPricingTierWhereUniqueInput
    data: XOR<CustomerPricingTierUpdateWithoutCustomerInput, CustomerPricingTierUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerPricingTierUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerPricingTierScalarWhereInput
    data: XOR<CustomerPricingTierUpdateManyMutationInput, CustomerPricingTierUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerPricingTierScalarWhereInput = {
    AND?: CustomerPricingTierScalarWhereInput | CustomerPricingTierScalarWhereInput[]
    OR?: CustomerPricingTierScalarWhereInput[]
    NOT?: CustomerPricingTierScalarWhereInput | CustomerPricingTierScalarWhereInput[]
    id?: StringFilter<"CustomerPricingTier"> | string
    customerId?: StringFilter<"CustomerPricingTier"> | string
    tierName?: StringFilter<"CustomerPricingTier"> | string
    discountPercentage?: DecimalFilter<"CustomerPricingTier"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFilter<"CustomerPricingTier"> | Date | string
    expirationDate?: DateTimeNullableFilter<"CustomerPricingTier"> | Date | string | null
    createdAt?: DateTimeFilter<"CustomerPricingTier"> | Date | string
  }

  export type CustomerExternalIdUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerExternalIdWhereUniqueInput
    update: XOR<CustomerExternalIdUpdateWithoutCustomerInput, CustomerExternalIdUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerExternalIdCreateWithoutCustomerInput, CustomerExternalIdUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerExternalIdUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerExternalIdWhereUniqueInput
    data: XOR<CustomerExternalIdUpdateWithoutCustomerInput, CustomerExternalIdUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerExternalIdUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerExternalIdScalarWhereInput
    data: XOR<CustomerExternalIdUpdateManyMutationInput, CustomerExternalIdUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerExternalIdScalarWhereInput = {
    AND?: CustomerExternalIdScalarWhereInput | CustomerExternalIdScalarWhereInput[]
    OR?: CustomerExternalIdScalarWhereInput[]
    NOT?: CustomerExternalIdScalarWhereInput | CustomerExternalIdScalarWhereInput[]
    id?: StringFilter<"CustomerExternalId"> | string
    customerId?: StringFilter<"CustomerExternalId"> | string
    externalSystem?: StringFilter<"CustomerExternalId"> | string
    externalCustomerId?: StringFilter<"CustomerExternalId"> | string
    externalCustomerName?: StringNullableFilter<"CustomerExternalId"> | string | null
    isPrimary?: BoolFilter<"CustomerExternalId"> | boolean
    createdAt?: DateTimeFilter<"CustomerExternalId"> | Date | string
  }

  export type JobUpsertWithWhereUniqueWithoutCustomerInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutCustomerInput, JobUncheckedUpdateWithoutCustomerInput>
    create: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput>
  }

  export type JobUpdateWithWhereUniqueWithoutCustomerInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutCustomerInput, JobUncheckedUpdateWithoutCustomerInput>
  }

  export type JobUpdateManyWithWhereWithoutCustomerInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CommunityUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CommunityWhereUniqueInput
    update: XOR<CommunityUpdateWithoutCustomerInput, CommunityUncheckedUpdateWithoutCustomerInput>
    create: XOR<CommunityCreateWithoutCustomerInput, CommunityUncheckedCreateWithoutCustomerInput>
  }

  export type CommunityUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CommunityWhereUniqueInput
    data: XOR<CommunityUpdateWithoutCustomerInput, CommunityUncheckedUpdateWithoutCustomerInput>
  }

  export type CommunityUpdateManyWithWhereWithoutCustomerInput = {
    where: CommunityScalarWhereInput
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CommunityScalarWhereInput = {
    AND?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
    OR?: CommunityScalarWhereInput[]
    NOT?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
    id?: StringFilter<"Community"> | string
    name?: StringFilter<"Community"> | string
    customerId?: StringFilter<"Community"> | string
    shippingYard?: StringFilter<"Community"> | string
    jurisdiction?: StringNullableFilter<"Community"> | string | null
    region?: StringNullableFilter<"Community"> | string | null
    activePlans?: IntFilter<"Community"> | number
    isActive?: BoolFilter<"Community"> | boolean
    specialRequirements?: StringNullableFilter<"Community"> | string | null
    createdAt?: DateTimeFilter<"Community"> | Date | string
    updatedAt?: DateTimeFilter<"Community"> | Date | string
  }

  export type CustomerPricingUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerPricingWhereUniqueInput
    update: XOR<CustomerPricingUpdateWithoutCustomerInput, CustomerPricingUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerPricingCreateWithoutCustomerInput, CustomerPricingUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerPricingUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerPricingWhereUniqueInput
    data: XOR<CustomerPricingUpdateWithoutCustomerInput, CustomerPricingUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerPricingUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerPricingScalarWhereInput
    data: XOR<CustomerPricingUpdateManyMutationInput, CustomerPricingUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerPricingScalarWhereInput = {
    AND?: CustomerPricingScalarWhereInput | CustomerPricingScalarWhereInput[]
    OR?: CustomerPricingScalarWhereInput[]
    NOT?: CustomerPricingScalarWhereInput | CustomerPricingScalarWhereInput[]
    id?: StringFilter<"CustomerPricing"> | string
    customerId?: StringFilter<"CustomerPricing"> | string
    materialId?: StringFilter<"CustomerPricing"> | string
    overridePrice?: DecimalNullableFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: DecimalNullableFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: DecimalNullableFilter<"CustomerPricing"> | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFilter<"CustomerPricing"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CustomerPricing"> | Date | string | null
    notes?: StringNullableFilter<"CustomerPricing"> | string | null
    createdAt?: DateTimeFilter<"CustomerPricing"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPricing"> | Date | string
  }

  export type VariancePatternUpsertWithWhereUniqueWithoutCustomerInput = {
    where: VariancePatternWhereUniqueInput
    update: XOR<VariancePatternUpdateWithoutCustomerInput, VariancePatternUncheckedUpdateWithoutCustomerInput>
    create: XOR<VariancePatternCreateWithoutCustomerInput, VariancePatternUncheckedCreateWithoutCustomerInput>
  }

  export type VariancePatternUpdateWithWhereUniqueWithoutCustomerInput = {
    where: VariancePatternWhereUniqueInput
    data: XOR<VariancePatternUpdateWithoutCustomerInput, VariancePatternUncheckedUpdateWithoutCustomerInput>
  }

  export type VariancePatternUpdateManyWithWhereWithoutCustomerInput = {
    where: VariancePatternScalarWhereInput
    data: XOR<VariancePatternUpdateManyMutationInput, VariancePatternUncheckedUpdateManyWithoutCustomerInput>
  }

  export type VariancePatternScalarWhereInput = {
    AND?: VariancePatternScalarWhereInput | VariancePatternScalarWhereInput[]
    OR?: VariancePatternScalarWhereInput[]
    NOT?: VariancePatternScalarWhereInput | VariancePatternScalarWhereInput[]
    id?: StringFilter<"VariancePattern"> | string
    scope?: EnumVarianceScopeFilter<"VariancePattern"> | $Enums.VarianceScope
    planId?: StringNullableFilter<"VariancePattern"> | string | null
    communityId?: StringNullableFilter<"VariancePattern"> | string | null
    customerId?: StringNullableFilter<"VariancePattern"> | string | null
    region?: StringNullableFilter<"VariancePattern"> | string | null
    materialCategory?: StringFilter<"VariancePattern"> | string
    subcategory?: StringNullableFilter<"VariancePattern"> | string | null
    sampleSize?: IntFilter<"VariancePattern"> | number
    avgVariance?: DecimalFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: DecimalNullableFilter<"VariancePattern"> | Decimal | DecimalJsLike | number | string | null
    reasoning?: StringNullableFilter<"VariancePattern"> | string | null
    status?: EnumPatternStatusFilter<"VariancePattern"> | $Enums.PatternStatus
    reviewedAt?: DateTimeNullableFilter<"VariancePattern"> | Date | string | null
    appliedAt?: DateTimeNullableFilter<"VariancePattern"> | Date | string | null
    createdAt?: DateTimeFilter<"VariancePattern"> | Date | string
    updatedAt?: DateTimeFilter<"VariancePattern"> | Date | string
  }

  export type CustomerCreateWithoutContactsInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingTiers?: CustomerPricingTierCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    communities?: CommunityCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutContactsInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingTiers?: CustomerPricingTierUncheckedCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    communities?: CommunityUncheckedCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutContactsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutContactsInput, CustomerUncheckedCreateWithoutContactsInput>
  }

  export type CustomerUpsertWithoutContactsInput = {
    update: XOR<CustomerUpdateWithoutContactsInput, CustomerUncheckedUpdateWithoutContactsInput>
    create: XOR<CustomerCreateWithoutContactsInput, CustomerUncheckedCreateWithoutContactsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutContactsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutContactsInput, CustomerUncheckedUpdateWithoutContactsInput>
  }

  export type CustomerUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingTiers?: CustomerPricingTierUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingTiers?: CustomerPricingTierUncheckedUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUncheckedUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutPricingTiersInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    communities?: CommunityCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPricingTiersInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    communities?: CommunityUncheckedCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPricingTiersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPricingTiersInput, CustomerUncheckedCreateWithoutPricingTiersInput>
  }

  export type CustomerUpsertWithoutPricingTiersInput = {
    update: XOR<CustomerUpdateWithoutPricingTiersInput, CustomerUncheckedUpdateWithoutPricingTiersInput>
    create: XOR<CustomerCreateWithoutPricingTiersInput, CustomerUncheckedCreateWithoutPricingTiersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPricingTiersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPricingTiersInput, CustomerUncheckedUpdateWithoutPricingTiersInput>
  }

  export type CustomerUpdateWithoutPricingTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPricingTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUncheckedUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutExternalIdsInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    communities?: CommunityCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutExternalIdsInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    communities?: CommunityUncheckedCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutExternalIdsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutExternalIdsInput, CustomerUncheckedCreateWithoutExternalIdsInput>
  }

  export type CustomerUpsertWithoutExternalIdsInput = {
    update: XOR<CustomerUpdateWithoutExternalIdsInput, CustomerUncheckedUpdateWithoutExternalIdsInput>
    create: XOR<CustomerCreateWithoutExternalIdsInput, CustomerUncheckedCreateWithoutExternalIdsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutExternalIdsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutExternalIdsInput, CustomerUncheckedUpdateWithoutExternalIdsInput>
  }

  export type CustomerUpdateWithoutExternalIdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutExternalIdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUncheckedUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutCustomerPricingInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    communities?: CommunityCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerPricingInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierUncheckedCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    communities?: CommunityUncheckedCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerPricingInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerPricingInput, CustomerUncheckedCreateWithoutCustomerPricingInput>
  }

  export type MaterialCreateWithoutCustomerPricingInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutMaterialsInput
    pricingHistory?: PricingHistoryCreateNestedManyWithoutMaterialInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutCustomerPricingInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: string | null
    pricingHistory?: PricingHistoryUncheckedCreateNestedManyWithoutMaterialInput
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutCustomerPricingInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutCustomerPricingInput, MaterialUncheckedCreateWithoutCustomerPricingInput>
  }

  export type CustomerUpsertWithoutCustomerPricingInput = {
    update: XOR<CustomerUpdateWithoutCustomerPricingInput, CustomerUncheckedUpdateWithoutCustomerPricingInput>
    create: XOR<CustomerCreateWithoutCustomerPricingInput, CustomerUncheckedCreateWithoutCustomerPricingInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerPricingInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerPricingInput, CustomerUncheckedUpdateWithoutCustomerPricingInput>
  }

  export type CustomerUpdateWithoutCustomerPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUncheckedUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUncheckedUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type MaterialUpsertWithoutCustomerPricingInput = {
    update: XOR<MaterialUpdateWithoutCustomerPricingInput, MaterialUncheckedUpdateWithoutCustomerPricingInput>
    create: XOR<MaterialCreateWithoutCustomerPricingInput, MaterialUncheckedCreateWithoutCustomerPricingInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutCustomerPricingInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutCustomerPricingInput, MaterialUncheckedUpdateWithoutCustomerPricingInput>
  }

  export type MaterialUpdateWithoutCustomerPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutMaterialsNestedInput
    pricingHistory?: PricingHistoryUpdateManyWithoutMaterialNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutCustomerPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingHistory?: PricingHistoryUncheckedUpdateManyWithoutMaterialNestedInput
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type PlanElevationCreateWithoutPlanInput = {
    id?: string
    code: string
    name?: string | null
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobCreateNestedManyWithoutElevationInput
  }

  export type PlanElevationUncheckedCreateWithoutPlanInput = {
    id?: string
    code: string
    name?: string | null
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutElevationInput
  }

  export type PlanElevationCreateOrConnectWithoutPlanInput = {
    where: PlanElevationWhereUniqueInput
    create: XOR<PlanElevationCreateWithoutPlanInput, PlanElevationUncheckedCreateWithoutPlanInput>
  }

  export type PlanElevationCreateManyPlanInputEnvelope = {
    data: PlanElevationCreateManyPlanInput | PlanElevationCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanOptionCreateWithoutPlansInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.OptionCategory
    basePrice: Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionCreatetriggersPacksInput | string[]
    appliesTo?: PlanOptionCreateappliesToInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionCreateNestedManyWithoutOptionInput
  }

  export type PlanOptionUncheckedCreateWithoutPlansInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.OptionCategory
    basePrice: Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionCreatetriggersPacksInput | string[]
    appliesTo?: PlanOptionCreateappliesToInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type PlanOptionCreateOrConnectWithoutPlansInput = {
    where: PlanOptionWhereUniqueInput
    create: XOR<PlanOptionCreateWithoutPlansInput, PlanOptionUncheckedCreateWithoutPlansInput>
  }

  export type PlanTemplateItemCreateWithoutPlanInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    wasteFactor?: Decimal | DecimalJsLike | number | string
    category: string
    subcategory?: string | null
    averageVariance?: Decimal | DecimalJsLike | number | string | null
    varianceCount?: number
    lastVarianceDate?: Date | string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutTemplateItemsInput
  }

  export type PlanTemplateItemUncheckedCreateWithoutPlanInput = {
    id?: string
    materialId: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    wasteFactor?: Decimal | DecimalJsLike | number | string
    category: string
    subcategory?: string | null
    averageVariance?: Decimal | DecimalJsLike | number | string | null
    varianceCount?: number
    lastVarianceDate?: Date | string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanTemplateItemCreateOrConnectWithoutPlanInput = {
    where: PlanTemplateItemWhereUniqueInput
    create: XOR<PlanTemplateItemCreateWithoutPlanInput, PlanTemplateItemUncheckedCreateWithoutPlanInput>
  }

  export type PlanTemplateItemCreateManyPlanInputEnvelope = {
    data: PlanTemplateItemCreateManyPlanInput | PlanTemplateItemCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutPlanInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutPlanInput = {
    id?: string
    jobNumber: string
    customerId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutPlanInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutPlanInput, JobUncheckedCreateWithoutPlanInput>
  }

  export type JobCreateManyPlanInputEnvelope = {
    data: JobCreateManyPlanInput | JobCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type VariancePatternCreateWithoutPlanInput = {
    id?: string
    scope: $Enums.VarianceScope
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    community?: CommunityCreateNestedOneWithoutVariancePatternsInput
    customer?: CustomerCreateNestedOneWithoutVariancePatternsInput
    reviews?: VarianceReviewCreateNestedManyWithoutPatternInput
  }

  export type VariancePatternUncheckedCreateWithoutPlanInput = {
    id?: string
    scope: $Enums.VarianceScope
    communityId?: string | null
    customerId?: string | null
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VarianceReviewUncheckedCreateNestedManyWithoutPatternInput
  }

  export type VariancePatternCreateOrConnectWithoutPlanInput = {
    where: VariancePatternWhereUniqueInput
    create: XOR<VariancePatternCreateWithoutPlanInput, VariancePatternUncheckedCreateWithoutPlanInput>
  }

  export type VariancePatternCreateManyPlanInputEnvelope = {
    data: VariancePatternCreateManyPlanInput | VariancePatternCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanElevationUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanElevationWhereUniqueInput
    update: XOR<PlanElevationUpdateWithoutPlanInput, PlanElevationUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanElevationCreateWithoutPlanInput, PlanElevationUncheckedCreateWithoutPlanInput>
  }

  export type PlanElevationUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanElevationWhereUniqueInput
    data: XOR<PlanElevationUpdateWithoutPlanInput, PlanElevationUncheckedUpdateWithoutPlanInput>
  }

  export type PlanElevationUpdateManyWithWhereWithoutPlanInput = {
    where: PlanElevationScalarWhereInput
    data: XOR<PlanElevationUpdateManyMutationInput, PlanElevationUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanElevationScalarWhereInput = {
    AND?: PlanElevationScalarWhereInput | PlanElevationScalarWhereInput[]
    OR?: PlanElevationScalarWhereInput[]
    NOT?: PlanElevationScalarWhereInput | PlanElevationScalarWhereInput[]
    id?: StringFilter<"PlanElevation"> | string
    planId?: StringFilter<"PlanElevation"> | string
    code?: StringFilter<"PlanElevation"> | string
    name?: StringNullableFilter<"PlanElevation"> | string | null
    description?: StringNullableFilter<"PlanElevation"> | string | null
    imageUrl?: StringNullableFilter<"PlanElevation"> | string | null
    createdAt?: DateTimeFilter<"PlanElevation"> | Date | string
    updatedAt?: DateTimeFilter<"PlanElevation"> | Date | string
  }

  export type PlanOptionUpsertWithWhereUniqueWithoutPlansInput = {
    where: PlanOptionWhereUniqueInput
    update: XOR<PlanOptionUpdateWithoutPlansInput, PlanOptionUncheckedUpdateWithoutPlansInput>
    create: XOR<PlanOptionCreateWithoutPlansInput, PlanOptionUncheckedCreateWithoutPlansInput>
  }

  export type PlanOptionUpdateWithWhereUniqueWithoutPlansInput = {
    where: PlanOptionWhereUniqueInput
    data: XOR<PlanOptionUpdateWithoutPlansInput, PlanOptionUncheckedUpdateWithoutPlansInput>
  }

  export type PlanOptionUpdateManyWithWhereWithoutPlansInput = {
    where: PlanOptionScalarWhereInput
    data: XOR<PlanOptionUpdateManyMutationInput, PlanOptionUncheckedUpdateManyWithoutPlansInput>
  }

  export type PlanOptionScalarWhereInput = {
    AND?: PlanOptionScalarWhereInput | PlanOptionScalarWhereInput[]
    OR?: PlanOptionScalarWhereInput[]
    NOT?: PlanOptionScalarWhereInput | PlanOptionScalarWhereInput[]
    id?: StringFilter<"PlanOption"> | string
    code?: StringFilter<"PlanOption"> | string
    name?: StringFilter<"PlanOption"> | string
    description?: StringNullableFilter<"PlanOption"> | string | null
    category?: EnumOptionCategoryFilter<"PlanOption"> | $Enums.OptionCategory
    basePrice?: DecimalFilter<"PlanOption"> | Decimal | DecimalJsLike | number | string
    triggersPacks?: StringNullableListFilter<"PlanOption">
    appliesTo?: StringNullableListFilter<"PlanOption">
    createdAt?: DateTimeFilter<"PlanOption"> | Date | string
    updatedAt?: DateTimeFilter<"PlanOption"> | Date | string
  }

  export type PlanTemplateItemUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanTemplateItemWhereUniqueInput
    update: XOR<PlanTemplateItemUpdateWithoutPlanInput, PlanTemplateItemUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanTemplateItemCreateWithoutPlanInput, PlanTemplateItemUncheckedCreateWithoutPlanInput>
  }

  export type PlanTemplateItemUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanTemplateItemWhereUniqueInput
    data: XOR<PlanTemplateItemUpdateWithoutPlanInput, PlanTemplateItemUncheckedUpdateWithoutPlanInput>
  }

  export type PlanTemplateItemUpdateManyWithWhereWithoutPlanInput = {
    where: PlanTemplateItemScalarWhereInput
    data: XOR<PlanTemplateItemUpdateManyMutationInput, PlanTemplateItemUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanTemplateItemScalarWhereInput = {
    AND?: PlanTemplateItemScalarWhereInput | PlanTemplateItemScalarWhereInput[]
    OR?: PlanTemplateItemScalarWhereInput[]
    NOT?: PlanTemplateItemScalarWhereInput | PlanTemplateItemScalarWhereInput[]
    id?: StringFilter<"PlanTemplateItem"> | string
    planId?: StringFilter<"PlanTemplateItem"> | string
    materialId?: StringFilter<"PlanTemplateItem"> | string
    quantity?: DecimalFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"PlanTemplateItem"> | string
    wasteFactor?: DecimalFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"PlanTemplateItem"> | string
    subcategory?: StringNullableFilter<"PlanTemplateItem"> | string | null
    averageVariance?: DecimalNullableFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFilter<"PlanTemplateItem"> | number
    lastVarianceDate?: DateTimeNullableFilter<"PlanTemplateItem"> | Date | string | null
    confidenceScore?: DecimalNullableFilter<"PlanTemplateItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"PlanTemplateItem"> | string | null
    createdAt?: DateTimeFilter<"PlanTemplateItem"> | Date | string
    updatedAt?: DateTimeFilter<"PlanTemplateItem"> | Date | string
  }

  export type JobUpsertWithWhereUniqueWithoutPlanInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutPlanInput, JobUncheckedUpdateWithoutPlanInput>
    create: XOR<JobCreateWithoutPlanInput, JobUncheckedCreateWithoutPlanInput>
  }

  export type JobUpdateWithWhereUniqueWithoutPlanInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutPlanInput, JobUncheckedUpdateWithoutPlanInput>
  }

  export type JobUpdateManyWithWhereWithoutPlanInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutPlanInput>
  }

  export type VariancePatternUpsertWithWhereUniqueWithoutPlanInput = {
    where: VariancePatternWhereUniqueInput
    update: XOR<VariancePatternUpdateWithoutPlanInput, VariancePatternUncheckedUpdateWithoutPlanInput>
    create: XOR<VariancePatternCreateWithoutPlanInput, VariancePatternUncheckedCreateWithoutPlanInput>
  }

  export type VariancePatternUpdateWithWhereUniqueWithoutPlanInput = {
    where: VariancePatternWhereUniqueInput
    data: XOR<VariancePatternUpdateWithoutPlanInput, VariancePatternUncheckedUpdateWithoutPlanInput>
  }

  export type VariancePatternUpdateManyWithWhereWithoutPlanInput = {
    where: VariancePatternScalarWhereInput
    data: XOR<VariancePatternUpdateManyMutationInput, VariancePatternUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanCreateWithoutElevationsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: PlanOptionCreateNestedManyWithoutPlansInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutPlanInput
    jobs?: JobCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutElevationsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: PlanOptionUncheckedCreateNestedManyWithoutPlansInput
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutPlanInput
    jobs?: JobUncheckedCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutElevationsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutElevationsInput, PlanUncheckedCreateWithoutElevationsInput>
  }

  export type JobCreateWithoutElevationInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    plan: PlanCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutElevationInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutElevationInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutElevationInput, JobUncheckedCreateWithoutElevationInput>
  }

  export type JobCreateManyElevationInputEnvelope = {
    data: JobCreateManyElevationInput | JobCreateManyElevationInput[]
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithoutElevationsInput = {
    update: XOR<PlanUpdateWithoutElevationsInput, PlanUncheckedUpdateWithoutElevationsInput>
    create: XOR<PlanCreateWithoutElevationsInput, PlanUncheckedCreateWithoutElevationsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutElevationsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutElevationsInput, PlanUncheckedUpdateWithoutElevationsInput>
  }

  export type PlanUpdateWithoutElevationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: PlanOptionUpdateManyWithoutPlansNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutPlanNestedInput
    jobs?: JobUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutElevationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: PlanOptionUncheckedUpdateManyWithoutPlansNestedInput
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutPlanNestedInput
    jobs?: JobUncheckedUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type JobUpsertWithWhereUniqueWithoutElevationInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutElevationInput, JobUncheckedUpdateWithoutElevationInput>
    create: XOR<JobCreateWithoutElevationInput, JobUncheckedCreateWithoutElevationInput>
  }

  export type JobUpdateWithWhereUniqueWithoutElevationInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutElevationInput, JobUncheckedUpdateWithoutElevationInput>
  }

  export type JobUpdateManyWithWhereWithoutElevationInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutElevationInput>
  }

  export type PlanCreateWithoutOptionsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationCreateNestedManyWithoutPlanInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutPlanInput
    jobs?: JobCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutOptionsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationUncheckedCreateNestedManyWithoutPlanInput
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutPlanInput
    jobs?: JobUncheckedCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutOptionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutOptionsInput, PlanUncheckedCreateWithoutOptionsInput>
  }

  export type JobOptionCreateWithoutOptionInput = {
    id?: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutJobOptionsInput
  }

  export type JobOptionUncheckedCreateWithoutOptionInput = {
    id?: string
    jobId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type JobOptionCreateOrConnectWithoutOptionInput = {
    where: JobOptionWhereUniqueInput
    create: XOR<JobOptionCreateWithoutOptionInput, JobOptionUncheckedCreateWithoutOptionInput>
  }

  export type JobOptionCreateManyOptionInputEnvelope = {
    data: JobOptionCreateManyOptionInput | JobOptionCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithWhereUniqueWithoutOptionsInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutOptionsInput, PlanUncheckedUpdateWithoutOptionsInput>
    create: XOR<PlanCreateWithoutOptionsInput, PlanUncheckedCreateWithoutOptionsInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutOptionsInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutOptionsInput, PlanUncheckedUpdateWithoutOptionsInput>
  }

  export type PlanUpdateManyWithWhereWithoutOptionsInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutOptionsInput>
  }

  export type PlanScalarWhereInput = {
    AND?: PlanScalarWhereInput | PlanScalarWhereInput[]
    OR?: PlanScalarWhereInput[]
    NOT?: PlanScalarWhereInput | PlanScalarWhereInput[]
    id?: StringFilter<"Plan"> | string
    code?: StringFilter<"Plan"> | string
    name?: StringNullableFilter<"Plan"> | string | null
    type?: EnumPlanTypeFilter<"Plan"> | $Enums.PlanType
    sqft?: IntNullableFilter<"Plan"> | number | null
    bedrooms?: IntNullableFilter<"Plan"> | number | null
    bathrooms?: DecimalNullableFilter<"Plan"> | Decimal | DecimalJsLike | number | string | null
    garage?: StringNullableFilter<"Plan"> | string | null
    style?: StringNullableFilter<"Plan"> | string | null
    version?: IntFilter<"Plan"> | number
    isActive?: BoolFilter<"Plan"> | boolean
    pdssUrl?: StringNullableFilter<"Plan"> | string | null
    notes?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
  }

  export type JobOptionUpsertWithWhereUniqueWithoutOptionInput = {
    where: JobOptionWhereUniqueInput
    update: XOR<JobOptionUpdateWithoutOptionInput, JobOptionUncheckedUpdateWithoutOptionInput>
    create: XOR<JobOptionCreateWithoutOptionInput, JobOptionUncheckedCreateWithoutOptionInput>
  }

  export type JobOptionUpdateWithWhereUniqueWithoutOptionInput = {
    where: JobOptionWhereUniqueInput
    data: XOR<JobOptionUpdateWithoutOptionInput, JobOptionUncheckedUpdateWithoutOptionInput>
  }

  export type JobOptionUpdateManyWithWhereWithoutOptionInput = {
    where: JobOptionScalarWhereInput
    data: XOR<JobOptionUpdateManyMutationInput, JobOptionUncheckedUpdateManyWithoutOptionInput>
  }

  export type JobOptionScalarWhereInput = {
    AND?: JobOptionScalarWhereInput | JobOptionScalarWhereInput[]
    OR?: JobOptionScalarWhereInput[]
    NOT?: JobOptionScalarWhereInput | JobOptionScalarWhereInput[]
    id?: StringFilter<"JobOption"> | string
    jobId?: StringFilter<"JobOption"> | string
    optionId?: StringFilter<"JobOption"> | string
    quantity?: IntFilter<"JobOption"> | number
    price?: DecimalFilter<"JobOption"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"JobOption"> | Date | string
  }

  export type PlanCreateWithoutTemplateItemsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationCreateNestedManyWithoutPlanInput
    options?: PlanOptionCreateNestedManyWithoutPlansInput
    jobs?: JobCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutTemplateItemsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationUncheckedCreateNestedManyWithoutPlanInput
    options?: PlanOptionUncheckedCreateNestedManyWithoutPlansInput
    jobs?: JobUncheckedCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutTemplateItemsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutTemplateItemsInput, PlanUncheckedCreateWithoutTemplateItemsInput>
  }

  export type MaterialCreateWithoutTemplateItemsInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutMaterialsInput
    pricingHistory?: PricingHistoryCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutTemplateItemsInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: string | null
    pricingHistory?: PricingHistoryUncheckedCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutTemplateItemsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutTemplateItemsInput, MaterialUncheckedCreateWithoutTemplateItemsInput>
  }

  export type PlanUpsertWithoutTemplateItemsInput = {
    update: XOR<PlanUpdateWithoutTemplateItemsInput, PlanUncheckedUpdateWithoutTemplateItemsInput>
    create: XOR<PlanCreateWithoutTemplateItemsInput, PlanUncheckedCreateWithoutTemplateItemsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutTemplateItemsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutTemplateItemsInput, PlanUncheckedUpdateWithoutTemplateItemsInput>
  }

  export type PlanUpdateWithoutTemplateItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUpdateManyWithoutPlanNestedInput
    options?: PlanOptionUpdateManyWithoutPlansNestedInput
    jobs?: JobUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutTemplateItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUncheckedUpdateManyWithoutPlanNestedInput
    options?: PlanOptionUncheckedUpdateManyWithoutPlansNestedInput
    jobs?: JobUncheckedUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type MaterialUpsertWithoutTemplateItemsInput = {
    update: XOR<MaterialUpdateWithoutTemplateItemsInput, MaterialUncheckedUpdateWithoutTemplateItemsInput>
    create: XOR<MaterialCreateWithoutTemplateItemsInput, MaterialUncheckedCreateWithoutTemplateItemsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutTemplateItemsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutTemplateItemsInput, MaterialUncheckedUpdateWithoutTemplateItemsInput>
  }

  export type MaterialUpdateWithoutTemplateItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutMaterialsNestedInput
    pricingHistory?: PricingHistoryUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutTemplateItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingHistory?: PricingHistoryUncheckedUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type VendorCreateWithoutMaterialsInput = {
    id?: string
    name: string
    code: string
    primaryContact?: string | null
    email?: string | null
    phone?: string | null
    paymentTerms?: string | null
    leadTimeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutMaterialsInput = {
    id?: string
    name: string
    code: string
    primaryContact?: string | null
    email?: string | null
    phone?: string | null
    paymentTerms?: string | null
    leadTimeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutMaterialsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutMaterialsInput, VendorUncheckedCreateWithoutMaterialsInput>
  }

  export type PricingHistoryCreateWithoutMaterialInput = {
    id?: string
    baseVendorCost: Decimal | DecimalJsLike | number | string
    commodityAdjustment?: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginPercentage: Decimal | DecimalJsLike | number | string
    marginAmount: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    calculationSteps: JsonNullValueInput | InputJsonValue
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PricingHistoryUncheckedCreateWithoutMaterialInput = {
    id?: string
    baseVendorCost: Decimal | DecimalJsLike | number | string
    commodityAdjustment?: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginPercentage: Decimal | DecimalJsLike | number | string
    marginAmount: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    calculationSteps: JsonNullValueInput | InputJsonValue
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PricingHistoryCreateOrConnectWithoutMaterialInput = {
    where: PricingHistoryWhereUniqueInput
    create: XOR<PricingHistoryCreateWithoutMaterialInput, PricingHistoryUncheckedCreateWithoutMaterialInput>
  }

  export type PricingHistoryCreateManyMaterialInputEnvelope = {
    data: PricingHistoryCreateManyMaterialInput | PricingHistoryCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type PlanTemplateItemCreateWithoutMaterialInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    wasteFactor?: Decimal | DecimalJsLike | number | string
    category: string
    subcategory?: string | null
    averageVariance?: Decimal | DecimalJsLike | number | string | null
    varianceCount?: number
    lastVarianceDate?: Date | string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutTemplateItemsInput
  }

  export type PlanTemplateItemUncheckedCreateWithoutMaterialInput = {
    id?: string
    planId: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    wasteFactor?: Decimal | DecimalJsLike | number | string
    category: string
    subcategory?: string | null
    averageVariance?: Decimal | DecimalJsLike | number | string | null
    varianceCount?: number
    lastVarianceDate?: Date | string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanTemplateItemCreateOrConnectWithoutMaterialInput = {
    where: PlanTemplateItemWhereUniqueInput
    create: XOR<PlanTemplateItemCreateWithoutMaterialInput, PlanTemplateItemUncheckedCreateWithoutMaterialInput>
  }

  export type PlanTemplateItemCreateManyMaterialInputEnvelope = {
    data: PlanTemplateItemCreateManyMaterialInput | PlanTemplateItemCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPricingCreateWithoutMaterialInput = {
    id?: string
    overridePrice?: Decimal | DecimalJsLike | number | string | null
    overrideMargin?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: Decimal | DecimalJsLike | number | string | null
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerPricingInput
  }

  export type CustomerPricingUncheckedCreateWithoutMaterialInput = {
    id?: string
    customerId: string
    overridePrice?: Decimal | DecimalJsLike | number | string | null
    overrideMargin?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: Decimal | DecimalJsLike | number | string | null
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPricingCreateOrConnectWithoutMaterialInput = {
    where: CustomerPricingWhereUniqueInput
    create: XOR<CustomerPricingCreateWithoutMaterialInput, CustomerPricingUncheckedCreateWithoutMaterialInput>
  }

  export type CustomerPricingCreateManyMaterialInputEnvelope = {
    data: CustomerPricingCreateManyMaterialInput | CustomerPricingCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type TakeoffLineItemCreateWithoutMaterialInput = {
    id?: string
    quantityEstimated: Decimal | DecimalJsLike | number | string
    quantityActual?: Decimal | DecimalJsLike | number | string | null
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    variancePercent?: Decimal | DecimalJsLike | number | string | null
    varianceReason?: string | null
    category: string
    subcategory?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    takeoff: TakeoffCreateNestedOneWithoutLineItemsInput
  }

  export type TakeoffLineItemUncheckedCreateWithoutMaterialInput = {
    id?: string
    takeoffId: string
    quantityEstimated: Decimal | DecimalJsLike | number | string
    quantityActual?: Decimal | DecimalJsLike | number | string | null
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    variancePercent?: Decimal | DecimalJsLike | number | string | null
    varianceReason?: string | null
    category: string
    subcategory?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakeoffLineItemCreateOrConnectWithoutMaterialInput = {
    where: TakeoffLineItemWhereUniqueInput
    create: XOR<TakeoffLineItemCreateWithoutMaterialInput, TakeoffLineItemUncheckedCreateWithoutMaterialInput>
  }

  export type TakeoffLineItemCreateManyMaterialInputEnvelope = {
    data: TakeoffLineItemCreateManyMaterialInput | TakeoffLineItemCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutMaterialsInput = {
    update: XOR<VendorUpdateWithoutMaterialsInput, VendorUncheckedUpdateWithoutMaterialsInput>
    create: XOR<VendorCreateWithoutMaterialsInput, VendorUncheckedCreateWithoutMaterialsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutMaterialsInput, VendorUncheckedUpdateWithoutMaterialsInput>
  }

  export type VendorUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    primaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    primaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type PricingHistoryUpsertWithWhereUniqueWithoutMaterialInput = {
    where: PricingHistoryWhereUniqueInput
    update: XOR<PricingHistoryUpdateWithoutMaterialInput, PricingHistoryUncheckedUpdateWithoutMaterialInput>
    create: XOR<PricingHistoryCreateWithoutMaterialInput, PricingHistoryUncheckedCreateWithoutMaterialInput>
  }

  export type PricingHistoryUpdateWithWhereUniqueWithoutMaterialInput = {
    where: PricingHistoryWhereUniqueInput
    data: XOR<PricingHistoryUpdateWithoutMaterialInput, PricingHistoryUncheckedUpdateWithoutMaterialInput>
  }

  export type PricingHistoryUpdateManyWithWhereWithoutMaterialInput = {
    where: PricingHistoryScalarWhereInput
    data: XOR<PricingHistoryUpdateManyMutationInput, PricingHistoryUncheckedUpdateManyWithoutMaterialInput>
  }

  export type PricingHistoryScalarWhereInput = {
    AND?: PricingHistoryScalarWhereInput | PricingHistoryScalarWhereInput[]
    OR?: PricingHistoryScalarWhereInput[]
    NOT?: PricingHistoryScalarWhereInput | PricingHistoryScalarWhereInput[]
    id?: StringFilter<"PricingHistory"> | string
    materialId?: StringFilter<"PricingHistory"> | string
    baseVendorCost?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    freight?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PricingHistory"> | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonFilter<"PricingHistory">
    effectiveDate?: DateTimeFilter<"PricingHistory"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PricingHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"PricingHistory"> | Date | string
  }

  export type PlanTemplateItemUpsertWithWhereUniqueWithoutMaterialInput = {
    where: PlanTemplateItemWhereUniqueInput
    update: XOR<PlanTemplateItemUpdateWithoutMaterialInput, PlanTemplateItemUncheckedUpdateWithoutMaterialInput>
    create: XOR<PlanTemplateItemCreateWithoutMaterialInput, PlanTemplateItemUncheckedCreateWithoutMaterialInput>
  }

  export type PlanTemplateItemUpdateWithWhereUniqueWithoutMaterialInput = {
    where: PlanTemplateItemWhereUniqueInput
    data: XOR<PlanTemplateItemUpdateWithoutMaterialInput, PlanTemplateItemUncheckedUpdateWithoutMaterialInput>
  }

  export type PlanTemplateItemUpdateManyWithWhereWithoutMaterialInput = {
    where: PlanTemplateItemScalarWhereInput
    data: XOR<PlanTemplateItemUpdateManyMutationInput, PlanTemplateItemUncheckedUpdateManyWithoutMaterialInput>
  }

  export type CustomerPricingUpsertWithWhereUniqueWithoutMaterialInput = {
    where: CustomerPricingWhereUniqueInput
    update: XOR<CustomerPricingUpdateWithoutMaterialInput, CustomerPricingUncheckedUpdateWithoutMaterialInput>
    create: XOR<CustomerPricingCreateWithoutMaterialInput, CustomerPricingUncheckedCreateWithoutMaterialInput>
  }

  export type CustomerPricingUpdateWithWhereUniqueWithoutMaterialInput = {
    where: CustomerPricingWhereUniqueInput
    data: XOR<CustomerPricingUpdateWithoutMaterialInput, CustomerPricingUncheckedUpdateWithoutMaterialInput>
  }

  export type CustomerPricingUpdateManyWithWhereWithoutMaterialInput = {
    where: CustomerPricingScalarWhereInput
    data: XOR<CustomerPricingUpdateManyMutationInput, CustomerPricingUncheckedUpdateManyWithoutMaterialInput>
  }

  export type TakeoffLineItemUpsertWithWhereUniqueWithoutMaterialInput = {
    where: TakeoffLineItemWhereUniqueInput
    update: XOR<TakeoffLineItemUpdateWithoutMaterialInput, TakeoffLineItemUncheckedUpdateWithoutMaterialInput>
    create: XOR<TakeoffLineItemCreateWithoutMaterialInput, TakeoffLineItemUncheckedCreateWithoutMaterialInput>
  }

  export type TakeoffLineItemUpdateWithWhereUniqueWithoutMaterialInput = {
    where: TakeoffLineItemWhereUniqueInput
    data: XOR<TakeoffLineItemUpdateWithoutMaterialInput, TakeoffLineItemUncheckedUpdateWithoutMaterialInput>
  }

  export type TakeoffLineItemUpdateManyWithWhereWithoutMaterialInput = {
    where: TakeoffLineItemScalarWhereInput
    data: XOR<TakeoffLineItemUpdateManyMutationInput, TakeoffLineItemUncheckedUpdateManyWithoutMaterialInput>
  }

  export type TakeoffLineItemScalarWhereInput = {
    AND?: TakeoffLineItemScalarWhereInput | TakeoffLineItemScalarWhereInput[]
    OR?: TakeoffLineItemScalarWhereInput[]
    NOT?: TakeoffLineItemScalarWhereInput | TakeoffLineItemScalarWhereInput[]
    id?: StringFilter<"TakeoffLineItem"> | string
    takeoffId?: StringFilter<"TakeoffLineItem"> | string
    materialId?: StringFilter<"TakeoffLineItem"> | string
    quantityEstimated?: DecimalFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    quantityActual?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"TakeoffLineItem"> | string
    unitPrice?: DecimalFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string
    totalActual?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    variancePercent?: DecimalNullableFilter<"TakeoffLineItem"> | Decimal | DecimalJsLike | number | string | null
    varianceReason?: StringNullableFilter<"TakeoffLineItem"> | string | null
    category?: StringFilter<"TakeoffLineItem"> | string
    subcategory?: StringNullableFilter<"TakeoffLineItem"> | string | null
    notes?: StringNullableFilter<"TakeoffLineItem"> | string | null
    createdAt?: DateTimeFilter<"TakeoffLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"TakeoffLineItem"> | Date | string
  }

  export type MaterialCreateWithoutVendorInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingHistory?: PricingHistoryCreateNestedManyWithoutMaterialInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutVendorInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingHistory?: PricingHistoryUncheckedCreateNestedManyWithoutMaterialInput
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutVendorInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutVendorInput, MaterialUncheckedCreateWithoutVendorInput>
  }

  export type MaterialCreateManyVendorInputEnvelope = {
    data: MaterialCreateManyVendorInput | MaterialCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutVendorInput = {
    id?: string
    poNumber: string
    status?: $Enums.POStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    approvedAt?: Date | string | null
    sentAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    scheduledDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    deliveryNotes?: string | null
    hyphenBuildProId?: string | null
    holtPortalId?: string | null
    signatureUrl?: string | null
    photoUrls?: PurchaseOrderCreatephotoUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutVendorInput = {
    id?: string
    poNumber: string
    jobId: string
    status?: $Enums.POStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    approvedAt?: Date | string | null
    sentAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    scheduledDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    deliveryNotes?: string | null
    hyphenBuildProId?: string | null
    holtPortalId?: string | null
    signatureUrl?: string | null
    photoUrls?: PurchaseOrderCreatephotoUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseOrderCreateManyVendorInputEnvelope = {
    data: PurchaseOrderCreateManyVendorInput | PurchaseOrderCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type MaterialUpsertWithWhereUniqueWithoutVendorInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutVendorInput, MaterialUncheckedUpdateWithoutVendorInput>
    create: XOR<MaterialCreateWithoutVendorInput, MaterialUncheckedCreateWithoutVendorInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutVendorInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutVendorInput, MaterialUncheckedUpdateWithoutVendorInput>
  }

  export type MaterialUpdateManyWithWhereWithoutVendorInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutVendorInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: StringFilter<"Material"> | string
    sku?: StringFilter<"Material"> | string
    description?: StringFilter<"Material"> | string
    category?: EnumMaterialCategoryFilter<"Material"> | $Enums.MaterialCategory
    subcategory?: StringNullableFilter<"Material"> | string | null
    unitOfMeasure?: StringFilter<"Material"> | string
    vendorCost?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    freight?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFilter<"Material"> | boolean
    rlTag?: StringNullableFilter<"Material"> | string | null
    rlBasePrice?: DecimalNullableFilter<"Material"> | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: DateTimeNullableFilter<"Material"> | Date | string | null
    lengthAdders?: JsonNullableFilter<"Material">
    gradeMultipliers?: JsonNullableFilter<"Material">
    isActive?: BoolFilter<"Material"> | boolean
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    vendorId?: StringNullableFilter<"Material"> | string | null
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutVendorInput, PurchaseOrderUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutVendorInput, PurchaseOrderUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutVendorInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    poNumber?: StringFilter<"PurchaseOrder"> | string
    jobId?: StringFilter<"PurchaseOrder"> | string
    vendorId?: StringNullableFilter<"PurchaseOrder"> | string | null
    status?: EnumPOStatusFilter<"PurchaseOrder"> | $Enums.POStatus
    totalAmount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    approvedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    scheduledDelivery?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    actualDelivery?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    deliveryNotes?: StringNullableFilter<"PurchaseOrder"> | string | null
    hyphenBuildProId?: StringNullableFilter<"PurchaseOrder"> | string | null
    holtPortalId?: StringNullableFilter<"PurchaseOrder"> | string | null
    signatureUrl?: StringNullableFilter<"PurchaseOrder"> | string | null
    photoUrls?: StringNullableListFilter<"PurchaseOrder">
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type MaterialCreateWithoutPricingHistoryInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutMaterialsInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutPricingHistoryInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: string | null
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutMaterialInput
    takeoffLineItems?: TakeoffLineItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutPricingHistoryInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutPricingHistoryInput, MaterialUncheckedCreateWithoutPricingHistoryInput>
  }

  export type MaterialUpsertWithoutPricingHistoryInput = {
    update: XOR<MaterialUpdateWithoutPricingHistoryInput, MaterialUncheckedUpdateWithoutPricingHistoryInput>
    create: XOR<MaterialCreateWithoutPricingHistoryInput, MaterialUncheckedCreateWithoutPricingHistoryInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutPricingHistoryInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutPricingHistoryInput, MaterialUncheckedUpdateWithoutPricingHistoryInput>
  }

  export type MaterialUpdateWithoutPricingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutMaterialsNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutPricingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type CustomerCreateWithoutCommunitiesInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCommunitiesInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierUncheckedCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCommunitiesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCommunitiesInput, CustomerUncheckedCreateWithoutCommunitiesInput>
  }

  export type LotCreateWithoutCommunityInput = {
    id?: string
    lotNumber: string
    status?: $Enums.LotStatus
    sqft?: number | null
    frontage?: Decimal | DecimalJsLike | number | string | null
    depth?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobCreateNestedManyWithoutLotInput
  }

  export type LotUncheckedCreateWithoutCommunityInput = {
    id?: string
    lotNumber: string
    status?: $Enums.LotStatus
    sqft?: number | null
    frontage?: Decimal | DecimalJsLike | number | string | null
    depth?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutLotInput
  }

  export type LotCreateOrConnectWithoutCommunityInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutCommunityInput, LotUncheckedCreateWithoutCommunityInput>
  }

  export type LotCreateManyCommunityInputEnvelope = {
    data: LotCreateManyCommunityInput | LotCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutCommunityInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    plan: PlanCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutCommunityInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutCommunityInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutCommunityInput, JobUncheckedCreateWithoutCommunityInput>
  }

  export type JobCreateManyCommunityInputEnvelope = {
    data: JobCreateManyCommunityInput | JobCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type VariancePatternCreateWithoutCommunityInput = {
    id?: string
    scope: $Enums.VarianceScope
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutVariancePatternsInput
    customer?: CustomerCreateNestedOneWithoutVariancePatternsInput
    reviews?: VarianceReviewCreateNestedManyWithoutPatternInput
  }

  export type VariancePatternUncheckedCreateWithoutCommunityInput = {
    id?: string
    scope: $Enums.VarianceScope
    planId?: string | null
    customerId?: string | null
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VarianceReviewUncheckedCreateNestedManyWithoutPatternInput
  }

  export type VariancePatternCreateOrConnectWithoutCommunityInput = {
    where: VariancePatternWhereUniqueInput
    create: XOR<VariancePatternCreateWithoutCommunityInput, VariancePatternUncheckedCreateWithoutCommunityInput>
  }

  export type VariancePatternCreateManyCommunityInputEnvelope = {
    data: VariancePatternCreateManyCommunityInput | VariancePatternCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutCommunitiesInput = {
    update: XOR<CustomerUpdateWithoutCommunitiesInput, CustomerUncheckedUpdateWithoutCommunitiesInput>
    create: XOR<CustomerCreateWithoutCommunitiesInput, CustomerUncheckedCreateWithoutCommunitiesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCommunitiesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCommunitiesInput, CustomerUncheckedUpdateWithoutCommunitiesInput>
  }

  export type CustomerUpdateWithoutCommunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCommunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUncheckedUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LotUpsertWithWhereUniqueWithoutCommunityInput = {
    where: LotWhereUniqueInput
    update: XOR<LotUpdateWithoutCommunityInput, LotUncheckedUpdateWithoutCommunityInput>
    create: XOR<LotCreateWithoutCommunityInput, LotUncheckedCreateWithoutCommunityInput>
  }

  export type LotUpdateWithWhereUniqueWithoutCommunityInput = {
    where: LotWhereUniqueInput
    data: XOR<LotUpdateWithoutCommunityInput, LotUncheckedUpdateWithoutCommunityInput>
  }

  export type LotUpdateManyWithWhereWithoutCommunityInput = {
    where: LotScalarWhereInput
    data: XOR<LotUpdateManyMutationInput, LotUncheckedUpdateManyWithoutCommunityInput>
  }

  export type LotScalarWhereInput = {
    AND?: LotScalarWhereInput | LotScalarWhereInput[]
    OR?: LotScalarWhereInput[]
    NOT?: LotScalarWhereInput | LotScalarWhereInput[]
    id?: StringFilter<"Lot"> | string
    communityId?: StringFilter<"Lot"> | string
    lotNumber?: StringFilter<"Lot"> | string
    status?: EnumLotStatusFilter<"Lot"> | $Enums.LotStatus
    sqft?: IntNullableFilter<"Lot"> | number | null
    frontage?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    depth?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Lot"> | string | null
    createdAt?: DateTimeFilter<"Lot"> | Date | string
    updatedAt?: DateTimeFilter<"Lot"> | Date | string
  }

  export type JobUpsertWithWhereUniqueWithoutCommunityInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutCommunityInput, JobUncheckedUpdateWithoutCommunityInput>
    create: XOR<JobCreateWithoutCommunityInput, JobUncheckedCreateWithoutCommunityInput>
  }

  export type JobUpdateWithWhereUniqueWithoutCommunityInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutCommunityInput, JobUncheckedUpdateWithoutCommunityInput>
  }

  export type JobUpdateManyWithWhereWithoutCommunityInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutCommunityInput>
  }

  export type VariancePatternUpsertWithWhereUniqueWithoutCommunityInput = {
    where: VariancePatternWhereUniqueInput
    update: XOR<VariancePatternUpdateWithoutCommunityInput, VariancePatternUncheckedUpdateWithoutCommunityInput>
    create: XOR<VariancePatternCreateWithoutCommunityInput, VariancePatternUncheckedCreateWithoutCommunityInput>
  }

  export type VariancePatternUpdateWithWhereUniqueWithoutCommunityInput = {
    where: VariancePatternWhereUniqueInput
    data: XOR<VariancePatternUpdateWithoutCommunityInput, VariancePatternUncheckedUpdateWithoutCommunityInput>
  }

  export type VariancePatternUpdateManyWithWhereWithoutCommunityInput = {
    where: VariancePatternScalarWhereInput
    data: XOR<VariancePatternUpdateManyMutationInput, VariancePatternUncheckedUpdateManyWithoutCommunityInput>
  }

  export type CommunityCreateWithoutLotsInput = {
    id?: string
    name: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCommunitiesInput
    jobs?: JobCreateNestedManyWithoutCommunityInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutLotsInput = {
    id?: string
    name: string
    customerId: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutCommunityInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutLotsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutLotsInput, CommunityUncheckedCreateWithoutLotsInput>
  }

  export type JobCreateWithoutLotInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    plan: PlanCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutLotInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutLotInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutLotInput, JobUncheckedCreateWithoutLotInput>
  }

  export type JobCreateManyLotInputEnvelope = {
    data: JobCreateManyLotInput | JobCreateManyLotInput[]
    skipDuplicates?: boolean
  }

  export type CommunityUpsertWithoutLotsInput = {
    update: XOR<CommunityUpdateWithoutLotsInput, CommunityUncheckedUpdateWithoutLotsInput>
    create: XOR<CommunityCreateWithoutLotsInput, CommunityUncheckedCreateWithoutLotsInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutLotsInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutLotsInput, CommunityUncheckedUpdateWithoutLotsInput>
  }

  export type CommunityUpdateWithoutLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCommunitiesNestedInput
    jobs?: JobUpdateManyWithoutCommunityNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutCommunityNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type JobUpsertWithWhereUniqueWithoutLotInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutLotInput, JobUncheckedUpdateWithoutLotInput>
    create: XOR<JobCreateWithoutLotInput, JobUncheckedCreateWithoutLotInput>
  }

  export type JobUpdateWithWhereUniqueWithoutLotInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutLotInput, JobUncheckedUpdateWithoutLotInput>
  }

  export type JobUpdateManyWithWhereWithoutLotInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutLotInput>
  }

  export type CustomerCreateWithoutJobsInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdCreateNestedManyWithoutCustomerInput
    communities?: CommunityCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutJobsInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierUncheckedCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdUncheckedCreateNestedManyWithoutCustomerInput
    communities?: CommunityUncheckedCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutCustomerInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutJobsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
  }

  export type PlanCreateWithoutJobsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationCreateNestedManyWithoutPlanInput
    options?: PlanOptionCreateNestedManyWithoutPlansInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutJobsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationUncheckedCreateNestedManyWithoutPlanInput
    options?: PlanOptionUncheckedCreateNestedManyWithoutPlansInput
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutPlanInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutJobsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutJobsInput, PlanUncheckedCreateWithoutJobsInput>
  }

  export type PlanElevationCreateWithoutJobsInput = {
    id?: string
    code: string
    name?: string | null
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutElevationsInput
  }

  export type PlanElevationUncheckedCreateWithoutJobsInput = {
    id?: string
    planId: string
    code: string
    name?: string | null
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanElevationCreateOrConnectWithoutJobsInput = {
    where: PlanElevationWhereUniqueInput
    create: XOR<PlanElevationCreateWithoutJobsInput, PlanElevationUncheckedCreateWithoutJobsInput>
  }

  export type CommunityCreateWithoutJobsInput = {
    id?: string
    name: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCommunitiesInput
    lots?: LotCreateNestedManyWithoutCommunityInput
    variancePatterns?: VariancePatternCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutJobsInput = {
    id?: string
    name: string
    customerId: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: LotUncheckedCreateNestedManyWithoutCommunityInput
    variancePatterns?: VariancePatternUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutJobsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutJobsInput, CommunityUncheckedCreateWithoutJobsInput>
  }

  export type LotCreateWithoutJobsInput = {
    id?: string
    lotNumber: string
    status?: $Enums.LotStatus
    sqft?: number | null
    frontage?: Decimal | DecimalJsLike | number | string | null
    depth?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutLotsInput
  }

  export type LotUncheckedCreateWithoutJobsInput = {
    id?: string
    communityId: string
    lotNumber: string
    status?: $Enums.LotStatus
    sqft?: number | null
    frontage?: Decimal | DecimalJsLike | number | string | null
    depth?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LotCreateOrConnectWithoutJobsInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutJobsInput, LotUncheckedCreateWithoutJobsInput>
  }

  export type UserCreateWithoutCreatedJobsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedJobs?: JobCreateNestedManyWithoutApprovedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutCreatedJobsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedJobs?: JobUncheckedCreateNestedManyWithoutApprovedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutCreatedJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedJobsInput, UserUncheckedCreateWithoutCreatedJobsInput>
  }

  export type UserCreateWithoutApprovedJobsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutApprovedJobsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutApprovedJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedJobsInput, UserUncheckedCreateWithoutApprovedJobsInput>
  }

  export type JobOptionCreateWithoutJobInput = {
    id?: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    option: PlanOptionCreateNestedOneWithoutJobOptionsInput
  }

  export type JobOptionUncheckedCreateWithoutJobInput = {
    id?: string
    optionId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type JobOptionCreateOrConnectWithoutJobInput = {
    where: JobOptionWhereUniqueInput
    create: XOR<JobOptionCreateWithoutJobInput, JobOptionUncheckedCreateWithoutJobInput>
  }

  export type JobOptionCreateManyJobInputEnvelope = {
    data: JobOptionCreateManyJobInput | JobOptionCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type TakeoffCreateWithoutJobInput = {
    id?: string
    status?: $Enums.TakeoffStatus
    isValidated?: boolean
    validatedAt?: Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: TakeoffLineItemCreateNestedManyWithoutTakeoffInput
    validation?: TakeoffValidationCreateNestedOneWithoutTakeoffInput
  }

  export type TakeoffUncheckedCreateWithoutJobInput = {
    id?: string
    status?: $Enums.TakeoffStatus
    isValidated?: boolean
    validatedAt?: Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: TakeoffLineItemUncheckedCreateNestedManyWithoutTakeoffInput
    validation?: TakeoffValidationUncheckedCreateNestedOneWithoutTakeoffInput
  }

  export type TakeoffCreateOrConnectWithoutJobInput = {
    where: TakeoffWhereUniqueInput
    create: XOR<TakeoffCreateWithoutJobInput, TakeoffUncheckedCreateWithoutJobInput>
  }

  export type PurchaseOrderCreateWithoutJobInput = {
    id?: string
    poNumber: string
    status?: $Enums.POStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    approvedAt?: Date | string | null
    sentAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    scheduledDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    deliveryNotes?: string | null
    hyphenBuildProId?: string | null
    holtPortalId?: string | null
    signatureUrl?: string | null
    photoUrls?: PurchaseOrderCreatephotoUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutJobInput = {
    id?: string
    poNumber: string
    vendorId?: string | null
    status?: $Enums.POStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    approvedAt?: Date | string | null
    sentAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    scheduledDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    deliveryNotes?: string | null
    hyphenBuildProId?: string | null
    holtPortalId?: string | null
    signatureUrl?: string | null
    photoUrls?: PurchaseOrderCreatephotoUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutJobInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutJobInput, PurchaseOrderUncheckedCreateWithoutJobInput>
  }

  export type PurchaseOrderCreateManyJobInputEnvelope = {
    data: PurchaseOrderCreateManyJobInput | PurchaseOrderCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutJobsInput = {
    update: XOR<CustomerUpdateWithoutJobsInput, CustomerUncheckedUpdateWithoutJobsInput>
    create: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutJobsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutJobsInput, CustomerUncheckedUpdateWithoutJobsInput>
  }

  export type CustomerUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUncheckedUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUncheckedUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUncheckedUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutCustomerNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PlanUpsertWithoutJobsInput = {
    update: XOR<PlanUpdateWithoutJobsInput, PlanUncheckedUpdateWithoutJobsInput>
    create: XOR<PlanCreateWithoutJobsInput, PlanUncheckedCreateWithoutJobsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutJobsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutJobsInput, PlanUncheckedUpdateWithoutJobsInput>
  }

  export type PlanUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUpdateManyWithoutPlanNestedInput
    options?: PlanOptionUpdateManyWithoutPlansNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUncheckedUpdateManyWithoutPlanNestedInput
    options?: PlanOptionUncheckedUpdateManyWithoutPlansNestedInput
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanElevationUpsertWithoutJobsInput = {
    update: XOR<PlanElevationUpdateWithoutJobsInput, PlanElevationUncheckedUpdateWithoutJobsInput>
    create: XOR<PlanElevationCreateWithoutJobsInput, PlanElevationUncheckedCreateWithoutJobsInput>
    where?: PlanElevationWhereInput
  }

  export type PlanElevationUpdateToOneWithWhereWithoutJobsInput = {
    where?: PlanElevationWhereInput
    data: XOR<PlanElevationUpdateWithoutJobsInput, PlanElevationUncheckedUpdateWithoutJobsInput>
  }

  export type PlanElevationUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutElevationsNestedInput
  }

  export type PlanElevationUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityUpsertWithoutJobsInput = {
    update: XOR<CommunityUpdateWithoutJobsInput, CommunityUncheckedUpdateWithoutJobsInput>
    create: XOR<CommunityCreateWithoutJobsInput, CommunityUncheckedCreateWithoutJobsInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutJobsInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutJobsInput, CommunityUncheckedUpdateWithoutJobsInput>
  }

  export type CommunityUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCommunitiesNestedInput
    lots?: LotUpdateManyWithoutCommunityNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: LotUncheckedUpdateManyWithoutCommunityNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type LotUpsertWithoutJobsInput = {
    update: XOR<LotUpdateWithoutJobsInput, LotUncheckedUpdateWithoutJobsInput>
    create: XOR<LotCreateWithoutJobsInput, LotUncheckedCreateWithoutJobsInput>
    where?: LotWhereInput
  }

  export type LotUpdateToOneWithWhereWithoutJobsInput = {
    where?: LotWhereInput
    data: XOR<LotUpdateWithoutJobsInput, LotUncheckedUpdateWithoutJobsInput>
  }

  export type LotUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    frontage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutLotsNestedInput
  }

  export type LotUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    frontage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedJobsInput = {
    update: XOR<UserUpdateWithoutCreatedJobsInput, UserUncheckedUpdateWithoutCreatedJobsInput>
    create: XOR<UserCreateWithoutCreatedJobsInput, UserUncheckedCreateWithoutCreatedJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedJobsInput, UserUncheckedUpdateWithoutCreatedJobsInput>
  }

  export type UserUpdateWithoutCreatedJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedJobs?: JobUpdateManyWithoutApprovedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedJobs?: JobUncheckedUpdateManyWithoutApprovedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUpsertWithoutApprovedJobsInput = {
    update: XOR<UserUpdateWithoutApprovedJobsInput, UserUncheckedUpdateWithoutApprovedJobsInput>
    create: XOR<UserCreateWithoutApprovedJobsInput, UserUncheckedCreateWithoutApprovedJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedJobsInput, UserUncheckedUpdateWithoutApprovedJobsInput>
  }

  export type UserUpdateWithoutApprovedJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type JobOptionUpsertWithWhereUniqueWithoutJobInput = {
    where: JobOptionWhereUniqueInput
    update: XOR<JobOptionUpdateWithoutJobInput, JobOptionUncheckedUpdateWithoutJobInput>
    create: XOR<JobOptionCreateWithoutJobInput, JobOptionUncheckedCreateWithoutJobInput>
  }

  export type JobOptionUpdateWithWhereUniqueWithoutJobInput = {
    where: JobOptionWhereUniqueInput
    data: XOR<JobOptionUpdateWithoutJobInput, JobOptionUncheckedUpdateWithoutJobInput>
  }

  export type JobOptionUpdateManyWithWhereWithoutJobInput = {
    where: JobOptionScalarWhereInput
    data: XOR<JobOptionUpdateManyMutationInput, JobOptionUncheckedUpdateManyWithoutJobInput>
  }

  export type TakeoffUpsertWithoutJobInput = {
    update: XOR<TakeoffUpdateWithoutJobInput, TakeoffUncheckedUpdateWithoutJobInput>
    create: XOR<TakeoffCreateWithoutJobInput, TakeoffUncheckedCreateWithoutJobInput>
    where?: TakeoffWhereInput
  }

  export type TakeoffUpdateToOneWithWhereWithoutJobInput = {
    where?: TakeoffWhereInput
    data: XOR<TakeoffUpdateWithoutJobInput, TakeoffUncheckedUpdateWithoutJobInput>
  }

  export type TakeoffUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: TakeoffLineItemUpdateManyWithoutTakeoffNestedInput
    validation?: TakeoffValidationUpdateOneWithoutTakeoffNestedInput
  }

  export type TakeoffUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: TakeoffLineItemUncheckedUpdateManyWithoutTakeoffNestedInput
    validation?: TakeoffValidationUncheckedUpdateOneWithoutTakeoffNestedInput
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutJobInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutJobInput, PurchaseOrderUncheckedUpdateWithoutJobInput>
    create: XOR<PurchaseOrderCreateWithoutJobInput, PurchaseOrderUncheckedCreateWithoutJobInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutJobInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutJobInput, PurchaseOrderUncheckedUpdateWithoutJobInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutJobInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutJobInput>
  }

  export type JobCreateWithoutJobOptionsInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    plan: PlanCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutJobOptionsInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutJobOptionsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutJobOptionsInput, JobUncheckedCreateWithoutJobOptionsInput>
  }

  export type PlanOptionCreateWithoutJobOptionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.OptionCategory
    basePrice: Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionCreatetriggersPacksInput | string[]
    appliesTo?: PlanOptionCreateappliesToInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: PlanCreateNestedManyWithoutOptionsInput
  }

  export type PlanOptionUncheckedCreateWithoutJobOptionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.OptionCategory
    basePrice: Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionCreatetriggersPacksInput | string[]
    appliesTo?: PlanOptionCreateappliesToInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: PlanUncheckedCreateNestedManyWithoutOptionsInput
  }

  export type PlanOptionCreateOrConnectWithoutJobOptionsInput = {
    where: PlanOptionWhereUniqueInput
    create: XOR<PlanOptionCreateWithoutJobOptionsInput, PlanOptionUncheckedCreateWithoutJobOptionsInput>
  }

  export type JobUpsertWithoutJobOptionsInput = {
    update: XOR<JobUpdateWithoutJobOptionsInput, JobUncheckedUpdateWithoutJobOptionsInput>
    create: XOR<JobCreateWithoutJobOptionsInput, JobUncheckedCreateWithoutJobOptionsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutJobOptionsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutJobOptionsInput, JobUncheckedUpdateWithoutJobOptionsInput>
  }

  export type JobUpdateWithoutJobOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutJobOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type PlanOptionUpsertWithoutJobOptionsInput = {
    update: XOR<PlanOptionUpdateWithoutJobOptionsInput, PlanOptionUncheckedUpdateWithoutJobOptionsInput>
    create: XOR<PlanOptionCreateWithoutJobOptionsInput, PlanOptionUncheckedCreateWithoutJobOptionsInput>
    where?: PlanOptionWhereInput
  }

  export type PlanOptionUpdateToOneWithWhereWithoutJobOptionsInput = {
    where?: PlanOptionWhereInput
    data: XOR<PlanOptionUpdateWithoutJobOptionsInput, PlanOptionUncheckedUpdateWithoutJobOptionsInput>
  }

  export type PlanOptionUpdateWithoutJobOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumOptionCategoryFieldUpdateOperationsInput | $Enums.OptionCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionUpdatetriggersPacksInput | string[]
    appliesTo?: PlanOptionUpdateappliesToInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: PlanUpdateManyWithoutOptionsNestedInput
  }

  export type PlanOptionUncheckedUpdateWithoutJobOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumOptionCategoryFieldUpdateOperationsInput | $Enums.OptionCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionUpdatetriggersPacksInput | string[]
    appliesTo?: PlanOptionUpdateappliesToInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: PlanUncheckedUpdateManyWithoutOptionsNestedInput
  }

  export type JobCreateWithoutTakeoffInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    plan: PlanCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutTakeoffInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutTakeoffInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutTakeoffInput, JobUncheckedCreateWithoutTakeoffInput>
  }

  export type TakeoffLineItemCreateWithoutTakeoffInput = {
    id?: string
    quantityEstimated: Decimal | DecimalJsLike | number | string
    quantityActual?: Decimal | DecimalJsLike | number | string | null
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    variancePercent?: Decimal | DecimalJsLike | number | string | null
    varianceReason?: string | null
    category: string
    subcategory?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutTakeoffLineItemsInput
  }

  export type TakeoffLineItemUncheckedCreateWithoutTakeoffInput = {
    id?: string
    materialId: string
    quantityEstimated: Decimal | DecimalJsLike | number | string
    quantityActual?: Decimal | DecimalJsLike | number | string | null
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    variancePercent?: Decimal | DecimalJsLike | number | string | null
    varianceReason?: string | null
    category: string
    subcategory?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakeoffLineItemCreateOrConnectWithoutTakeoffInput = {
    where: TakeoffLineItemWhereUniqueInput
    create: XOR<TakeoffLineItemCreateWithoutTakeoffInput, TakeoffLineItemUncheckedCreateWithoutTakeoffInput>
  }

  export type TakeoffLineItemCreateManyTakeoffInputEnvelope = {
    data: TakeoffLineItemCreateManyTakeoffInput | TakeoffLineItemCreateManyTakeoffInput[]
    skipDuplicates?: boolean
  }

  export type TakeoffValidationCreateWithoutTakeoffInput = {
    id?: string
    specCompliant?: boolean
    pricingCurrent?: boolean
    varianceAcceptable?: boolean
    issues: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationCreatecomparedToJobsInput | string[]
    avgVariance?: Decimal | DecimalJsLike | number | string | null
    validatedAt?: Date | string
  }

  export type TakeoffValidationUncheckedCreateWithoutTakeoffInput = {
    id?: string
    specCompliant?: boolean
    pricingCurrent?: boolean
    varianceAcceptable?: boolean
    issues: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationCreatecomparedToJobsInput | string[]
    avgVariance?: Decimal | DecimalJsLike | number | string | null
    validatedAt?: Date | string
  }

  export type TakeoffValidationCreateOrConnectWithoutTakeoffInput = {
    where: TakeoffValidationWhereUniqueInput
    create: XOR<TakeoffValidationCreateWithoutTakeoffInput, TakeoffValidationUncheckedCreateWithoutTakeoffInput>
  }

  export type JobUpsertWithoutTakeoffInput = {
    update: XOR<JobUpdateWithoutTakeoffInput, JobUncheckedUpdateWithoutTakeoffInput>
    create: XOR<JobCreateWithoutTakeoffInput, JobUncheckedCreateWithoutTakeoffInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutTakeoffInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutTakeoffInput, JobUncheckedUpdateWithoutTakeoffInput>
  }

  export type JobUpdateWithoutTakeoffInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutTakeoffInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type TakeoffLineItemUpsertWithWhereUniqueWithoutTakeoffInput = {
    where: TakeoffLineItemWhereUniqueInput
    update: XOR<TakeoffLineItemUpdateWithoutTakeoffInput, TakeoffLineItemUncheckedUpdateWithoutTakeoffInput>
    create: XOR<TakeoffLineItemCreateWithoutTakeoffInput, TakeoffLineItemUncheckedCreateWithoutTakeoffInput>
  }

  export type TakeoffLineItemUpdateWithWhereUniqueWithoutTakeoffInput = {
    where: TakeoffLineItemWhereUniqueInput
    data: XOR<TakeoffLineItemUpdateWithoutTakeoffInput, TakeoffLineItemUncheckedUpdateWithoutTakeoffInput>
  }

  export type TakeoffLineItemUpdateManyWithWhereWithoutTakeoffInput = {
    where: TakeoffLineItemScalarWhereInput
    data: XOR<TakeoffLineItemUpdateManyMutationInput, TakeoffLineItemUncheckedUpdateManyWithoutTakeoffInput>
  }

  export type TakeoffValidationUpsertWithoutTakeoffInput = {
    update: XOR<TakeoffValidationUpdateWithoutTakeoffInput, TakeoffValidationUncheckedUpdateWithoutTakeoffInput>
    create: XOR<TakeoffValidationCreateWithoutTakeoffInput, TakeoffValidationUncheckedCreateWithoutTakeoffInput>
    where?: TakeoffValidationWhereInput
  }

  export type TakeoffValidationUpdateToOneWithWhereWithoutTakeoffInput = {
    where?: TakeoffValidationWhereInput
    data: XOR<TakeoffValidationUpdateWithoutTakeoffInput, TakeoffValidationUncheckedUpdateWithoutTakeoffInput>
  }

  export type TakeoffValidationUpdateWithoutTakeoffInput = {
    id?: StringFieldUpdateOperationsInput | string
    specCompliant?: BoolFieldUpdateOperationsInput | boolean
    pricingCurrent?: BoolFieldUpdateOperationsInput | boolean
    varianceAcceptable?: BoolFieldUpdateOperationsInput | boolean
    issues?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationUpdatecomparedToJobsInput | string[]
    avgVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffValidationUncheckedUpdateWithoutTakeoffInput = {
    id?: StringFieldUpdateOperationsInput | string
    specCompliant?: BoolFieldUpdateOperationsInput | boolean
    pricingCurrent?: BoolFieldUpdateOperationsInput | boolean
    varianceAcceptable?: BoolFieldUpdateOperationsInput | boolean
    issues?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    comparedToJobs?: TakeoffValidationUpdatecomparedToJobsInput | string[]
    avgVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffCreateWithoutLineItemsInput = {
    id?: string
    status?: $Enums.TakeoffStatus
    isValidated?: boolean
    validatedAt?: Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutTakeoffInput
    validation?: TakeoffValidationCreateNestedOneWithoutTakeoffInput
  }

  export type TakeoffUncheckedCreateWithoutLineItemsInput = {
    id?: string
    jobId: string
    status?: $Enums.TakeoffStatus
    isValidated?: boolean
    validatedAt?: Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validation?: TakeoffValidationUncheckedCreateNestedOneWithoutTakeoffInput
  }

  export type TakeoffCreateOrConnectWithoutLineItemsInput = {
    where: TakeoffWhereUniqueInput
    create: XOR<TakeoffCreateWithoutLineItemsInput, TakeoffUncheckedCreateWithoutLineItemsInput>
  }

  export type MaterialCreateWithoutTakeoffLineItemsInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutMaterialsInput
    pricingHistory?: PricingHistoryCreateNestedManyWithoutMaterialInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutTakeoffLineItemsInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: string | null
    pricingHistory?: PricingHistoryUncheckedCreateNestedManyWithoutMaterialInput
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutMaterialInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutTakeoffLineItemsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutTakeoffLineItemsInput, MaterialUncheckedCreateWithoutTakeoffLineItemsInput>
  }

  export type TakeoffUpsertWithoutLineItemsInput = {
    update: XOR<TakeoffUpdateWithoutLineItemsInput, TakeoffUncheckedUpdateWithoutLineItemsInput>
    create: XOR<TakeoffCreateWithoutLineItemsInput, TakeoffUncheckedCreateWithoutLineItemsInput>
    where?: TakeoffWhereInput
  }

  export type TakeoffUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: TakeoffWhereInput
    data: XOR<TakeoffUpdateWithoutLineItemsInput, TakeoffUncheckedUpdateWithoutLineItemsInput>
  }

  export type TakeoffUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutTakeoffNestedInput
    validation?: TakeoffValidationUpdateOneWithoutTakeoffNestedInput
  }

  export type TakeoffUncheckedUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validation?: TakeoffValidationUncheckedUpdateOneWithoutTakeoffNestedInput
  }

  export type MaterialUpsertWithoutTakeoffLineItemsInput = {
    update: XOR<MaterialUpdateWithoutTakeoffLineItemsInput, MaterialUncheckedUpdateWithoutTakeoffLineItemsInput>
    create: XOR<MaterialCreateWithoutTakeoffLineItemsInput, MaterialUncheckedCreateWithoutTakeoffLineItemsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutTakeoffLineItemsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutTakeoffLineItemsInput, MaterialUncheckedUpdateWithoutTakeoffLineItemsInput>
  }

  export type MaterialUpdateWithoutTakeoffLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutMaterialsNestedInput
    pricingHistory?: PricingHistoryUpdateManyWithoutMaterialNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutTakeoffLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingHistory?: PricingHistoryUncheckedUpdateManyWithoutMaterialNestedInput
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type TakeoffCreateWithoutValidationInput = {
    id?: string
    status?: $Enums.TakeoffStatus
    isValidated?: boolean
    validatedAt?: Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutTakeoffInput
    lineItems?: TakeoffLineItemCreateNestedManyWithoutTakeoffInput
  }

  export type TakeoffUncheckedCreateWithoutValidationInput = {
    id?: string
    jobId: string
    status?: $Enums.TakeoffStatus
    isValidated?: boolean
    validatedAt?: Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: TakeoffLineItemUncheckedCreateNestedManyWithoutTakeoffInput
  }

  export type TakeoffCreateOrConnectWithoutValidationInput = {
    where: TakeoffWhereUniqueInput
    create: XOR<TakeoffCreateWithoutValidationInput, TakeoffUncheckedCreateWithoutValidationInput>
  }

  export type TakeoffUpsertWithoutValidationInput = {
    update: XOR<TakeoffUpdateWithoutValidationInput, TakeoffUncheckedUpdateWithoutValidationInput>
    create: XOR<TakeoffCreateWithoutValidationInput, TakeoffUncheckedCreateWithoutValidationInput>
    where?: TakeoffWhereInput
  }

  export type TakeoffUpdateToOneWithWhereWithoutValidationInput = {
    where?: TakeoffWhereInput
    data: XOR<TakeoffUpdateWithoutValidationInput, TakeoffUncheckedUpdateWithoutValidationInput>
  }

  export type TakeoffUpdateWithoutValidationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutTakeoffNestedInput
    lineItems?: TakeoffLineItemUpdateManyWithoutTakeoffNestedInput
  }

  export type TakeoffUncheckedUpdateWithoutValidationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumTakeoffStatusFieldUpdateOperationsInput | $Enums.TakeoffStatus
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: TakeoffLineItemUncheckedUpdateManyWithoutTakeoffNestedInput
  }

  export type JobCreateWithoutPurchaseOrdersInput = {
    id?: string
    jobNumber: string
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutJobsInput
    plan: PlanCreateNestedOneWithoutJobsInput
    elevation?: PlanElevationCreateNestedOneWithoutJobsInput
    community?: CommunityCreateNestedOneWithoutJobsInput
    lot?: LotCreateNestedOneWithoutJobsInput
    createdBy: UserCreateNestedOneWithoutCreatedJobsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedJobsInput
    jobOptions?: JobOptionCreateNestedManyWithoutJobInput
    takeoff?: TakeoffCreateNestedOneWithoutJobInput
  }

  export type JobUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobOptions?: JobOptionUncheckedCreateNestedManyWithoutJobInput
    takeoff?: TakeoffUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutPurchaseOrdersInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutPurchaseOrdersInput, JobUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type VendorCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    code: string
    primaryContact?: string | null
    email?: string | null
    phone?: string | null
    paymentTerms?: string | null
    leadTimeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    code: string
    primaryContact?: string | null
    email?: string | null
    phone?: string | null
    paymentTerms?: string | null
    leadTimeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchaseOrdersInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchaseOrdersInput, VendorUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type JobUpsertWithoutPurchaseOrdersInput = {
    update: XOR<JobUpdateWithoutPurchaseOrdersInput, JobUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<JobCreateWithoutPurchaseOrdersInput, JobUncheckedCreateWithoutPurchaseOrdersInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutPurchaseOrdersInput, JobUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type JobUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
  }

  export type VendorUpsertWithoutPurchaseOrdersInput = {
    update: XOR<VendorUpdateWithoutPurchaseOrdersInput, VendorUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<VendorCreateWithoutPurchaseOrdersInput, VendorUncheckedCreateWithoutPurchaseOrdersInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPurchaseOrdersInput, VendorUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type VendorUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    primaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    primaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type PlanCreateWithoutVariancePatternsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationCreateNestedManyWithoutPlanInput
    options?: PlanOptionCreateNestedManyWithoutPlansInput
    templateItems?: PlanTemplateItemCreateNestedManyWithoutPlanInput
    jobs?: JobCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutVariancePatternsInput = {
    id?: string
    code: string
    name?: string | null
    type: $Enums.PlanType
    sqft?: number | null
    bedrooms?: number | null
    bathrooms?: Decimal | DecimalJsLike | number | string | null
    garage?: string | null
    style?: string | null
    version?: number
    isActive?: boolean
    pdssUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elevations?: PlanElevationUncheckedCreateNestedManyWithoutPlanInput
    options?: PlanOptionUncheckedCreateNestedManyWithoutPlansInput
    templateItems?: PlanTemplateItemUncheckedCreateNestedManyWithoutPlanInput
    jobs?: JobUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutVariancePatternsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutVariancePatternsInput, PlanUncheckedCreateWithoutVariancePatternsInput>
  }

  export type CommunityCreateWithoutVariancePatternsInput = {
    id?: string
    name: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCommunitiesInput
    lots?: LotCreateNestedManyWithoutCommunityInput
    jobs?: JobCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutVariancePatternsInput = {
    id?: string
    name: string
    customerId: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: LotUncheckedCreateNestedManyWithoutCommunityInput
    jobs?: JobUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutVariancePatternsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutVariancePatternsInput, CommunityUncheckedCreateWithoutVariancePatternsInput>
  }

  export type CustomerCreateWithoutVariancePatternsInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    communities?: CommunityCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutVariancePatternsInput = {
    id?: string
    customerName: string
    customerType: $Enums.CustomerType
    pricingTier?: string | null
    primaryContactId?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    pricingTiers?: CustomerPricingTierUncheckedCreateNestedManyWithoutCustomerInput
    externalIds?: CustomerExternalIdUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    communities?: CommunityUncheckedCreateNestedManyWithoutCustomerInput
    customerPricing?: CustomerPricingUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutVariancePatternsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutVariancePatternsInput, CustomerUncheckedCreateWithoutVariancePatternsInput>
  }

  export type VarianceReviewCreateWithoutPatternInput = {
    id?: string
    decision: $Enums.ReviewDecision
    notes?: string | null
    reviewedAt?: Date | string
    reviewer: UserCreateNestedOneWithoutVarianceReviewsInput
  }

  export type VarianceReviewUncheckedCreateWithoutPatternInput = {
    id?: string
    reviewerId: string
    decision: $Enums.ReviewDecision
    notes?: string | null
    reviewedAt?: Date | string
  }

  export type VarianceReviewCreateOrConnectWithoutPatternInput = {
    where: VarianceReviewWhereUniqueInput
    create: XOR<VarianceReviewCreateWithoutPatternInput, VarianceReviewUncheckedCreateWithoutPatternInput>
  }

  export type VarianceReviewCreateManyPatternInputEnvelope = {
    data: VarianceReviewCreateManyPatternInput | VarianceReviewCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithoutVariancePatternsInput = {
    update: XOR<PlanUpdateWithoutVariancePatternsInput, PlanUncheckedUpdateWithoutVariancePatternsInput>
    create: XOR<PlanCreateWithoutVariancePatternsInput, PlanUncheckedCreateWithoutVariancePatternsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutVariancePatternsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutVariancePatternsInput, PlanUncheckedUpdateWithoutVariancePatternsInput>
  }

  export type PlanUpdateWithoutVariancePatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUpdateManyWithoutPlanNestedInput
    options?: PlanOptionUpdateManyWithoutPlansNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutPlanNestedInput
    jobs?: JobUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutVariancePatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUncheckedUpdateManyWithoutPlanNestedInput
    options?: PlanOptionUncheckedUpdateManyWithoutPlansNestedInput
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutPlanNestedInput
    jobs?: JobUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type CommunityUpsertWithoutVariancePatternsInput = {
    update: XOR<CommunityUpdateWithoutVariancePatternsInput, CommunityUncheckedUpdateWithoutVariancePatternsInput>
    create: XOR<CommunityCreateWithoutVariancePatternsInput, CommunityUncheckedCreateWithoutVariancePatternsInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutVariancePatternsInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutVariancePatternsInput, CommunityUncheckedUpdateWithoutVariancePatternsInput>
  }

  export type CommunityUpdateWithoutVariancePatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCommunitiesNestedInput
    lots?: LotUpdateManyWithoutCommunityNestedInput
    jobs?: JobUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutVariancePatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: LotUncheckedUpdateManyWithoutCommunityNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CustomerUpsertWithoutVariancePatternsInput = {
    update: XOR<CustomerUpdateWithoutVariancePatternsInput, CustomerUncheckedUpdateWithoutVariancePatternsInput>
    create: XOR<CustomerCreateWithoutVariancePatternsInput, CustomerUncheckedCreateWithoutVariancePatternsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutVariancePatternsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutVariancePatternsInput, CustomerUncheckedUpdateWithoutVariancePatternsInput>
  }

  export type CustomerUpdateWithoutVariancePatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutVariancePatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    pricingTier?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    pricingTiers?: CustomerPricingTierUncheckedUpdateManyWithoutCustomerNestedInput
    externalIds?: CustomerExternalIdUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    communities?: CommunityUncheckedUpdateManyWithoutCustomerNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type VarianceReviewUpsertWithWhereUniqueWithoutPatternInput = {
    where: VarianceReviewWhereUniqueInput
    update: XOR<VarianceReviewUpdateWithoutPatternInput, VarianceReviewUncheckedUpdateWithoutPatternInput>
    create: XOR<VarianceReviewCreateWithoutPatternInput, VarianceReviewUncheckedCreateWithoutPatternInput>
  }

  export type VarianceReviewUpdateWithWhereUniqueWithoutPatternInput = {
    where: VarianceReviewWhereUniqueInput
    data: XOR<VarianceReviewUpdateWithoutPatternInput, VarianceReviewUncheckedUpdateWithoutPatternInput>
  }

  export type VarianceReviewUpdateManyWithWhereWithoutPatternInput = {
    where: VarianceReviewScalarWhereInput
    data: XOR<VarianceReviewUpdateManyMutationInput, VarianceReviewUncheckedUpdateManyWithoutPatternInput>
  }

  export type VariancePatternCreateWithoutReviewsInput = {
    id?: string
    scope: $Enums.VarianceScope
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutVariancePatternsInput
    community?: CommunityCreateNestedOneWithoutVariancePatternsInput
    customer?: CustomerCreateNestedOneWithoutVariancePatternsInput
  }

  export type VariancePatternUncheckedCreateWithoutReviewsInput = {
    id?: string
    scope: $Enums.VarianceScope
    planId?: string | null
    communityId?: string | null
    customerId?: string | null
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariancePatternCreateOrConnectWithoutReviewsInput = {
    where: VariancePatternWhereUniqueInput
    create: XOR<VariancePatternCreateWithoutReviewsInput, VariancePatternUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutVarianceReviewsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobCreateNestedManyWithoutCreatedByInput
    approvedJobs?: JobCreateNestedManyWithoutApprovedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVarianceReviewsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobUncheckedCreateNestedManyWithoutCreatedByInput
    approvedJobs?: JobUncheckedCreateNestedManyWithoutApprovedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVarianceReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVarianceReviewsInput, UserUncheckedCreateWithoutVarianceReviewsInput>
  }

  export type VariancePatternUpsertWithoutReviewsInput = {
    update: XOR<VariancePatternUpdateWithoutReviewsInput, VariancePatternUncheckedUpdateWithoutReviewsInput>
    create: XOR<VariancePatternCreateWithoutReviewsInput, VariancePatternUncheckedCreateWithoutReviewsInput>
    where?: VariancePatternWhereInput
  }

  export type VariancePatternUpdateToOneWithWhereWithoutReviewsInput = {
    where?: VariancePatternWhereInput
    data: XOR<VariancePatternUpdateWithoutReviewsInput, VariancePatternUncheckedUpdateWithoutReviewsInput>
  }

  export type VariancePatternUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutVariancePatternsNestedInput
    community?: CommunityUpdateOneWithoutVariancePatternsNestedInput
    customer?: CustomerUpdateOneWithoutVariancePatternsNestedInput
  }

  export type VariancePatternUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutVarianceReviewsInput = {
    update: XOR<UserUpdateWithoutVarianceReviewsInput, UserUncheckedUpdateWithoutVarianceReviewsInput>
    create: XOR<UserCreateWithoutVarianceReviewsInput, UserUncheckedCreateWithoutVarianceReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVarianceReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVarianceReviewsInput, UserUncheckedUpdateWithoutVarianceReviewsInput>
  }

  export type UserUpdateWithoutVarianceReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUpdateManyWithoutCreatedByNestedInput
    approvedJobs?: JobUpdateManyWithoutApprovedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVarianceReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedJobs?: JobUncheckedUpdateManyWithoutApprovedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobCreateNestedManyWithoutCreatedByInput
    approvedJobs?: JobCreateNestedManyWithoutApprovedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobUncheckedCreateNestedManyWithoutCreatedByInput
    approvedJobs?: JobUncheckedCreateNestedManyWithoutApprovedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUpdateManyWithoutCreatedByNestedInput
    approvedJobs?: JobUpdateManyWithoutApprovedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedJobs?: JobUncheckedUpdateManyWithoutApprovedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobCreateNestedManyWithoutCreatedByInput
    approvedJobs?: JobCreateNestedManyWithoutApprovedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdJobs?: JobUncheckedCreateNestedManyWithoutCreatedByInput
    approvedJobs?: JobUncheckedCreateNestedManyWithoutApprovedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    varianceReviews?: VarianceReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUpdateManyWithoutCreatedByNestedInput
    approvedJobs?: JobUpdateManyWithoutApprovedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdJobs?: JobUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedJobs?: JobUncheckedUpdateManyWithoutApprovedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    varianceReviews?: VarianceReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type JobCreateManyCreatedByInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateManyApprovedByInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VarianceReviewCreateManyReviewerInput = {
    id?: string
    patternId: string
    decision: $Enums.ReviewDecision
    notes?: string | null
    reviewedAt?: Date | string
  }

  export type JobUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: VariancePatternUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type VarianceReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactCreateManyCustomerInput = {
    id?: string
    contactName: string
    role?: string | null
    email?: string | null
    phone?: string | null
    receivesNotifications?: boolean
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type CustomerPricingTierCreateManyCustomerInput = {
    id?: string
    tierName: string
    discountPercentage: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type CustomerExternalIdCreateManyCustomerInput = {
    id?: string
    externalSystem: string
    externalCustomerId: string
    externalCustomerName?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type JobCreateManyCustomerInput = {
    id?: string
    jobNumber: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityCreateManyCustomerInput = {
    id?: string
    name: string
    shippingYard: string
    jurisdiction?: string | null
    region?: string | null
    activePlans?: number
    isActive?: boolean
    specialRequirements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPricingCreateManyCustomerInput = {
    id?: string
    materialId: string
    overridePrice?: Decimal | DecimalJsLike | number | string | null
    overrideMargin?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: Decimal | DecimalJsLike | number | string | null
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariancePatternCreateManyCustomerInput = {
    id?: string
    scope: $Enums.VarianceScope
    planId?: string | null
    communityId?: string | null
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerContactUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    receivesNotifications?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    receivesNotifications?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    receivesNotifications?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingTierUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingTierUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingTierUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerExternalIdUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalSystem?: StringFieldUpdateOperationsInput | string
    externalCustomerId?: StringFieldUpdateOperationsInput | string
    externalCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerExternalIdUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalSystem?: StringFieldUpdateOperationsInput | string
    externalCustomerId?: StringFieldUpdateOperationsInput | string
    externalCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerExternalIdUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalSystem?: StringFieldUpdateOperationsInput | string
    externalCustomerId?: StringFieldUpdateOperationsInput | string
    externalCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: LotUpdateManyWithoutCommunityNestedInput
    jobs?: JobUpdateManyWithoutCommunityNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: LotUncheckedUpdateManyWithoutCommunityNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCommunityNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shippingYard?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    activePlans?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutCustomerPricingNestedInput
  }

  export type CustomerPricingUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariancePatternUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutVariancePatternsNestedInput
    community?: CommunityUpdateOneWithoutVariancePatternsNestedInput
    reviews?: VarianceReviewUpdateManyWithoutPatternNestedInput
  }

  export type VariancePatternUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VarianceReviewUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type VariancePatternUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanElevationCreateManyPlanInput = {
    id?: string
    code: string
    name?: string | null
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanTemplateItemCreateManyPlanInput = {
    id?: string
    materialId: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    wasteFactor?: Decimal | DecimalJsLike | number | string
    category: string
    subcategory?: string | null
    averageVariance?: Decimal | DecimalJsLike | number | string | null
    varianceCount?: number
    lastVarianceDate?: Date | string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateManyPlanInput = {
    id?: string
    jobNumber: string
    customerId: string
    elevationId?: string | null
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariancePatternCreateManyPlanInput = {
    id?: string
    scope: $Enums.VarianceScope
    communityId?: string | null
    customerId?: string | null
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanElevationUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutElevationNestedInput
  }

  export type PlanElevationUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutElevationNestedInput
  }

  export type PlanElevationUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanOptionUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumOptionCategoryFieldUpdateOperationsInput | $Enums.OptionCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionUpdatetriggersPacksInput | string[]
    appliesTo?: PlanOptionUpdateappliesToInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUpdateManyWithoutOptionNestedInput
  }

  export type PlanOptionUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumOptionCategoryFieldUpdateOperationsInput | $Enums.OptionCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionUpdatetriggersPacksInput | string[]
    appliesTo?: PlanOptionUpdateappliesToInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type PlanOptionUncheckedUpdateManyWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumOptionCategoryFieldUpdateOperationsInput | $Enums.OptionCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    triggersPacks?: PlanOptionUpdatetriggersPacksInput | string[]
    appliesTo?: PlanOptionUpdateappliesToInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanTemplateItemUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutTemplateItemsNestedInput
  }

  export type PlanTemplateItemUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanTemplateItemUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariancePatternUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneWithoutVariancePatternsNestedInput
    customer?: CustomerUpdateOneWithoutVariancePatternsNestedInput
    reviews?: VarianceReviewUpdateManyWithoutPatternNestedInput
  }

  export type VariancePatternUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VarianceReviewUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type VariancePatternUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateManyElevationInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    communityId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateWithoutElevationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutElevationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutElevationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOptionCreateManyOptionInput = {
    id?: string
    jobId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PlanUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUpdateManyWithoutPlanNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutPlanNestedInput
    jobs?: JobUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elevations?: PlanElevationUncheckedUpdateManyWithoutPlanNestedInput
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutPlanNestedInput
    jobs?: JobUncheckedUpdateManyWithoutPlanNestedInput
    variancePatterns?: VariancePatternUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    garage?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pdssUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOptionUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutJobOptionsNestedInput
  }

  export type JobOptionUncheckedUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOptionUncheckedUpdateManyWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingHistoryCreateManyMaterialInput = {
    id?: string
    baseVendorCost: Decimal | DecimalJsLike | number | string
    commodityAdjustment?: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginPercentage: Decimal | DecimalJsLike | number | string
    marginAmount: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    calculationSteps: JsonNullValueInput | InputJsonValue
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PlanTemplateItemCreateManyMaterialInput = {
    id?: string
    planId: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    wasteFactor?: Decimal | DecimalJsLike | number | string
    category: string
    subcategory?: string | null
    averageVariance?: Decimal | DecimalJsLike | number | string | null
    varianceCount?: number
    lastVarianceDate?: Date | string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPricingCreateManyMaterialInput = {
    id?: string
    customerId: string
    overridePrice?: Decimal | DecimalJsLike | number | string | null
    overrideMargin?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: Decimal | DecimalJsLike | number | string | null
    effectiveDate?: Date | string
    expiresAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakeoffLineItemCreateManyMaterialInput = {
    id?: string
    takeoffId: string
    quantityEstimated: Decimal | DecimalJsLike | number | string
    quantityActual?: Decimal | DecimalJsLike | number | string | null
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    variancePercent?: Decimal | DecimalJsLike | number | string | null
    varianceReason?: string | null
    category: string
    subcategory?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingHistoryUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseVendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingHistoryUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseVendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingHistoryUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseVendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commodityAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationSteps?: JsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanTemplateItemUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutTemplateItemsNestedInput
  }

  export type PlanTemplateItemUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanTemplateItemUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    wasteFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    averageVariance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceCount?: IntFieldUpdateOperationsInput | number
    lastVarianceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerPricingNestedInput
  }

  export type CustomerPricingUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPricingUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    overridePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overrideMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffLineItemUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    takeoff?: TakeoffUpdateOneRequiredWithoutLineItemsNestedInput
  }

  export type TakeoffLineItemUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    takeoffId?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffLineItemUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    takeoffId?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateManyVendorInput = {
    id?: string
    sku: string
    description: string
    category: $Enums.MaterialCategory
    subcategory?: string | null
    unitOfMeasure: string
    vendorCost: Decimal | DecimalJsLike | number | string
    freight?: Decimal | DecimalJsLike | number | string
    isRLLinked?: boolean
    rlTag?: string | null
    rlBasePrice?: Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyVendorInput = {
    id?: string
    poNumber: string
    jobId: string
    status?: $Enums.POStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    approvedAt?: Date | string | null
    sentAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    scheduledDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    deliveryNotes?: string | null
    hyphenBuildProId?: string | null
    holtPortalId?: string | null
    signatureUrl?: string | null
    photoUrls?: PurchaseOrderCreatephotoUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingHistory?: PricingHistoryUpdateManyWithoutMaterialNestedInput
    templateItems?: PlanTemplateItemUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingHistory?: PricingHistoryUncheckedUpdateManyWithoutMaterialNestedInput
    templateItems?: PlanTemplateItemUncheckedUpdateManyWithoutMaterialNestedInput
    customerPricing?: CustomerPricingUncheckedUpdateManyWithoutMaterialNestedInput
    takeoffLineItems?: TakeoffLineItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: StringFieldUpdateOperationsInput | string
    vendorCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRLLinked?: BoolFieldUpdateOperationsInput | boolean
    rlTag?: NullableStringFieldUpdateOperationsInput | string | null
    rlBasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rlLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lengthAdders?: NullableJsonNullValueInput | InputJsonValue
    gradeMultipliers?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotCreateManyCommunityInput = {
    id?: string
    lotNumber: string
    status?: $Enums.LotStatus
    sqft?: number | null
    frontage?: Decimal | DecimalJsLike | number | string | null
    depth?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateManyCommunityInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    lotId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariancePatternCreateManyCommunityInput = {
    id?: string
    scope: $Enums.VarianceScope
    planId?: string | null
    customerId?: string | null
    region?: string | null
    materialCategory: string
    subcategory?: string | null
    sampleSize: number
    avgVariance: Decimal | DecimalJsLike | number | string
    stdDeviation: Decimal | DecimalJsLike | number | string
    confidenceScore: Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: Decimal | DecimalJsLike | number | string | null
    reasoning?: string | null
    status?: $Enums.PatternStatus
    reviewedAt?: Date | string | null
    appliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LotUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    frontage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutLotNestedInput
  }

  export type LotUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    frontage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutLotNestedInput
  }

  export type LotUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    frontage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    lot?: LotUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariancePatternUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutVariancePatternsNestedInput
    customer?: CustomerUpdateOneWithoutVariancePatternsNestedInput
    reviews?: VarianceReviewUpdateManyWithoutPatternNestedInput
  }

  export type VariancePatternUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VarianceReviewUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type VariancePatternUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumVarianceScopeFieldUpdateOperationsInput | $Enums.VarianceScope
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    materialCategory?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    avgVariance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stdDeviation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateManyLotInput = {
    id?: string
    jobNumber: string
    customerId: string
    planId: string
    elevationId?: string | null
    communityId?: string | null
    status?: $Enums.JobStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    actualCost?: Decimal | DecimalJsLike | number | string | null
    margin?: Decimal | DecimalJsLike | number | string | null
    createdById: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    startDate?: Date | string | null
    completionDate?: Date | string | null
    notes?: string | null
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    plan?: PlanUpdateOneRequiredWithoutJobsNestedInput
    elevation?: PlanElevationUpdateOneWithoutJobsNestedInput
    community?: CommunityUpdateOneWithoutJobsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedJobsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedJobsNestedInput
    jobOptions?: JobOptionUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOptions?: JobOptionUncheckedUpdateManyWithoutJobNestedInput
    takeoff?: TakeoffUncheckedUpdateOneWithoutJobNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    elevationId?: NullableStringFieldUpdateOperationsInput | string | null
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOptionCreateManyJobInput = {
    id?: string
    optionId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PurchaseOrderCreateManyJobInput = {
    id?: string
    poNumber: string
    vendorId?: string | null
    status?: $Enums.POStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    approvedAt?: Date | string | null
    sentAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    scheduledDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    deliveryNotes?: string | null
    hyphenBuildProId?: string | null
    holtPortalId?: string | null
    signatureUrl?: string | null
    photoUrls?: PurchaseOrderCreatephotoUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobOptionUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: PlanOptionUpdateOneRequiredWithoutJobOptionsNestedInput
  }

  export type JobOptionUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOptionUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    hyphenBuildProId?: NullableStringFieldUpdateOperationsInput | string | null
    holtPortalId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrls?: PurchaseOrderUpdatephotoUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffLineItemCreateManyTakeoffInput = {
    id?: string
    materialId: string
    quantityEstimated: Decimal | DecimalJsLike | number | string
    quantityActual?: Decimal | DecimalJsLike | number | string | null
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalEstimated: Decimal | DecimalJsLike | number | string
    totalActual?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    variancePercent?: Decimal | DecimalJsLike | number | string | null
    varianceReason?: string | null
    category: string
    subcategory?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakeoffLineItemUpdateWithoutTakeoffInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutTakeoffLineItemsNestedInput
  }

  export type TakeoffLineItemUncheckedUpdateWithoutTakeoffInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakeoffLineItemUncheckedUpdateManyWithoutTakeoffInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    quantityEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEstimated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variancePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceReviewCreateManyPatternInput = {
    id?: string
    reviewerId: string
    decision: $Enums.ReviewDecision
    notes?: string | null
    reviewedAt?: Date | string
  }

  export type VarianceReviewUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutVarianceReviewsNestedInput
  }

  export type VarianceReviewUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceReviewUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}