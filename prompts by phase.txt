# MindFlow Platform: Claude Code Launch Plan
**Systematic, Incremental Development Guide with Prompts**

---

## How to Use This Guide

**Structure:**
- Each phase broken into 2-week sprints
- Each sprint has specific Claude Code prompts
- Prompts are copy/paste ready
- Checkpoints verify progress before moving forward
- Natural pause points if you need to step away

**Working with Claude Code:**
1. Start each session by sharing relevant context files
2. Use the prompts in order (they build on each other)
3. Test each component before moving to the next
4. Commit to git after each successful prompt
5. Take notes on what worked/what didn't for future sessions

**Time Expectations:**
- Each sprint = 2 weeks = 40-50 development hours
- Each prompt = 2-4 hours of work (coding + testing)
- Plan for 3-4 prompts per week (10-15 hours)

---

## Table of Contents

**Phase 0: Foundation Setup (Week 0)**
**Phase 1: Foundation Layer (Weeks 1-16)**
- Sprint 1-2: Customer Database
- Sprint 3-4: Plans Management  
- Sprint 5-8: Materials & Pricing

**Phase 2: Operational Core (Weeks 17-36)**
- Sprint 9-10: Communities & Lots
- Sprint 11-13: Order Creation & Job Management
- Sprint 14-16: Plan Takeoffs & Validation

**Phase 3: Transaction Layer (Weeks 37-52)**
- Sprint 17-19: Purchase Orders Management
- Sprint 20-22: Order Calendar & Scheduling

**Phase 4: Intelligence Layer (Weeks 53-64)**
- Sprint 23-24: Communications Hub
- Sprint 25-28: Reporting & Analytics

**Phase 5: Integration & Polish (Weeks 65-72)**
- Sprint 29-30: External System Connectors
- Sprint 31-32: Performance & Launch Prep

---

# Phase 0: Foundation Setup
**Timeline:** Week 0 (5-10 hours)  
**Goal:** Establish development environment and project structure

## Prompt 0.1: Initialize Project Structure

```
I'm building MindFlow, a construction management platform. This will be a full-stack application with:
- Frontend: React 18 + TypeScript + Vite + TailwindCSS
- Backend: Node.js + Express + PostgreSQL
- Deployment: Vercel (frontend) + Railway (backend)

Please create the initial project structure with:
1. Root directory with two folders: /frontend and /backend
2. Frontend setup (similar to the Universal Project Manager we built):
   - Vite + React + TypeScript
   - TailwindCSS configured
   - React Router for navigation
   - Basic folder structure: /src/components, /src/services, /src/hooks, /src/types, /src/utils
3. Backend setup:
   - Express.js server with TypeScript
   - PostgreSQL connection with Prisma ORM
   - Basic folder structure: /src/routes, /src/controllers, /src/services, /src/middleware
4. Shared types folder for TypeScript interfaces used by both frontend and backend
5. Package.json scripts for:
   - Frontend dev server
   - Backend dev server
   - Full-stack dev (concurrent)
   - Build for production
6. .gitignore with appropriate exclusions
7. README.md with setup instructions

Use modern best practices and ensure everything is typed with TypeScript.
```

**Expected Output:**
- `/frontend` folder with Vite React app
- `/backend` folder with Express API
- `/shared` folder with TypeScript types
- Root package.json with scripts
- Basic README

**Testing:**
```bash
# Install dependencies
npm install

# Start development servers
npm run dev

# Should see:
# - Frontend at http://localhost:5173
# - Backend at http://localhost:3001
```

**Success Criteria:**
- ✅ Both servers start without errors
- ✅ Frontend shows "Hello World" or default page
- ✅ Backend responds to GET /health with 200 OK
- ✅ TypeScript compiles with zero errors

---

## Prompt 0.2: Database Connection & Prisma Setup

```
Set up PostgreSQL database connection using Prisma ORM:

1. Create docker-compose.yml for local PostgreSQL development database
2. Configure Prisma in /backend:
   - Install @prisma/client and prisma dev dependency
   - Create prisma/schema.prisma with PostgreSQL datasource
   - Set up initial User model (for testing connection)
3. Create database service in /backend/src/services/database.ts that:
   - Initializes Prisma client
   - Handles connection pooling
   - Provides error handling
   - Exports singleton instance
4. Add npm scripts for:
   - prisma:generate (generate Prisma client)
   - prisma:migrate (run migrations)
   - prisma:studio (open Prisma Studio)
5. Create first migration for User table
6. Update backend server to:
   - Import database service
   - Test connection on startup
   - Log success/failure

Environment variables should use .env file (not committed) with .env.example as template.
```

**Expected Output:**
- `docker-compose.yml` for PostgreSQL
- Prisma schema with User model
- Database service with connection handling
- First migration created

**Testing:**
```bash
# Start PostgreSQL
docker-compose up -d

# Run migrations
npm run prisma:migrate

# Start backend
npm run dev:backend

# Should see log: "Database connected successfully"

# Open Prisma Studio
npm run prisma:studio
# Should see User table
```

**Success Criteria:**
- ✅ PostgreSQL running in Docker
- ✅ Prisma client generated
- ✅ Backend connects to database
- ✅ Can view schema in Prisma Studio

---

## Prompt 0.3: Authentication Setup

```
Implement JWT-based authentication system:

1. Add User model to Prisma schema with:
   - id (UUID)
   - email (unique)
   - password_hash
   - first_name, last_name
   - role (enum: admin, estimator, pm, field_user)
   - created_at, updated_at

2. Create auth service (/backend/src/services/auth.ts):
   - register(email, password, role) - hash password with bcrypt
   - login(email, password) - verify and return JWT
   - verifyToken(token) - validate JWT
   - refreshToken(token) - generate new token

3. Create auth middleware (/backend/src/middleware/auth.ts):
   - authenticateToken - verify JWT from headers
   - requireRole(...roles) - check user has required role

4. Create auth routes (/backend/src/routes/auth.ts):
   - POST /api/auth/register
   - POST /api/auth/login
   - POST /api/auth/refresh
   - GET /api/auth/me (get current user)

5. Create auth context for frontend (/frontend/src/contexts/AuthContext.tsx):
   - Login/logout functions
   - Current user state
   - Token storage (localStorage)
   - Protected route wrapper

6. Add login/register pages to frontend

Use jsonwebtoken for JWT, bcrypt for password hashing. JWT secret should be in .env.
```

**Expected Output:**
- User model in database
- Auth service with registration/login
- JWT middleware for protected routes
- Auth context for frontend
- Login/register UI

**Testing:**
```bash
# Use Postman or curl:

# Register new user
curl -X POST http://localhost:3001/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@mindflow.com","password":"test123","role":"admin"}'

# Login
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@mindflow.com","password":"test123"}'

# Should receive JWT token
```

**Success Criteria:**
- ✅ User can register via API
- ✅ User can login and receive JWT
- ✅ Protected routes require valid JWT
- ✅ Frontend login form works
- ✅ AuthContext stores user state

---

## Prompt 0.4: Base UI Components & Layout

```
Create reusable UI component library and application layout:

1. Install shadcn/ui components (or similar component library)

2. Create base components in /frontend/src/components/ui:
   - Button (primary, secondary, danger variants)
   - Input (text, number, date, select)
   - Card (for content containers)
   - Modal (reusable dialog)
   - Table (data tables with sorting)
   - Loading (spinner component)
   - Toast (notification system)

3. Create layout components:
   - MainLayout.tsx - sidebar + header + main content area
   - Sidebar.tsx - navigation menu
   - Header.tsx - user menu, notifications icon
   - PageHeader.tsx - page titles and breadcrumbs

4. Create navigation structure:
   - Dashboard (home)
   - Foundation (customers, plans, materials)
   - Operations (jobs, takeoffs)
   - Transactions (POs, schedule)
   - Reports (analytics)
   - Settings (user profile, system config)

5. Set up routing in App.tsx with:
   - Public routes (login, register)
   - Protected routes (dashboard, modules)
   - 404 page

6. Create theme configuration:
   - Color palette (primary, secondary, accent, neutral)
   - Typography scale
   - Spacing system
   - Mobile breakpoints

Match the design patterns from Universal Project Manager for consistency.
```

**Expected Output:**
- Reusable UI component library
- Main application layout with sidebar
- Navigation routing
- Theme system

**Testing:**
- Visit each route and verify layout renders
- Test responsiveness (resize browser window)
- Verify protected routes redirect to login

**Success Criteria:**
- ✅ All UI components render correctly
- ✅ Navigation works (can click between pages)
- ✅ Layout is responsive (mobile, tablet, desktop)
- ✅ Theme is consistent across pages

---

**Phase 0 Complete!** You now have:
- ✅ Full-stack development environment
- ✅ Database connection with Prisma
- ✅ Authentication system
- ✅ Base UI components and layout

**Commit checkpoint:** `git commit -m "Phase 0: Development environment setup complete"`

---

# Phase 1: Foundation Layer
**Timeline:** Weeks 1-16 (4 months)  
**Goal:** Build single source of truth for customers, plans, and pricing

---

## Sprint 1-2: Customer Database (Weeks 1-4)

### Prompt 1.1: Customer Schema & Models

```
Create the Customer Database module for MindFlow. This is part of the Foundation Layer and will be the authoritative source for all customer information.

Context: Production builders like RICHMOND and HOLT have different pricing tiers, multiple contacts, and specific business rules. We need to track all of this while maintaining mappings to external systems (Sales 1440, Hyphen BuildPro, Holt Builder Portal).

Tasks:

1. Create Prisma schema models in /backend/prisma/schema.prisma:

```prisma
model Customer {
  id              String   @id @default(uuid())
  customerName    String   @map("customer_name")
  customerType    CustomerType @map("customer_type")
  pricingTier     String?  @map("pricing_tier")
  primaryContactId String? @map("primary_contact_id")
  isActive        Boolean  @default(true) @map("is_active")
  notes           String?
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  contacts        CustomerContact[]
  pricingTiers    CustomerPricingTier[]
  externalIds     CustomerExternalId[]
  jobs            Job[]
  
  @@map("customers")
}

enum CustomerType {
  PRODUCTION
  SEMI_CUSTOM
  FULL_CUSTOM
}

model CustomerContact {
  id                    String   @id @default(uuid())
  customerId            String   @map("customer_id")
  contactName           String   @map("contact_name")
  role                  String?
  email                 String?
  phone                 String?
  receivesNotifications Boolean  @default(true) @map("receives_notifications")
  isPrimary             Boolean  @default(false) @map("is_primary")
  createdAt             DateTime @default(now()) @map("created_at")
  
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@map("customer_contacts")
}

model CustomerPricingTier {
  id                  String   @id @default(uuid())
  customerId          String   @map("customer_id")
  tierName            String   @map("tier_name")
  discountPercentage  Decimal  @map("discount_percentage") @db.Decimal(5, 2)
  effectiveDate       DateTime @map("effective_date")
  expirationDate      DateTime? @map("expiration_date")
  createdAt           DateTime @default(now()) @map("created_at")
  
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@map("customer_pricing_tiers")
}

model CustomerExternalId {
  id                   String   @id @default(uuid())
  customerId           String   @map("customer_id")
  externalSystem       String   @map("external_system")
  externalCustomerId   String   @map("external_customer_id")
  externalCustomerName String?  @map("external_customer_name")
  isPrimary            Boolean  @default(false) @map("is_primary")
  createdAt            DateTime @default(now()) @map("created_at")
  
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@unique([customerId, externalSystem])
  @@map("customer_external_ids")
}
```

2. Create TypeScript types in /shared/types/customer.ts

3. Run migration: `npx prisma migrate dev --name create_customers`

4. Create seed data with 3 sample customers (RICHMOND, HOLT, and one generic builder) in /backend/prisma/seed.ts

Expected outcome: Database tables created, seed data loaded, types generated.
```

**Testing:**
```bash
npm run prisma:migrate
npm run prisma:seed
npm run prisma:studio
# Verify 3 customers appear in Prisma Studio
```

**Success Criteria:**
- ✅ All customer tables created
- ✅ Seed data loads successfully
- ✅ Relationships work (customer → contacts)

---

### Prompt 1.2: Customer Service & Repository

```
Create the service layer for Customer management following Repository pattern:

Context: We want clean separation between database operations (repository) and business logic (service). This makes the code testable and maintainable.

Tasks:

1. Create Customer Repository in /backend/src/repositories/CustomerRepository.ts:
   - findAll(filters?, pagination?)
   - findById(id)
   - findByExternalId(system, externalId)
   - create(data)
   - update(id, data)
   - delete(id)
   - All methods should use Prisma and return typed results

2. Create Customer Service in /backend/src/services/CustomerService.ts:
   - getAllCustomers(filters?, page?, limit?) - includes pagination
   - getCustomerById(id) - includes related contacts and pricing tiers
   - createCustomer(customerData) - validates data, creates customer
   - updateCustomer(id, updates) - validates changes
   - deleteCustomer(id) - checks for dependencies (can't delete if has jobs)
   - addContact(customerId, contactData)
   - updateContact(contactId, updates)
   - deleteContact(contactId)
   - addPricingTier(customerId, tierData)
   - getCurrentPricingTier(customerId) - gets active tier for today
   - mapExternalId(customerId, system, externalId)

3. Add input validation using Zod schemas in /backend/src/validators/customer.ts

4. Create error classes in /backend/src/errors:
   - CustomerNotFoundError
   - CustomerHasDependenciesError
   - InvalidCustomerDataError

Service methods should:
- Validate inputs before calling repository
- Throw appropriate errors
- Log operations for audit trail
- Handle edge cases (e.g., primary contact logic)

Use dependency injection pattern (pass repository to service constructor).
```

**Testing:**
```typescript
// Create test file: /backend/src/services/__tests__/CustomerService.test.ts
// Test each service method
```

**Success Criteria:**
- ✅ All repository methods work
- ✅ Service validates inputs
- ✅ Can create customer with contacts
- ✅ getCurrentPricingTier returns correct tier

---

### Prompt 1.3: Customer API Routes

```
Create RESTful API endpoints for Customer management:

Context: These endpoints will be used by the frontend admin interface. Follow REST conventions and include proper error handling.

Tasks:

1. Create Customer Controller in /backend/src/controllers/CustomerController.ts:
   - getAllCustomers (GET with query params for filters/pagination)
   - getCustomer (GET by ID)
   - createCustomer (POST with body validation)
   - updateCustomer (PUT/PATCH by ID)
   - deleteCustomer (DELETE by ID with confirmation)
   - getCustomerContacts (GET customer's contacts)
   - addCustomerContact (POST)
   - updateCustomerContact (PUT)
   - deleteCustomerContact (DELETE)
   - getCustomerPricingTiers (GET)
   - addCustomerPricingTier (POST)
   - getCurrentPricingTier (GET - convenience endpoint)

2. Create routes in /backend/src/routes/customer.ts:
   - All routes should be under /api/customers
   - Apply authentication middleware (requireAuth)
   - Apply role-based access (admin and estimator can create/edit, others read-only)
   - Include request validation middleware

3. Add error handling middleware in /backend/src/middleware/errorHandler.ts:
   - Catch and format errors
   - Return appropriate HTTP status codes
   - Log errors for debugging
   - Hide sensitive info in production

4. Register routes in main server file

Example route structure:
```typescript
GET    /api/customers
GET    /api/customers/:id
POST   /api/customers
PUT    /api/customers/:id
DELETE /api/customers/:id
GET    /api/customers/:id/contacts
POST   /api/customers/:id/contacts
PUT    /api/customers/:id/contacts/:contactId
DELETE /api/customers/:id/contacts/:contactId
GET    /api/customers/:id/pricing-tiers
POST   /api/customers/:id/pricing-tiers
GET    /api/customers/:id/current-pricing
```

Include Swagger/OpenAPI documentation for all endpoints.
```

**Testing:**
```bash
# Use Postman collection or curl:

# Get all customers
curl http://localhost:3001/api/customers \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# Create customer
curl -X POST http://localhost:3001/api/customers \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "customerName": "Test Builder",
    "customerType": "PRODUCTION",
    "pricingTier": "Tier 2"
  }'

# Add contact
curl -X POST http://localhost:3001/api/customers/{id}/contacts \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "contactName": "John Smith",
    "email": "john@testbuilder.com",
    "role": "Project Manager"
  }'
```

**Success Criteria:**
- ✅ All endpoints return correct status codes
- ✅ Validation rejects invalid data
- ✅ Authentication required for all routes
- ✅ Role-based access works
- ✅ Errors return helpful messages

---

### Prompt 1.4: Customer Admin UI (Frontend)

```
Create the Customer management interface for administrators:

Context: This is where admin users will manage customer records, contacts, and pricing tiers. The UI should be intuitive and efficient for daily use.

Tasks:

1. Create Customer List Page in /frontend/src/pages/customers/CustomerList.tsx:
   - Table showing all customers with columns: Name, Type, Pricing Tier, # Contacts, Status
   - Search/filter by name, type, active status
   - Pagination (20 per page)
   - Sort by any column
   - "Add Customer" button (opens modal)
   - Row actions: Edit, View Details, Archive

2. Create Customer Detail Page in /frontend/src/pages/customers/CustomerDetail.tsx:
   - Three tabs: Overview, Contacts, Pricing History
   - Overview tab: Customer info, external IDs, notes
   - Contacts tab: List of contacts with add/edit/delete
   - Pricing History tab: Timeline of pricing tier changes
   - "Edit Customer" button

3. Create Customer Form Modal in /frontend/src/components/customers/CustomerFormModal.tsx:
   - Form fields: Name, Type (dropdown), Pricing Tier, Notes
   - Validation (required fields, format checks)
   - Used for both create and edit
   - Cancel/Save buttons

4. Create Contact Form Modal in /frontend/src/components/customers/ContactFormModal.tsx:
   - Form fields: Name, Role, Email, Phone, Receives Notifications checkbox, Is Primary checkbox
   - Email/phone validation
   - Used for both create and edit

5. Create API service in /frontend/src/services/customerService.ts:
   - Wraps all customer API endpoints
   - Handles loading states
   - Manages error handling
   - Uses React Query for caching

6. Add Customers link to sidebar navigation

Design should match Universal Project Manager styling. Use the same component library (shadcn/ui or whatever was set up in Phase 0).
```

**Testing:**
- Navigate to /customers
- Create a new customer
- Add 2 contacts to that customer
- Edit customer name
- Delete a contact
- Verify all changes persist (refresh page)

**Success Criteria:**
- ✅ Can view list of all customers
- ✅ Can create new customer
- ✅ Can edit existing customer
- ✅ Can add/edit/delete contacts
- ✅ Form validation works
- ✅ Loading states display
- ✅ Error messages show for API failures

---

### Prompt 1.5: External ID Mapping UI

```
Create interface for mapping customers to external system identifiers:

Context: RICHMOND uses Hyphen BuildPro, HOLT has their own portal, and we need to maintain these external identifiers for bidirectional sync. This UI helps administrators set up and manage these mappings.

Tasks:

1. Add "External Systems" tab to Customer Detail Page

2. Create External ID Manager component in /frontend/src/components/customers/ExternalIdManager.tsx:
   - Table showing current mappings: System, External ID, External Name, Is Primary, Date Added
   - "Add Mapping" button
   - Row actions: Edit, Delete, Set as Primary

3. Create External ID Form Modal:
   - System dropdown (Sales 1440, Hyphen BuildPro, Holt Portal, Other)
   - External Customer ID field
   - External Customer Name field (optional)
   - Is Primary checkbox (only one per system)
   - Help text explaining what each field is for

4. Add validation:
   - Can't have duplicate system mappings (unique per customer + system)
   - External ID required
   - Warn if changing primary

5. Create API endpoints (if not already created):
   - GET /api/customers/:id/external-ids
   - POST /api/customers/:id/external-ids
   - PUT /api/customers/:id/external-ids/:mappingId
   - DELETE /api/customers/:id/external-ids/:mappingId

Include helpful UI elements:
- Tooltip explaining why external IDs are important
- Example IDs for each system type
- Visual indicator for primary mapping
```

**Testing:**
- Open customer detail page
- Go to External Systems tab
- Add mapping for "Hyphen BuildPro" with ID "RICH-001"
- Add mapping for "Holt Portal" with ID "HOLT-RICHMOND"
- Set one as primary
- Try to add duplicate (should be blocked)
- Delete a mapping

**Success Criteria:**
- ✅ Can add external ID mappings
- ✅ Can edit/delete mappings
- ✅ Primary flag works correctly
- ✅ Validation prevents duplicates
- ✅ UI explains purpose of mappings

---

## Sprint 1-2 Complete! 
**Checkpoint:** Customer Database module is now functional

**Test the complete workflow:**
1. Create a new customer "Test Builder Inc"
2. Set customer type to "Production"
3. Add pricing tier "Tier 2" at 7% discount
4. Add 3 contacts with different roles
5. Map to external system "Hyphen BuildPro"
6. Verify everything saves and displays correctly

**Commit:** `git commit -m "Sprint 1-2: Customer Database complete"`

---

## Sprint 3-4: Plans Management (Weeks 5-8)

### Prompt 1.6: Plans Schema & Models

```
Create the Plans Management module for MindFlow's Foundation Layer.

Context: Plans are the blueprints for houses. Each plan has a base design, multiple elevations (facade variations A/B/C/D), and options (upgrades like 3-car garage, extended patio). We need to handle:
1. Plan versioning (plans evolve over time)
2. Dual representation (human-readable names like "2400BDE-RIV" AND machine-queryable components)
3. External system mapping (same plan has different codes in different systems)
4. Option availability per elevation
5. PDSS (Plan Design & Specification Sheet) document storage

Tasks:

1. Create Prisma schema models in /backend/prisma/schema.prisma:

```prisma
model Plan {
  id                String    @id @default(uuid())
  planNumber        String    @map("plan_number") // '2400', 'G17', '167'
  planName          String?   @map("plan_name") // 'The Oakmont', 'Sierra'
  baseSquareFootage Int       @map("base_square_footage")
  stories           Decimal   @db.Decimal(2, 1) // 1.0, 1.5, 2.0
  bedrooms          Int
  bathrooms         Decimal   @db.Decimal(3, 1)
  garageBays        Int?      @map("garage_bays")
  version           String    @default("1.0")
  effectiveDate     DateTime  @default(now()) @map("effective_date")
  deprecatedDate    DateTime? @map("deprecated_date")
  isActive          Boolean   @default(true) @map("is_active")
  description       String?
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")
  
  elevations        Elevation[]
  options           PlanOption[]
  nameComponents    PlanNameComponent[]
  specifications    PlanSpecification[]
  externalIds       PlanExternalId[]
  materialTemplates PlanMaterialTemplate[]
  jobs              Job[]
  
  @@unique([planNumber, version])
  @@map("plans")
}

model Elevation {
  id              String   @id @default(uuid())
  planId          String   @map("plan_id")
  elevationCode   String   @map("elevation_code") // 'A', 'B', 'C', 'D'
  elevationName   String?  @map("elevation_name") // 'Craftsman', 'Colonial'
  exteriorStyle   String?  @map("exterior_style")
  isAvailable     Boolean  @default(true) @map("is_available")
  sortOrder       Int      @default(0) @map("sort_order")
  createdAt       DateTime @default(now()) @map("created_at")
  
  plan            Plan     @relation(fields: [planId], references: [id], onDelete: Cascade)
  specifications  PlanSpecification[]
  externalIds     PlanExternalId[]
  packElevations  PackElevation[]
  jobs            Job[]
  
  @@unique([planId, elevationCode])
  @@map("elevations")
}

model PlanOption {
  id               String   @id @default(uuid())
  planId           String   @map("plan_id")
  optionCode       String   @map("option_code") // 'B', 'D', 'E', 'BDE'
  optionName       String   @map("option_name") // 'Extended Patio', '3-Car Garage'
  optionCategory   String?  @map("option_category") // 'Exterior', 'Interior', 'Structural'
  basePriceImpact  Decimal? @map("base_price_impact") @db.Decimal(10, 2)
  isAvailable      Boolean  @default(true) @map("is_available")
  sortOrder        Int      @default(0) @map("sort_order")
  description      String?
  createdAt        DateTime @default(now()) @map("created_at")
  
  plan             Plan     @relation(fields: [planId], references: [id], onDelete: Cascade)
  requirements     OptionMaterialRequirement[]
  jobOptions       JobOption[]
  
  @@unique([planId, optionCode])
  @@map("plan_options")
}

// Dual Representation: Parse "2400BDE-RIV" into queryable components
model PlanNameComponent {
  id               String   @id @default(uuid())
  planId           String   @map("plan_id")
  originalPlanName String   @map("original_plan_name") // '2400BDE-RIV'
  basePlanNumber   String   @map("base_plan_number") // '2400'
  optionCodes      Json     @map("option_codes") // ['B', 'D', 'E']
  subdivisionCode  String?  @map("subdivision_code") // 'RIV'
  elevationCode    String?  @map("elevation_code") // 'C'
  parsedAt         DateTime @default(now()) @map("parsed_at")
  
  plan             Plan     @relation(fields: [planId], references: [id], onDelete: Cascade)
  
  @@unique([planId, originalPlanName])
  @@map("plan_name_components")
}

// External system mappings (backward compatibility)
model PlanExternalId {
  id               String     @id @default(uuid())
  planId           String     @map("plan_id")
  elevationId      String?    @map("elevation_id")
  externalSystem   String     @map("external_system") // 'sales_1440', 'buildpro', 'holt_portal'
  externalPlanCode String     @map("external_plan_code") // 'G17F', '16701...'
  createdAt        DateTime   @default(now()) @map("created_at")
  
  plan             Plan       @relation(fields: [planId], references: [id], onDelete: Cascade)
  elevation        Elevation? @relation(fields: [elevationId], references: [id], onDelete: Cascade)
  
  @@unique([planId, elevationId, externalSystem])
  @@map("plan_external_ids")
}

// PDSS document storage
model PlanSpecification {
  id              String     @id @default(uuid())
  planId          String     @map("plan_id")
  elevationId     String?    @map("elevation_id")
  specDocumentUrl String     @map("spec_document_url") // S3 or storage URL
  specVersion     String     @map("spec_version")
  effectiveDate   DateTime   @map("effective_date")
  uploadedBy      String     @map("uploaded_by")
  fileSize        Int?       @map("file_size")
  fileType        String?    @map("file_type")
  createdAt       DateTime   @default(now()) @map("created_at")
  
  plan            Plan       @relation(fields: [planId], references: [id], onDelete: Cascade)
  elevation       Elevation? @relation(fields: [elevationId], references: [id], onDelete: SetNull)
  
  @@map("plan_specifications")
}
```

2. Create TypeScript types in /shared/types/plan.ts

3. Run migration: `npx prisma migrate dev --name create_plans`

4. Create seed data in /backend/prisma/seeds/plans.ts:
   - RICHMOND Plan 2400 with elevations A, B, C, D
   - Options: B (Extended Patio), D (Upgraded Kitchen), E (3-Car Garage)
   - External IDs for Hyphen (G17A, G17B, etc.)
   - HOLT Plan 167 with elevations A, B
   - External IDs for Holt Portal (167010105, etc.)

Expected outcome: All plan tables created, seed data with 2 complete plans.
```

**Testing:**
```bash
npm run prisma:migrate
npm run prisma:seed
npm run prisma:studio
# Verify plans appear with elevations and options
```

**Success Criteria:**
- ✅ Plan tables created
- ✅ Seed data loads 2 plans
- ✅ Relationships work (plan → elevations → options)
- ✅ External IDs stored correctly

---

### Prompt 1.7: Plan Name Parser Service

```
Create intelligent plan name parsing service:

Context: Plans are often referred to by compact codes like "2400BDE-RIV" which encode multiple pieces of information. We need to parse these into structured, queryable data while preserving the original human-readable name.

Example inputs and expected parsing:
- "2400BDE-RIV" → Plan: 2400, Options: [B,D,E], Subdivision: RIV
- "G17F" → Plan: G17, Elevation: F
- "167-02-GARAGE3C" → Plan: 167, Elevation: 02, Option: GARAGE3C
- "Plan 2400 with options B and D in Riverside" → Plan: 2400, Options: [B,D], Subdivision: Riverside

Tasks:

1. Create Plan Name Parser in /backend/src/services/PlanNameParser.ts:
   - parseConventional(name) - handles standard patterns like "2400BDE-RIV"
   - parseNaturalLanguage(text) - extracts plan info from free text
   - validate(name) - checks if name follows known patterns
   - normalize(name) - standardizes format
   - detectPattern(name) - identifies which builder's convention this follows

2. Create parsing rules configuration in /backend/src/config/planNamingRules.ts:
   - Richmond pattern: "LetterNumber + Elevation" (G17F)
   - Holt pattern: "Number-Number-Option" (167-02-GARAGE3C)
   - Generic pattern: "Number + Options + Subdivision" (2400BDE-RIV)
   - Custom patterns (admin-definable)

3. Create service method to auto-populate PlanNameComponent table:
   - When a plan is created with originalPlanName, automatically parse it
   - Store parsed components for querying
   - Flag unparseable names for manual review

4. Add API endpoint: POST /api/plans/parse-name
   - Takes: { planName: string }
   - Returns: { components: ParsedComponents, confidence: number }
   - Used by frontend to validate plan names before saving

5. Create unit tests in /backend/src/services/__tests__/PlanNameParser.test.ts:
   - Test each parsing pattern
   - Test edge cases (malformed names, ambiguous patterns)
   - Test confidence scoring

Parser should:
- Handle variations (spaces, hyphens, case-insensitive)
- Return confidence score (0-1) for fuzzy matches
- Support custom regex patterns
- Log ambiguous parses for improvement
```

**Testing:**
```typescript
// Test parsing:
const parser = new PlanNameParser();

parser.parseConventional("2400BDE-RIV");
// Expected: { basePlan: "2400", options: ["B","D","E"], subdivision: "RIV" }

parser.parseConventional("G17F");
// Expected: { basePlan: "G17", elevation: "F" }

parser.parseNaturalLanguage("Plan 2400 with 3 car garage in Riverside");
// Expected: { basePlan: "2400", options: ["3 car garage"], subdivision: "Riverside" }

// Test via API:
curl -X POST http://localhost:3001/api/plans/parse-name \
  -H "Content-Type: application/json" \
  -d '{"planName":"2400BDE-RIV"}'
```

**Success Criteria:**
- ✅ Parses Richmond convention (G17F)
- ✅ Parses Holt convention (167-02-...)
- ✅ Parses generic convention (2400BDE-RIV)
- ✅ Returns confidence score
- ✅ Handles malformed inputs gracefully

---

### Prompt 1.8: Plans Service & Repository

```
Create service layer for Plans management:

Context: Plans module needs comprehensive CRUD operations plus specialized queries (find plans by option, find plans for community, check plan compatibility).

Tasks:

1. Create Plan Repository in /backend/src/repositories/PlanRepository.ts:
   - findAll(filters?, pagination?) - filters: isActive, hasOption, minSqFt, maxSqFt
   - findById(id) - includes elevations, options, specifications
   - findByNumber(planNumber, version?) - lookup by plan number
   - findByExternalId(system, externalCode)
   - findByOption(optionCode) - all plans that have this option
   - create(planData)
   - update(id, updates)
   - deprecate(id, deprecatedDate) - soft delete
   - addElevation(planId, elevationData)
   - addOption(planId, optionData)
   - addSpecification(planId, specData)

2. Create Plan Service in /backend/src/services/PlanService.ts:
   - getAllPlans(filters?, page?, limit?)
   - getPlanById(id) - full details
   - getPlanByNumber(planNumber, version?)
   - createPlan(planData) - validates, parses name, creates plan
   - updatePlan(id, updates)
   - deprecatePlan(id, reason) - marks as inactive, logs reason
   - clonePlan(id, newVersion) - creates new version from existing
   - getElevations(planId)
   - addElevation(planId, elevationData) - validates elevation code
   - updateElevation(elevationId, updates)
   - deleteElevation(elevationId) - checks for dependencies
   - getOptions(planId)
   - addOption(planId, optionData)
   - updateOption(optionId, updates)
   - deleteOption(optionId) - checks for dependencies
   - uploadSpecification(planId, elevationId?, file) - handles file upload to S3
   - getSpecifications(planId, elevationId?)
   - mapExternalId(planId, elevationId?, system, externalCode)
   - translateFromExternal(system, externalCode) - looks up MindFlow plan
   - translateToExternal(planId, elevationId, targetSystem) - gets external code

3. Create validation schemas in /backend/src/validators/plan.ts:
   - CreatePlanSchema (required: planNumber, sqft, stories, beds, baths)
   - UpdatePlanSchema (all fields optional)
   - ElevationSchema (required: code, must be A-Z)
   - OptionSchema (required: code, name)

4. Create specialized query service in /backend/src/services/PlanQueryService.ts:
   - findPlansForCommunity(communityId) - checks community rules
   - findSimilarPlans(planId) - by sqft, beds, baths
   - getPlanPopularity() - most frequently built plans
   - getAverageCosts(planId) - across all jobs

Business logic:
- When deprecating plan, ensure no active jobs reference it
- When parsing plan name, auto-create PlanNameComponent entry
- Elevation codes must be unique per plan
- Option codes must be unique per plan
- File uploads should go to S3 with naming convention: plans/{planId}/specs/{elevationId}_{version}.pdf
```

**Testing:**
```typescript
// Test creating plan with auto-parsing:
const planData = {
  planNumber: "2400",
  planName: "The Oakmont",
  baseSquareFootage: 2400,
  stories: 2.0,
  bedrooms: 4,
  bathrooms: 2.5,
  garageBays: 2,
  originalPlanName: "2400BDE-RIV" // Should auto-parse
};

const plan = await planService.createPlan(planData);
// Verify PlanNameComponent was created with parsed data

// Test external ID translation:
const mindflowPlan = await planService.translateFromExternal("buildpro", "G17F");
// Should return Plan 2400, Elevation F

const externalCode = await planService.translateToExternal(planId, elevationId, "holt_portal");
// Should return Holt's code for this plan
```

**Success Criteria:**
- ✅ Can create plan with all related data
- ✅ Plan name parsing happens automatically
- ✅ External ID translation works bidirectionally
- ✅ Can't delete plans/elevations/options with dependencies
- ✅ Validation prevents invalid data

---

### Prompt 1.9: Plans API Routes

```
Create RESTful API endpoints for Plans management:

Tasks:

1. Create Plan Controller in /backend/src/controllers/PlanController.ts:
   - getAllPlans
   - getPlan
   - createPlan
   - updatePlan
   - deprecatePlan (soft delete)
   - clonePlan (create new version)
   - searchPlans (advanced search)
   - getElevations
   - addElevation
   - updateElevation
   - deleteElevation
   - getOptions
   - addOption
   - updateOption
   - deleteOption
   - uploadSpecification (handles file upload)
   - getSpecifications
   - translatePlan (external code conversion)

2. Create routes in /backend/src/routes/plan.ts:

```typescript
// Plans
GET    /api/plans
GET    /api/plans/search (with query params)
GET    /api/plans/:id
POST   /api/plans
PUT    /api/plans/:id
DELETE /api/plans/:id (deprecate)
POST   /api/plans/:id/clone
POST   /api/plans/translate (body: { system, externalCode })

// Elevations
GET    /api/plans/:id/elevations
POST   /api/plans/:id/elevations
PUT    /api/plans/:id/elevations/:elevationId
DELETE /api/plans/:id/elevations/:elevationId

// Options
GET    /api/plans/:id/options
POST   /api/plans/:id/options
PUT    /api/plans/:id/options/:optionId
DELETE /api/plans/:id/options/:optionId

// Specifications (PDSS)
GET    /api/plans/:id/specifications
POST   /api/plans/:id/specifications (multipart/form-data for file upload)
GET    /api/plans/:id/specifications/:specId/download

// External IDs
GET    /api/plans/:id/external-ids
POST   /api/plans/:id/external-ids
```

3. Implement file upload handling:
   - Use multer for multipart/form-data
   - Upload to S3 (or local storage for dev)
   - Generate presigned URLs for downloads
   - Validate file types (PDF only for PDSS)
   - Max file size: 10MB

4. Add search endpoint with filters:
   - planNumber (partial match)
   - minSqFt, maxSqFt
   - stories
   - bedrooms (exact or min/max)
   - hasOption (option code)
   - isActive
   - Sort by: sqft, planNumber, popularity

5. Apply authentication and authorization:
   - Read: All authenticated users
   - Create/Update: Admin, Estimator
   - Delete: Admin only

Include Swagger documentation with example requests/responses.
```

**Testing:**
```bash
# Search plans
curl "http://localhost:3001/api/plans/search?minSqFt=2000&maxSqFt=3000&bedrooms=4" \
  -H "Authorization: Bearer $TOKEN"

# Create plan
curl -X POST http://localhost:3001/api/plans \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "planNumber": "3000",
    "planName": "The Grand Vista",
    "baseSquareFootage": 3000,
    "stories": 2,
    "bedrooms": 5,
    "bathrooms": 3.5,
    "garageBays": 3
  }'

# Add elevation
curl -X POST http://localhost:3001/api/plans/{id}/elevations \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "elevationCode": "A",
    "elevationName": "Craftsman",
    "exteriorStyle": "Traditional"
  }'

# Upload PDSS
curl -X POST http://localhost:3001/api/plans/{id}/specifications \
  -H "Authorization: Bearer $TOKEN" \
  -F "file=@plan2400_specs.pdf" \
  -F "specVersion=2.1" \
  -F "elevationId={elevationId}"

# Translate external code
curl -X POST http://localhost:3001/api/plans/translate \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "externalSystem": "buildpro",
    "externalCode": "G17F"
  }'
```

**Success Criteria:**
- ✅ All endpoints return correct data
- ✅ Search filters work correctly
- ✅ File upload stores PDSS documents
- ✅ Translation endpoint converts external codes
- ✅ Authorization prevents unauthorized actions

---

### Prompt 1.10: Plans Admin UI (Frontend)

```
Create the Plans management interface:

Context: This is where administrators and estimators manage the plan library. The interface needs to handle the complexity of plans, elevations, options, and specifications in an organized, user-friendly way.

Tasks:

1. Create Plans List Page in /frontend/src/pages/plans/PlansList.tsx:
   - Card/Grid view of plans with thumbnails (if available)
   - Shows: Plan Number, Name, Sq Ft, Beds/Baths, # Elevations, # Options, Status
   - Search by plan number or name
   - Filter by: Sq Ft range, Stories, Bedrooms, Active status
   - Sort by: Plan Number, Sq Ft, Popularity
   - "Add Plan" button
   - Quick actions per plan: View, Edit, Clone, Deprecate

2. Create Plan Detail Page in /frontend/src/pages/plans/PlanDetail.tsx:
   - Tabs: Overview, Elevations, Options, Specifications, External IDs, History
   
   **Overview Tab:**
   - Plan details (number, name, sqft, beds, baths, etc.)
   - Version history
   - Status (active/deprecated)
   - Edit button
   
   **Elevations Tab:**
   - Grid of elevation cards (A, B, C, D)
   - Each card shows elevation code, name, style
   - "Add Elevation" button
   - Click card to edit
   
   **Options Tab:**
   - Table of options with columns: Code, Name, Category, Price Impact, Availability
   - Group by category
   - "Add Option" button
   - Inline edit for quick changes
   
   **Specifications Tab:**
   - List of PDSS documents with version, date, elevation
   - Download button per document
   - Upload new specification button
   - Preview PDF inline (if possible)
   
   **External IDs Tab:**
   - Table: System, External Code, Elevation, Date Added
   - Add/Edit/Delete mappings
   - Test translation button (shows what this translates to)
   
   **History Tab:**
   - Audit log of changes to this plan
   - Who changed what, when

3. Create Plan Form Modal in /frontend/src/components/plans/PlanFormModal.tsx:
   - Fields: Plan Number, Plan Name, Sq Ft, Stories, Beds, Baths, Garage Bays, Description
   - Optional: Original Plan Name (triggers parsing)
   - Parse button that shows what would be extracted
   - Version field (for cloning)
   - Used for create, edit, and clone operations

4. Create Elevation Form Modal:
   - Fields: Code (A-D dropdown), Name, Exterior Style
   - Is Available checkbox
   - Visual preview if possible (placeholder image)

5. Create Option Form Modal:
   - Fields: Code, Name, Category (dropdown), Base Price Impact, Description
   - Is Available checkbox
   - Multi-select: Which elevations is this available for?

6. Create Specification Upload Modal:
   - File picker (PDF only)
   - Version field
   - Elevation selector (optional - for elevation-specific specs)
   - Effective date
   - Upload progress bar

7. Create API service in /frontend/src/services/planService.ts:
   - Wraps all plan API endpoints
   - Handles file uploads with progress tracking
   - Caches plan data with React Query

8. Create reusable components:
   - PlanCard (for list view)
   - ElevationBadge (shows A/B/C/D)
   - OptionTag (shows option codes)
   - SpecificationViewer (PDF viewer)

Design patterns:
- Use tabs for organizing complex data
- Inline editing where possible (options table)
- Modal forms for create/edit
- Confirm dialogs for delete/deprecate actions
- Loading skeletons while data fetches
- Empty states with helpful messages ("No plans yet. Add your first plan!")
```

**Testing Workflow:**
1. Navigate to /plans
2. Create new plan "3500 Custom" with 3500 sq ft, 5 beds, 4 baths
3. Add elevation A "Craftsman" and B "Colonial"
4. Add option "DECK" = "Extended Deck" with $5000 price impact
5. Upload PDSS document for elevation A
6. Add external ID mapping for Hyphen BuildPro
7. Test translation (input external code, verify it finds this plan)
8. Clone plan to create version 2.0
9. Deprecate original version
10. Verify all data persists (refresh page)

**Success Criteria:**
- ✅ Plans list displays with search/filter
- ✅ Can create new plan
- ✅ Can add elevations and options
- ✅ Can upload PDSS files
- ✅ PDF viewer shows uploaded specs
- ✅ External ID translation works
- ✅ Can clone plan (creates new version)
- ✅ Form validation prevents invalid data
- ✅ All UI responsive on mobile

---

## Sprint 3-4 Complete!
**Checkpoint:** Plans Management module is now functional

**Test the complete workflow:**
1. Create RICHMOND Plan 2400 with 4 elevations (A, B, C, D)
2. Add 5 options (B=Patio, D=Kitchen, E=Garage, etc.)
3. Upload PDSS for each elevation
4. Map to external IDs:
   - Hyphen BuildPro: G17A, G17B, G17C, G17D
   - Holt Portal: 167010105, 167020105, etc.
5. Test translation both ways (external → MindFlow, MindFlow → external)
6. Clone plan to create version 2.0
7. Search for plans with option "E"
8. Verify everything works

**Commit:** `git commit -m "Sprint 3-4: Plans Management complete"`

---

## Sprint 5-8: Materials & Pricing (Weeks 9-16)

### Prompt 1.11: Materials Schema & Models

```
Create the Materials & Pricing Management module - the economic engine of MindFlow.

Context: This is the most complex module in the Foundation Layer. Materials have base vendor costs, but the final price depends on:
- Commodity market fluctuations (lumber prices change daily via Random Lengths index)
- Customer pricing tiers (Tier 2 gets 7% discount)
- Length adders (longer boards cost more)
- Grade multipliers (premium materials cost more)
- Applied margins (20% markup)

We need transparent pricing pipeline where every calculation step is visible and auditable.

Tasks:

1. Create Prisma schema models in /backend/prisma/schema.prisma:

```prisma
model Material {
  id                String   @id @default(uuid())
  materialSku       String   @unique @map("material_sku")
  materialName      String   @map("material_name")
  materialCategory  String   @map("material_category") // 'Lumber', 'Trusses', 'Siding', etc.
  unitOfMeasure     String   @map("unit_of_measure") // 'board_feet', 'linear_feet', 'each'
  baseVendorCost    Decimal  @map("base_vendor_cost") @db.Decimal(10, 4)
  vendorId          String?  @map("vendor_id")
  isCommodityPriced Boolean  @default(false) @map("is_commodity_priced")
  commodityCategory String?  @map("commodity_category") // 'SPF_LUMBER', 'OSB'
  description       String?
  isActive          Boolean  @default(true) @map("is_active")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")
  
  vendor            Vendor?  @relation(fields: [vendorId], references: [id])
  pricingRules      PricingRule[]
  externalIds       MaterialExternalId[]
  lumberDetails     LumberCalculation?
  lengthPricing     LengthPricingAdder[]
  calculations      PriceCalculation[]
  
  @@map("materials")
}

model Vendor {
  id           String   @id @default(uuid())
  vendorName   String   @map("vendor_name")
  contactName  String?  @map("contact_name")
  email        String?
  phone        String?
  paymentTerms String?  @map("payment_terms")
  leadTimeDays Int?     @map("lead_time_days")
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  
  materials    Material[]
  purchaseOrders PurchaseOrder[]
  
  @@map("vendors")
}

// The Pricing Pipeline Engine
model PricingRule {
  id                String   @id @default(uuid())
  materialId        String?  @map("material_id") // null = applies globally
  customerId        String?  @map("customer_id") // null = applies to all customers
  ruleType          String   @map("rule_type") // 'commodity_adjustment', 'customer_tier', 'length_adder', 'margin'
  rulePriority      Int      @map("rule_priority") // Order of application
  calculationMethod String   @map("calculation_method") // 'percentage', 'fixed_amount', 'formula'
  ruleParameters    Json     @map("rule_parameters") // Flexible config
  effectiveDate     DateTime @map("effective_date")
  expirationDate    DateTime? @map("expiration_date")
  isActive          Boolean  @default(true) @map("is_active")
  createdAt         DateTime @default(now()) @map("created_at")
  
  material          Material? @relation(fields: [materialId], references: [id], onDelete: Cascade)
  customer          Customer? @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@map("pricing_rules")
}

// Commodity price tracking (Random Lengths, etc.)
model CommodityPricing {
  id               String   @id @default(uuid())
  materialCategory String   @map("material_category") // 'SPF_LUMBER', 'OSB'
  priceDate        DateTime @map("price_date")
  indexValue       Decimal  @map("index_value") @db.Decimal(10, 4)
  percentageChange Decimal  @map("percentage_change") @db.Decimal(5, 2)
  source           String   // 'random_lengths', 'manual'
  notes            String?
  createdAt        DateTime @default(now()) @map("created_at")
  
  @@unique([materialCategory, priceDate])
  @@map("commodity_pricing")
}

// Transparent price breakdown (audit trail)
model PriceCalculation {
  id                   String   @id @default(uuid())
  materialId           String   @map("material_id")
  customerId           String?  @map("customer_id")
  calculatedAt         DateTime @default(now()) @map("calculated_at")
  baseCost             Decimal  @map("base_cost") @db.Decimal(10, 4)
  commodityAdjustment  Decimal  @default(0) @map("commodity_adjustment") @db.Decimal(10, 4)
  customerDiscount     Decimal  @default(0) @map("customer_discount") @db.Decimal(10, 4)
  lengthAdder          Decimal  @default(0) @map("length_adder") @db.Decimal(10, 4)
  marginAmount         Decimal  @map("margin_amount") @db.Decimal(10, 4)
  finalPrice           Decimal  @map("final_price") @db.Decimal(10, 4)
  calculationBreakdown Json     @map("calculation_breakdown") // Full step-by-step
  
  material             Material @relation(fields: [materialId], references: [id], onDelete: Cascade)
  customer             Customer? @relation(fields: [customerId], references: [id])
  
  @@index([materialId, customerId, calculatedAt])
  @@map("price_calculations")
}

// Domain-specific: MBF lumber calculations
model LumberCalculation {
  id              String   @id @default(uuid())
  materialId      String   @unique @map("material_id")
  nominalSize     String   @map("nominal_size") // '2x4', '2x6', '2x10'
  actualDimensions String  @map("actual_dimensions") // '1.5x3.5'
  pricePerMbf     Decimal? @map("price_per_mbf") @db.Decimal(10, 2) // Per thousand board feet
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  material        Material @relation(fields: [materialId], references: [id], onDelete: Cascade)
  
  @@map("lumber_calculations")
}

// Length-based pricing adders
model LengthPricingAdder {
  id                 String   @id @default(uuid())
  materialId         String   @map("material_id")
  baseLengthFeet     Int      @map("base_length_feet")
  lengthIncrementFeet Int     @map("length_increment_feet")
  adderPerIncrement  Decimal  @map("adder_per_increment") @db.Decimal(10, 2)
  createdAt          DateTime @default(now()) @map("created_at")
  
  material           Material @relation(fields: [materialId], references: [id], onDelete: Cascade)
  
  @@map("length_pricing_adders")
}

// External system mappings
model MaterialExternalId {
  id                String   @id @default(uuid())
  materialId        String   @map("material_id")
  externalSystem    String   @map("external_system")
  externalSku       String   @map("external_sku")
  externalItemNumber String? @map("external_item_number") // Richmond R-codes
  externalTradeCode String?  @map("external_trade_code") // Holt 4-digit codes
  createdAt         DateTime @default(now()) @map("created_at")
  
  material          Material @relation(fields: [materialId], references: [id], onDelete: Cascade)
  
  @@unique([materialId, externalSystem])
  @@map("material_external_ids")
}
```

2. Create TypeScript types in /shared/types/material.ts and /shared/types/pricing.ts

3. Run migration: `npx prisma migrate dev --name create_materials_pricing`

4. Create seed data in /backend/prisma/seeds/materials.ts:
   - 20+ common materials across categories:
     - Lumber: 2x4, 2x6, 2x10 (with MBF calculations)
     - Trusses: Roof trusses, floor trusses
     - Siding: Vinyl, fiber cement
     - Concrete: Foundation, flatwork
   - 3 vendors
   - Commodity pricing history (last 30 days for lumber)
   - Sample pricing rules (Tier 2 discount, margin rules)
   - External ID mappings for Richmond and Holt

Expected outcome: Materials catalog with transparent pricing logic.
```

**Testing:**
```bash
npm run prisma:migrate
npm run prisma:seed
npm run prisma:studio
# Verify materials appear with pricing rules
```

**Success Criteria:**
- ✅ Materials tables created
- ✅ Seed data loads 20+ materials
- ✅ Lumber calculations present
- ✅ Commodity pricing history exists
- ✅ Pricing rules configured

---

### Prompt 1.12: Pricing Pipeline Engine

```
Create the transparent pricing pipeline service:

Context: This is the "complexity engine" that calculates material costs. Unlike black-box systems, every step of the calculation is visible and logged. The pipeline processes materials through sequential transformations:

1. Start with base vendor cost
2. Apply commodity adjustment (if lumber)
3. Apply customer tier discount
4. Apply length adders (if applicable)
5. Apply margin
6. Return final price WITH full breakdown

Tasks:

1. Create Pricing Pipeline Service in /backend/src/services/PricingPipelineService.ts:

```typescript
interface PriceCalculationStep {
  step: number;
  name: string;
  input: number;
  adjustment: number;
  output: number;
  explanation: string;
  ruleApplied?: string;
}

interface PriceBreakdown {
  materialId: string;
  materialName: string;
  customerId?: string;
  baseCost: number;
  steps: PriceCalculationStep[];
  finalPrice: number;
  calculatedAt: Date;
  confidence: number; // 1.0 = all rules current, <1.0 = some rules expired
}

class PricingPipelineService {
  // Main calculation method
  async calculatePrice(
    materialId: string,
    customerId?: string,
    quantity?: number,
    lengthFeet?: number,
    calculationDate: Date = new Date()
  ): Promise<PriceBreakdown>

  // Individual pipeline steps
  private async applyBaseCost(material: Material): Promise<PriceCalculationStep>
  private async applyCommodityAdjustment(material: Material, baseCost: number, date: Date): Promise<PriceCalculationStep>
  private async applyCustomerDiscount(customerId: string, currentCost: number): Promise<PriceCalculationStep>
  private async applyLengthAdder(material: Material, currentCost: number, lengthFeet: number): Promise<PriceCalculationStep>
  private async applyMargin(currentCost: number, marginRule: PricingRule): Promise<PriceCalculationStep>

  // Utility methods
  async getApplicableRules(materialId: string, customerId?: string, date: Date): Promise<PricingRule[]>
  async getCurrentCommodityPrice(category: string, date: Date): Promise<CommodityPricing | null>
  async validatePricingRules(materialId: string): Promise<{ valid: boolean; issues: string[] }>
  
  // Caching and optimization
  async cachePriceCalculation(calculation: PriceBreakdown): Promise<void>
  async getCachedPrice(materialId: string, customerId?: string, maxAgeHours: number = 24): Promise<PriceBreakdown | null>
}
```

2. Implement commodity pricing integration:
   - Fetch latest Random Lengths index for lumber categories
   - Calculate percentage change from base cost
   - Apply percentage adjustment
   - Log source and confidence

3. Implement customer tier logic:
   - Look up customer's current pricing tier
   - Apply tier discount percentage
   - Handle tier effective dates (use tier active on calculation date)

4. Implement MBF calculator for lumber:
   - Convert quantity + length to board feet
   - Calculate MBF (board feet / 1000)
   - Apply price per MBF
   - Handle standard vs. custom sizes

5. Create validation service in /backend/src/services/PricingValidationService.ts:
   - detectStalePrices(materialIds) - flags materials with pricing >30 days old
   - detectMissingRules(materialIds) - flags materials without margin rules
   - detectAnomalies(calculations) - flags unusual price changes (>15% from typical)
   - suggestRuleUpdates() - recommends updating based on historical data

6. Add logging:
   - Log every price calculation to PriceCalculation table
   - Include full breakdown JSON
   - Enable audit trail ("who calculated what price when")

Pipeline should:
- Be deterministic (same inputs = same output)
- Handle missing data gracefully (default to base cost if no rules)
- Cache recent calculations (avoid recalculating same price repeatedly)
- Support "as of" date calculations (historical pricing)
```

**Testing:**
```typescript
// Test complete pipeline:
const pipeline = new PricingPipelineService();

// Test 1: Simple material (no commodity, no length adder)
const price1 = await pipeline.calculatePrice(
  "material-id-for-trim", 
  "richmond-customer-id"
);
console.log(price1.finalPrice); // Should show final price
console.log(price1.steps); // Should show: base → customer discount → margin

// Test 2: Lumber with commodity pricing
const price2 = await pipeline.calculatePrice(
  "material-id-for-2x4", 
  "richmond-customer-id",
  500, // quantity
  8 // length in feet
);
console.log(price2.steps); 
// Should show: base → commodity adjustment → customer discount → MBF calc → margin

// Test 3: Historical pricing
const price3 = await pipeline.calculatePrice(
  "material-id",
  "customer-id",
  undefined,
  undefined,
  new Date('2024-01-15') // Calculate price as it was on Jan 15
);

// Test 4: Validation
const validation = await pipeline.validatePricingRules("material-id");
console.log(validation.issues); // Should show any missing or expired rules
```

**Success Criteria:**
- ✅ Pipeline calculates prices correctly
- ✅ Breakdown shows every step transparently
- ✅ Commodity adjustments apply for lumber
- ✅ Customer tier discounts apply correctly
- ✅ MBF calculations accurate
- ✅ Caching reduces redundant calculations
- ✅ Validation detects stale prices

---

### Prompt 1.13: Materials Service & Repository

```
Create service layer for Materials & Pricing management:

Context: Materials management needs comprehensive CRUD plus specialized queries (find materials by category, check pricing freshness, batch price calculations).

Tasks:

1. Create Material Repository in /backend/src/repositories/MaterialRepository.ts:
   - findAll(filters?, pagination?)
   - findById(id) - includes vendor, pricing rules, external IDs
   - findBySku(sku)
   - findByCategory(category)
   - findByExternalId(system, externalSku)
   - findCommodityMaterials() - all materials with isCommodityPriced = true
   - create(materialData)
   - update(id, updates)
   - delete(id) - soft delete (isActive = false)

2. Create Material Service in /backend/src/services/MaterialService.ts:
   - getAllMaterials(filters?, page?, limit?)
   - getMaterialById(id) - full details
   - getMaterialBySku(sku)
   - createMaterial(materialData) - validates, creates material
   - updateMaterial(id, updates)
   - deleteMaterial(id) - checks dependencies
   - bulkImport(materials[]) - import from CSV/Excel
   - getMaterialsByCategory(category)
   - searchMaterials(query) - fuzzy search by name or SKU
   - addPricingRule(materialId, ruleData)
   - updatePricingRule(ruleId, updates)
   - deletePricingRule(ruleId)
   - getActivePricingRules(materialId, customerId?, date?)
   - mapExternalId(materialId, system, externalSku)
   - translateFromExternal(system, externalSku)
   - translateToExternal(materialId, targetSystem)

3. Create Vendor Service in /backend/src/services/VendorService.ts:
   - getAllVendors()
   - getVendorById(id)
   - createVendor(vendorData)
   - updateVendor(id, updates)
   - deleteVendor(id)
   - getVendorMaterials(vendorId) - all materials from this vendor
   - getVendorPerformance(vendorId) - on-time delivery rate, etc.

4. Create Commodity Pricing Service in /backend/src/services/CommodityPricingService.ts:
   - getLatestPrice(category) - most recent commodity price
   - getPriceHistory(category, startDate, endDate) - historical data
   - updateCommodityPrice(category, indexValue, source) - manual update
   - importPrices(file) - batch import from Random Lengths export
   - detectPriceSpikes(threshold) - alert on unusual changes

5. Create Batch Pricing Service in /backend/src/services/BatchPricingService.ts:
   - calculateBatch(materialIds[], customerId?, date?)
   - Returns array of PriceBreakdowns
   - Optimized for calculating hundreds of prices at once
   - Used by takeoff generation

6. Create validation schemas in /backend/src/validators/material.ts:
   - CreateMaterialSchema
   - UpdateMaterialSchema
   - PricingRuleSchema
   - CommodityPriceSchema

Business logic:
- Can't delete materials referenced in takeoffs or POs
- Pricing rules must have valid date ranges
- Customer-specific rules override global rules
- Commodity prices must be sequential (no gaps in date history)
- External SKU mappings must be unique per system
```

**Testing:**
```typescript
// Test material creation with pricing rule:
const material = await materialService.createMaterial({
  materialSku: "LBR-2X4-8",
  materialName: "2x4x8 SPF Lumber",
  materialCategory: "LUMBER",
  unitOfMeasure: "board_feet",
  baseVendorCost: 3.50,
  isCommodityPriced: true,
  commodityCategory: "SPF_LUMBER"
});

// Add margin rule (20%)
await materialService.addPricingRule(material.id, {
  ruleType: "margin",
  rulePriority: 100,
  calculationMethod: "percentage",
  ruleParameters: { percentage: 20 },
  effectiveDate: new Date()
});

// Test batch pricing:
const materialIds = [/* array of 50 material IDs */];
const prices = await batchPricingService.calculateBatch(
  materialIds,
  "richmond-customer-id"
);
console.log(`Calculated ${prices.length} prices`);
// Should complete in <1 second

// Test commodity price update:
await commodityPricingService.updateCommodityPrice(
  "SPF_LUMBER",
  425.50, // index value
  "random_lengths"
);

// Verify this affects lumber pricing:
const newPrice = await pricingPipeline.calculatePrice("LBR-2X4-8");
// Should reflect updated commodity price
```

**Success Criteria:**
- ✅ All CRUD operations work
- ✅ Batch pricing handles 100+ materials efficiently
- ✅ Commodity price updates propagate to calculations
- ✅ External ID translation works
- ✅ Validation prevents invalid data
- ✅ Can't delete materials with dependencies

---

*Due to length limits, I'll continue with the remaining prompts in the next response. Would you like me to continue with:*

1. **Prompt 1.14:** Materials & Pricing API Routes
2. **Prompt 1.15:** Materials Admin UI (Frontend)
3. **Prompt 1.16:** Pricing Calculator UI
4. **Prompt 1.17:** Commodity Price Import Tool
5. **Sprint 5-8 Integration Testing**

Then move into **Phase 2: Operational Core** with job management, takeoffs, etc.?

Let me know if you'd like me to continue, or if you'd like me to adjust the format/detail level of the prompts!